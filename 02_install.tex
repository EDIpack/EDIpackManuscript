\documentclass[edipack_sp.tex]{subfiles}
\begin{document}

\section{Installation}\label{SecInstall}
The configuration and installation of \NAME is handled by CMake, which ensures
multi-platforms compabitility and dependencies resolution.  
The software builds into two distinct libraries.
The main one is a static Fortran library called {\tt  libedipack.a} which, alongside the compiled
modules, wraps the \NAME software in both its single- and multi-impurity variants.
A second dynamic library, {\tt libedipack\_cbindings.so}, together with the associated header
file {\tt edipack\_cbindings.h}, enables interoperability with other programming languages.  


\subsection{Structure}\label{sSecInstallStructure}
\NAME is a modular library organized into three main components. At its 
core, constituting the primary computational engine, 
is the exact diagonalization solver for the quantum single-impurity Hamiltonian.
Building on this, the library includes 
{\tt EDIpack2ineq}, an extension for handling multiple inequivalent 
impurity problems. Finally, the Fortran-C/C++ interface is provided for 
seamless integration with external software and the development of 
additional APIs.


\begin{itemize}
\item{\bf EDIpack.}
  This module forms the foundation of the library, implementing the 
  Lanczos-based solver for general quantum impurity problems. It 
  supports systems with a wide range of symmetries leveraging different quantum numbers conservation, multi-orbital models, and even coupling to local 
  phonons. The \NAME solver is structured hierarchically and modularly, 
  with different sections of the library communicating through a shared 
  memory layer. The top-level module, {\tt EDIPACK}, provides access 
  to the core Fortran API, exposing key procedures for initialization, 
  execution, and finalization, while abstracting the underlying data 
  structures. A detailed overview of this part of the library is 
  provided in \secu{SecEDIpack}.
  
\item{\bf EDIpack2ineq.}
  This extension, developed using modern Fortran constructs,
  enables the treatment of multiple, independent quantum 
impurities. It is particularly useful in DMFT applications involving 
unit cells with inequivalent atomic sites or systems with broken 
translational symmetry, such as heterostructures, large supercells, 
or disordered materials. This module provides flexible memory 
management and supports the simultaneous solution of multiple impurity 
problems, as discussed in Sec.\ref{sSecIneq}.



\item{\bf EDIpack C-bindings.}
  For enhanced interoperability, \NAME includes a dedicated module 
implementing Fortran-C/C++ bindings for key library procedures. This 
module relies on the {\tt ISO\_C\_BINDING} capabilities available in 
modern Fortran, allowing direct translation of Fortran functions to C. 
To ensure a straightforward user experience, only the functions and 
variables directly exposed to the user are included in this binding, 
shielding developers from the complexity of the library's internal 
architecture. This interface is intended to facilitate integration 
with third-party software and support the development of custom APIs.
\end{itemize}




\subsection{Dependencies}\label{sSecInstallDependencies}
\NAME directly depends on two external libraries.
\begin{itemize}
\item {\bf SciFortran}: an open-source Fortran library to support
  mathematical and scientific software development. 
\item {\bf MPI} (optional): a distributed memory parallel communication layer with support to modern Fortran compiler.
\end{itemize}
 
SciFortran provides a solid development platform enabling access to
many algorithms and functions, including standard linear algebra
operations and high-performance Lanczos based algorithms. This
greatly reduces code clutter and development time.
The use of distributed memory parallel environment, although optional,
is required to access scalable parallel diagonalization algorithms
which speed up calculations for large dimensional systems. 

\subsection{Build and Install}\label{sSecInstallBuildInstall}
\subsubsection{Compilation from source}
The software can be installed from source as follows. The source code can
be retrieved directly from its GitHub repository, for instance using:
\begin{lstlisting}[style=mybash,numbers=none]
git clone https://github.com/edipack/EDIpack 
\end{lstlisting}
Then, assuming to be in the software directory, a conventional
out-of-source building can be performed using two alternative compilation backends.

\begin{itemize}
  \item {\bf GNU Make}\\
This is the default CMake workflow:
\begin{lstlisting}[style=mybash,numbers=none]
mkdir build
cd build
cmake ..
make -j
make install
\end{lstlisting}


\item{\bf Ninja}

An alternative workflow employs the Ninja building backend with
Fortran support. Ninja is generally faster and automatically supports
multi-threaded building:
\begin{lstlisting}[style=mybash,numbers=none]
mkdir build
cd build
cmake -GNinja ..
ninja
ninja install
\end{lstlisting}
\end{itemize}

\noindent
The CMake configuration can be further tuned using the following variables:
\begin{center}
\begin{tabular}{ l|l|l } 
 \hline
  {\bf Option}               & {\bf Scope} & {\bf Value} \\
  \hline
  -D{\bf PREFIX}          & Install directory  & $\sim$/opt/EDIpack/TAG/PLAT/BRANCH\\
  -D{\bf USE\_MPI}       & MPI support  &  True/{\color{red}False}\\
  -D{\bf WITH\_INEQ}   & Inequivalent impurities support & {\color{red}True}/{False}\\
  -D{\bf VERBOSE}      & Verbose CMake output & {\color{red}True}/{False}\\ 
  -D{\bf BUILD\_TYPE} & Compilation flags & {\color{red}RELEASE}/TESTING/DEBUG/AGGRESSIVE \\
 \hline
\end{tabular}
\end{center}

The default target builds and installs both the main library and the C-bindings.
Separate build targets for either are available. A recap message is printed at the end of the
CMake configuration step. 

\subsubsection{Anaconda}
As an alternative, we provide for both Linux and macOS systems
installation through Anaconda packages into a virtual
environment containing Python ($>3.10$).

The Conda package installation procedure reads:
\begin{lstlisting}[style=mybash,numbers=none]
conda create -n edipack
conda activate edipack
conda install -c conda-forge -c edipack edipack
\end{lstlisting}
\noindent
which installs a bundle of SciFortran and \NAME libraries together with
specific {\tt pkg-config} configurations files, which can be used to
retrieve compilation and linking flags. In order to compile Fortran/C++ 
drivers, the {\tt compilers} conda package will need to be installed.


\subsection{OS Loading}\label{sSecInstallOSloading}
In order to avoid possible conflicts or the requirement for administrative
privileges, the building step results are installed by default in the user's {\tt HOME}
directory, specified by the CMake variable {\tt PREFIX}.
As a consequence, the system library and include paths will need to be updated by the user.

We offer different ways to perform this action:
\begin{enumerate}
\item  A CMake-generated configuration file for an environment module
  which allows to load and unload the library at any time. This is
  preferred solution for HPC systems. 
\item A CMake-generated bash script to be sourced (once or
  permanently) in any shell session to add \NAME library to the
  default environment.
\item A CMake generated {\tt pkg-config} file to be added in
  the {\tt PKG\_CONFIG\_PATH} itself.  
\end{enumerate}
An automatically generated recap message with all instructions is
generated at the end of the installation procedure. 

\end{document}








