\documentclass[edipack2.tex]{subfiles}
\begin{document}

\section{Interoperability}\label{SecInterop}
The recent growing availability of state-of-the-art software dedicated
to the solution of quantum impurity problems using different methods
poses a serious challenge to test accuracy and realiability of the
results.
As such, complex softwares are requested to develop a higher level of
interoperability, i.e. the possibility to operate with other software
possibly using different programming language.
Modern Fortran, which is the language of choice for \NAME, since many
years supports the standardized generation of procedures and
variables that are interoperable with C.


\subsection{C-bindings}\label{sSecInteropCbindings}
The interoperability with C language is provided by the
{\tt ISO\_C\_BINDING} module, which is part of the Fortran
standard since 2003. The module contains definitions of named
constants, types and procedures for C interoperability.
Alongside, a second key feature essential to expose to C any Fortran
entity is the {\tt BIND(C)} intrinsic function.
In \NAME we exploit these features of the language to provide a
complete interface from the Fortran code to C/C++, i.e. {\tt
  EDIpack2C}. 


\subsubsection{Installation and inclusion}\label{sSecInteropCbindingsInstallation}
The C-binding module in included in the build process of \NAME and
compiled into a dynamical library {\tt
  libedipack2\_cbinding.so/.dylib}. As dicussed in the
\secu{sSecInstallBuildInstall}, the support for inequivalent
impurities is configured at the build level and propagates to the
C-bindings library as well. An exported variable {\tt has\_ineq} is
defined and export to C/C++ as a way to query the presence of
inequivalent impurities support. 
The generated library and header files get installed in the include
directory at the prefix location, specified during configuration
step. The corresponding path is added to the environment variable {\tt
  LD\_LIBRARY\_PATH}, valid of any Unix/Linux system, via any of the
loading methods outlines in \secu{sSecInstallOSloading}. 

The C/C++ compatible functions and variables 
are declared in the header file  {\tt edipack2\_cbinding.h}.
Since {\tt ISO\_C\_BINDING} only provides, to date, C compatibility, the 
functions and variables are declared with C linkage, which prevents name mangling.
Function overloading is not supported, hence all interfaced Fortran functions,
for example supporting multiple input variables combinations with different types
and ranks, are here represented by multiple alternative functions.
As an example, the {\tt ed\_chi2\_fitgf} Fortran function, which handles the fitting of bath parameters, is callable in C++ in the following variants
\begin{itemize}
    \item  {\tt chi2\_fitgf\_single\_normal\_n3}: for {\tt ED\_MODE=NORMAL/NONSU2}, single-site DMFT and rank-3 Weiss field/hybridization function arrays
    \item  {\tt chi2\_fitgf\_single\_normal\_n5}: for {\tt ED\_MODE=NORMAL/NONSU2}, single-site DMFT and rank-5 Weiss field/hybridization function arrays
    \item  {\tt chi2\_fitgf\_single\_superc\_n3}: for {\tt ED\_MODE=SUPERC}, single-site DMFT and rank-3 Weiss field/hybridization function arrays
    \item  {\tt chi2\_fitgf\_single\_superc\_n5}: for {\tt ED\_MODE=SUPERC}, single-site DMFT and rank-5 Weiss field/hybridization function arrays
\end{itemize}
and analogous functions for the real-space DMFT case. All functions are listed and documented in the online manual.
When using EDIpack2 functions in a C/C++ program, care must be taken in the way arrays are passed. Consistently with {\tt ISO\_C\_BINDING}, non-scalar parameters have to be passed as raw pointers. An array of integers containing the dimensions of the former need to be passed as well to allow for proper Fortran input parsing. A working C++ example is provided in the {\tt examples} folder of the EDIpack2 repository.

\subsubsection{Implementation}\label{sSecInteropCbindingsImplementation}
The interface layer is contained in the Fortran module {\tt
  EDIpack2\_C}. This contains a common part and two set of functions,
one to interface the procedures from \NAME and a second
one to extend the interface to the inequivalent impurities case.
Specifically, the implemented interface functions expose to C through
{\tt bind(C)} statement a number of
procedures composing the Fortran API of \NAME, i.e. contained in {\tt
  ED\_MAIN}. The procedures and shared variables can be divided in four main groups:

\paragraph{{\bf Variables}}
A number of relevant input and shared variables which are normally
required to setup or to control the calculation are interfaced to C
directly in the \NAME modules {\tt ED\_INPUT\_VARIABLES} using {\tt
  bind(C)} constructs. These are implicitly loaded into the C-binding module {\tt
  EDIpack2\_C} through the Fortran {\tt USE EDIPACK2} statement and
then further interfaced in the C++ header file. 


\paragraph{{\bf Main}} This group contains interface to the exact
digonalization solver, interfacing the solver itself {\tt
  solve\_site/ineq} as well as its initialization
{\tt init\_solver\_site/ineq} and finalization {\tt
  finalize\_solver} procedures. It also includes the functions used to
set the non-interacting part of the impurity Hamiltonian
$h^0_{\a\b\s\s'}$ through the functions {\tt set\_Hloc}, as well as the
interaction Hamiltonian through {\tt add\_twobody\_operator}.


\paragraph{{\bf Bath}} In this group we implement a number of
procedures dealing with bath initialization, symmetry operations and
optimization. In particular it contains the function returning the
dimension of the bath array on the user side {\tt
  get\_bath\_dimension} as well as the setup of the matrix basis
$\vec{\Gamma}$ for the replica/general bath via different instances of
{\tt set\_Hreplica/general\_{site,lattice}\_d{3,5}}. 
The crucial part in the DMFT-Lanczos self-consistency loop is the optimization of the bath
through conjugate-gradient algorithm. To this end we interfaced a
number of functions {\tt
  chi2\_fitgf\_{single,lattice}\_{normal,superc}\_n{3,4,5,6}} which
cover all the cases supported in \NAME. Note that, because the actual
optimization is still performed through the Fortran code, no changes
apply to the outcome of this step.    

\paragraph{{\bf Input/Output}}
The input and output part of the software is interfaced in this group
of functions. In particular, {\tt read\_input} expose to C the input
reading procedure of \NAME which set essentially set all the internal
variables of \NAME.
Next, in {\tt edipack{2ineq}\_c\_binding\_io} we interface all the
functions implementing the communication from the \NAME instance to
the user, namely those to retrieve static observables (e.g. {\tt
  get\_dens}), the impurity Green's functions and self-energies
(e.g. {\tt get\_Sigma\_{site,lattice}\_n{3,5}}), the
impurity susceptibilities (e.g. {\tt get\_spinChi}), the impurity reduced density matrix as well
as the non-interacting Green's and hybridization functions starting from the
user bath array.   


% ##################################################################
% ##################################################################




\subsection{EDIpy2, the Python API}\label{sSecInteropEDIpy}
As a first application of the \NAME C-bindings we implemented a
complete Python interface, i.e. EDIpy2. This is a Python module which
enables access to all the library features and unlock implementation of
further interfaces of \NAME as a plug-in solver for external Python
based software.    


\subsubsection{Installation}\label{sSecInteropEDIpyInstallation}
EDIpy2 is available as a stand-alone
module which only depends on \NAME and SciFortran.
The Python package can be obtained from the repository
\href{https://github.com/EDIpack/EDIpy2.0}{EDIpy2}.

\begin{lstlisting}[style=mybash]
git clone https://github.com/edipack/EDIpy2 EDIpy2
cd EDIpy2
pip install . 
\end{lstlisting}
In some more recent Python distribution the flag {\tt
  --break-system-packages} might be required to complete
installation or a virtual environment should be used instead. 


\paragraph{PyPi}
The EDIpy2 package is also available in PyPi at
\href{https://pypi.org/project/edipy2/}{pypi.org/edipy2}. As such
EDIpy2 can be conveniently installed in any system supporting {\tt pip} as:

\begin{lstlisting}[style=mybash]
pip install edipy2
\end{lstlisting}


\paragraph{Anaconda}
As for \NAME, the Python API in EDIpy2 is available through
Anaconda packaging for Unix/Linux systems. Packages are available for
Python version $>3.10$. The EDIpack2.0 package contains the {\tt
  edipy2} Python module as well as the EDIpack2.0 and SciFortran
libraries. In this case the resolution of the dependencies is
taken care from Conda itself. 
Using conda the installation reads:
\begin{lstlisting}[style=mybash]
conda create -n edipack
conda activate edipack
conda install -c conda-forge -c edipack edipack2
\end{lstlisting}


Once installed, any loading of the {\tt edipy2} module resolves in the
attempt to load the dynamic library {\tt
  libedipack2\_cbinding.so/.dylib} containing the Fortran-C bindings
for \NAME. By default the library is searched proceeds as follow: 
\begin{enumerate}
\item First the user can override the location of the library
  (determined during \NAME build configuration) by exporting an
  environment variable called {\tt EDIPACK\_PATH} .
\item By default, the Python module detects the position of the
  Fortran libraries via {\tt pkg-config}. Any of the OS loading method
  outlined in \secu{sSecInstallOSloading} automatically push the
  correct configuration to the {\tt PKG\_CONFIG\_PATH}. 
\item As a last resort the environment variables {\tt
    LD\_LIBRARY\_PATH} and {\tt DYLD\_LIBRARY\_PATH} are analyzed to
  retrieve the correct position. 
\end{enumerate}
If none of the previous attempts succeeds, the module will not not load correctly and an error message will be printed. 



\subsubsection{Implementation}\label{sSecInteropEDIpyImplementation}
The Python API provided in the edipy2 module consists essentially of a
suitable class called for convenience {\tt global\_env}.
The class incorporates all the global variables inherited from \NAME
C-bindings library and implements a number of interface functions
leveraging the Python duck typing to \NAME.  
The variables and the functions of \NAME are exposed to the user and
are accessed as properties and
methods of the {\tt global\_env} claass, which needs to be imported at the beginning
of the python script, along with other useful modules. For instance Numpy is
necessary, while mpi4py is strongly recommended.

\begin{lstlisting}[language=python,  frame=lines]
import numpy as np
import mpi4py
from mpi4py import MPI
from edipy2 import global_env as ed
import os,sys
\end{lstlisting}

The EDIpy2 supports the solution of problems with independent
impurities, interfacing with the the EDIpack2ineq extension of the
library, if present. Should the inequivalent impurities package not be
built, the Python module silently disable the support to it, so that
invoking any related procedure  will result in a {\tt RuntimeError}.
The user can check the availability of the inequivalent impurities
interface by querying the value of  {\tt edipy2.global\_env.has\_ineq}.

The implementation of the Python API is divided in two main parts. The
first is a set of global variables, the second includes 4 groups of
functions: solver, bath, input/output, auxiliary. 

\paragraph{{\bf Global variables}}
This includes a subset of the input variables available in \NAME which
are used to control the calculation.
The variables are loaded globally in {\tt EDIpy2} and can be accessed
or set locally as properties of the class {\tt
  global\_env}. Differently these are initialized, alongside the remaining
default input variables, through a call to procedure {\tt
  edipy2.global\_env.read\_input} which interface the {\tt
  ed\_read\_input} function in \NAME. 
A given example is reported in the following code extract:

\begin{lstlisting}[language=python,  frame=lines]
import numpy as np
from edipy2 import global_env as ed
ed.Nspin = 1            # set a global variable
mylocalvar = ed.Nspin   # assign to a local variable
print(ed.Nspin)         # all functions can have global variables as arguments
np.arange(ed.Nspin)
\end{lstlisting}


\paragraph{{\bf Solver functions}}
This group includes a number of functions enabling initialization,
execution and finalization  functionalities for the diagonalization
solver.
\begin{itemize}
  \item {\tt init\_solver} and {\tt set\_Hloc}. The first 
    initializes the \NAME environment for the quantum impurity problem
    solution, sets the effective bath either reading it from a file or
    initializing it from flat band model. Once this function is
    called, it is not possible to allocate a second instance of the solver.
    {\tt set\_Hloc} sets the
    non-interacting part of the impurity Hamiltonian $\h^0_{\a\b\s\s'}$. 
    Either function take different argument combinations there
    including support for inequivalent impurities.

  \item {\tt solve} This function solves the quantum impurity problem,
    calculates the observables and any dynamical correlation
    function. All results remain stored in the memory and get accessed
    through input/output functions.

  \item {\tt finalize\_solver} This function cleans up the \NAME
    environment, free the memory deallocating all relevant arrays or
    data structure. A call to this functions enables a new
    initialization of the solver, i.e. a new call to {\tt
      init\_solver}.  
  \end{itemize}


\paragraph{{\bf Bath functions}}
This set covers the implementation of utility functions handling the
effective bath on the user side as well as interfaces to specific
\NAME procedures, either setting bath properties or applying
conventional symmetry transformation. Here we discuss 
a pair of crucial functions in this group.
\begin{itemize}
\item {\tt bath\_inspect}This function translates between the
  user-accessible continuous bath array and the bath components
  (energy level, hybridization and so on). It functions in both ways,
  given the array returns the components and vice-versa. It
  autonomously determines the type of bath and ED mode.

\item {\tt chi2\_fitgf}
  This function fits the Weiss field or Hybridization function (delta)
  with a discrete set of level. The fit parameters are the bath
  parameters contained in the user-accessible array. Depending on the
  type of system we are considering (normal, superconductive,
  non-SU(2)) a different set of inputs has to be passed. The specifics
  of the numerical fitting routines are controlled in the input file.
  \end{itemize}

Additionally, the group includes the function {\tt
  get\_bath\_dimension}, returning the correct
dimension for the user bath array to be allocated and {\tt
  set\_H{replica/general}} which set the matrix basis
$\vec{\Gamma}$ and init the bath variational parameters
$\vec{\lambda}$ for {\tt bath\_type=replica,general}. 




  
\paragraph{{\bf Input/Output functions}}
This group includes functions which return to the userspace
observables or dynamical correlation functions evaluated in \NAME and
conserved in the corresponding memory instance. Each function
provides a general interface which encompass all dimension of the
input array there including inequivalent impurities support.
For instance, the function {\tt get\_sigma} returns the self-energy
function array (evaluated on-the-fly) for a specified supported shape,
normal or anomlous type and on a specific axis or frequency domain. 
    

\paragraph{{\bf Auxiliary functions}}
This group include some auxiliary functions, either interfacing \NAME
procedures or defined locally in Python to provide specific new
functionalities. Among the latter we include {\tt get\_ed\_mode} which
return the value of the variable {\tt ed\_mode=normal,superc,nosu2}
and {\tt get\_bath\_type} which similarly returns the value of {\tt bath\_type}.



% ##################################################################
% ##################################################################






\subsection{TRIQS interface}\label{sSecInteropTRIQS}
A thin compatibility layer between \NAME and the Toolbox for Research on 
Interacting Quantum Systems (TRIQS)\cite{Parcollet2015CPC} called edipack2triqs 
is available as a stand-alone project. It is a pure Python package that is 
built upon \NAME's Python API  (Sec.~\ref{sSecInteropEDIpy}) and provides a 
limited object-oriented interface to the most important features of \NAME. 
edipack2triqs strives to offer seamless interoperability with other 
tools based on TRIQS by adopting the data storage formats, conventions and 
usage patterns common to other TRIQS-based impurity solvers, such as 
TRIQS/CTHYB\cite{Seth2016CPC}.

\subsubsection{Installation}\label{sSecInteropTRIQSInstallation}
The package depends on \NAME (which ultimately depends on SciFortran), EDIpy2
and TRIQS version 3.1 or newer. Assuming the three prerequisites are correctly 
installed in the OS, the current development version of edipack2triqs can be 
installed with {\tt pip} from its 
\href{https://github.com/krivenko/edipack2triqs}{GitHub repository} as follows:

\begin{lstlisting}[style=mybash]
git clone https://github.com/krivenko/edipack2triqs
cd edipack2triqs
pip install .
\end{lstlisting}

\paragraph{Anaconda}
Another option for installing the package is by using the Anaconda package 
manager on Unix/Linux systems.
The following commands will create a new {\tt conda} environment named 
`edipack' and install the most recently released version of edipack2triqs along 
with its dependencies (\NAME, EDIpy2 and the TRIQS libraries).

\begin{lstlisting}[style=mybash]
conda create -n edipack
conda activate edipack
conda install -c conda-forge -c edipack edipack2triqs
\end{lstlisting}

\subsection{W2Dynamics interface}\label{sSecInteropW2DYN}
\NAME is supported as alternative impurity solver by the w2dynamics DMFT package\cite{Wallerberger2019CPC}. The only prerequisite to use this option is the presence of a functioning EDIpy2 installation, which w2dynamics will attempt to import at runtime only if the user sets the appropriate configuration parameter.

In order to use the \NAME impurity solver for a calculation instead of the built-in implementation of the CT-HYB algorithm, the user needs to set the {\tt solver} parameter in section {\tt General} to {\tt   EDIPACK}. Configuration specific to the exact diagonalization solver can be performed through the parameters in section {\tt EDIPACK} of a w2dynamics parameter file. For most of the \NAME input variables, it provides a parameter of the same name (in all uppercase letters) that allows the corresponding variable to be set insofar as this is supported by the interface and not an option available through generic w2dynamics parameters. This thus includes some parameters that the user will ordinarily want to change from their defaults in a typical calculation such as the number of bath sites {\tt NBATH} and other parameters such as options for the bath fitting and diagonalization algorithms, but also specifically excludes other typically set input variables such as {\tt NORB}, {\tt ULOC}, {\tt BETA}, and {\tt   NLOOP}. All of the these variables correspond to or follow from configuration parameters that a user also needs to set for a CT-HYB calculation, and in order to present a consistent and rather ``solver-agnostic'' user interface, no redundant parameters are added to the {\tt EDIPACK} section and the usual parameters such as {\tt   beta} in section {\tt General} must be used instead. Note however in particular that if the \NAME solver is used, {\tt beta} is by default only used as cut-off and does not imply a finite temperature calculation unless the user explicitly sets the parameter {\tt   ED\_FINITE\_TEMP} in section {\tt EDIPACK} to {\tt True}.

Solver specificities are abstracted away to the greatest reasonable extent by having the input, output, and DMFT loop handled by w2dynamics in mostly the same way as it would be for the CT-HYB solver. This e.g. means that results such as the Green's functions are stored into the w2dynamics HDF5 output file in the typical format, and that w2dynamics uses only its own code for e.g. calculations with multiple inequivalent impurities without relying on any related implementation provided by \NAME{}. As a consequence of this, some functionality that would require specific support from w2dynamics that is not available as of the time of publication can not be used through the interface, e.g. calculations with superconductivity or with phonons.



\subsection{EDIjl, the Julia API}\label{sSecInteropEDIjl}

The c-bindings approach is extremely handy, in that is opens the way for interoperability 
with a large number of languages and frameworks. As an example, an experimental Julia API 
is provided in the EDIpack github repository. Rather than a fully functioning Julia package, 
this is at present a proof of concept, capable of replicating the results of Fortran, C++ and
python implementations for the Bethe lattice example driver.
Its structure and operation mimicks that of the EDIpy2 layer, with minimal language-specific differences.

The \NAME{} Julia api consists of a module called {\tt EDIjl2}, which provides access to the global variables and functions contained in {\tt  libedipack2\_cbinding.so/.dylib}. 

The library is searched upon loading the module, with the following order of priority:

\begin{itemize}
\item {\tt EDIPACK\_PATH}: if this environment variable is set, {\tt EDIjl2} will look there for the library first
\item {\tt LD\_LIBRARY\_PATH}: for Linux systems
\item {\tt DYLD\_LIBRARY\_PATH}: for Mac systems
\end{itemize}

\subsubsection{Structure}

In partial analogy to the Python API, the global variables, but not the functions, are contained in a  {\tt struct} called {\tt global\_env}.

Similarly to the C++ case, global variables and functions are loaded as raw pointers. As a consequence, it is important that the dimensions of the array-like variables (such as {\tt ULOC}) and, in general, the amount of memory occupied by each variable are correcty accounted for. This is achieved within the Julia module by appropriately casting the variables to compatible types, such as {\tt  Cint, Cbool, Cdouble}.
Functions are called from the dynamic library, making use of the {\tt  ccall} procedure. As previously stated, as a consequence of the C linking conventions multiple alternative version of the interfaced Fortran procedures are present, to account for the different input variable combinations; the EDIjl2 wrapper functions take care of selecting the appropriate Fortran procedure depending on the set of input parameters provided by the user.

\subsubsection{Installation and usage}

At present, the EDIpack Julia interface is not offered as a package. The git repository has to be cloned via

\begin{lstlisting}[style=mybash]
git clone https://github.com/EDIpack/EDIjl2.0.git
\end{lstlisting}

and the location of the source files needs to be included in the user program via

\begin{lstlisting}[style=mybash]
push!(LOAD_PATH, joinpath(@__DIR__, "PATH/TO/REPO/src"))
\end{lstlisting}

The EDIjl2 module can then be loaded via

\begin{lstlisting}[style=mybash]
using EDIjl2
\end{lstlisting}

The correct way to access global variables and functions is as in the following example:

\begin{lstlisting}[style=mybash]
EDIjl2.read_input("inputED.conf")
ed = EDIjl2.global_env
println("Nspin = ", ed.Nspin)
ed.Nspin = 2
\end{lstlisting}

The names and inputs of the Julia-wrapped functions are entirely analogous to those of the Python API.

Particular care has to be taken with respect to parallelism: Julia offers an in-house platform for parallel computing with memory sharing through multi-threading. At present, there is no integration between this architecture and the MPI-based parallelism of \NAME{}, and their concurrent use in a single program is entirely untested and not encouraged. If the \NAME{} library is compiled with enabled parallelism, MPI support will need to be enabled in the user-created Julia program, by making use of modules such as {\tt  MPI.jl}. The {\tt MPI\_COMM\_WORLD} communicator will need to be correctly initialized by the user as well, and the program will need to be run with {\tt  mpiexec/mpirun}.

We provide an example script for the simple case of the Bethe lattice in the normal phase in the {\tt  examples} folder of the EDIjl2.0 repository. This script is intended to be run serially. Documentation of the API and further examples are being developed.
\end{document}