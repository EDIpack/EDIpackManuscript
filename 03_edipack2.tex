\documentclass[edipack_sp.tex]{subfiles}
\usepackage{multirow}
\begin{document}

\section{Implementation}\label{SecEDIpack}
In this section we introduce the generic quantum impurity system and
present a detailed overview of the \NAME library implementation. 













\subsection{The quantum impurity problem}\label{sSecQIM}
We consider a general quantum impurity problem described by the Hamiltonian:
$$
\hat{H} = \hat{H}_\mathrm{imp} + \hat{H}_\mathrm{bath} + \hat{H}_\mathrm{hyb} + \hat{H}_\mathrm{ph} + \hat{H}_\mathrm{e-ph}
$$
which describes a multi-orbital quantum impurity
coupled to an electronic bath and local phonons (e.g., Holstein
modes). For now, we assume no specific symmetries.

\subsubsection{Impurity Hamiltonian}
The impurity Hamiltonian is split into a quadratic and an 
interacting part:
\begin{equation}\label{Himp}
  \hat{H}_\mathrm{imp}  = \hat{H}^0_\mathrm{imp} + \hat{H}^\mathrm{int}_\mathrm{imp}
\end{equation}
where
\begin{equation}\label{H0imp}
  \hat{H}^0_\mathrm{imp}  =
  \sum_{\a\b\sigma\sigma'}h^{0}_{\a\b\sigma\sigma'}d^{+}_{\a\sigma}d_{\b\sigma'}
\end{equation}
represents the quadratic part, with $d_{\a\sigma}$ ($d^+_{\a\sigma}$) are the annihilation (creation)
operators for impurity electrons in 
orbital $\alpha=1,\dots,N_\a$, with $N_\a$ the number of orbitals,
and spin $\sigma=\up,\dw$.  The occupation number operator is defined
as  $n_{\alpha\sigma}=d^{+}_{\alpha\sigma}d_{\alpha\sigma}$.
The internal structure of the non-interacting part is captured by the 
matrix $h^{0}_{\a\b\sigma\sigma'}$, which can include 
orbital-dependent on-site energies or amplitudes, spin-orbit coupling or other single-particle terms.


The interaction part of the impurity Hamiltonian, 
 $\hat{H}^{\mathrm{int}}$ can in principle contain any 
set of two-body operators: 
$$
\hat{H}^\mathrm{int}_\mathrm{imp} =  \sum_{ijkl} U_{ijkl}c^{\dagger}_{i}c^{\dagger}_{j}c_{l}c_{k}. 
$$
However, we typically 
adopt a generic formulation of the local multi-orbital Hubbard-Kanamori interaction~\cite{Georges2013ACMP}:
\begin{equation}\label{Hint}
  \begin{split}
    \hat{H}^\mathrm{int}_\mathrm{imp} &=U\sum_{\a}n_{\a\uparrow}n_{\a\downarrow}+U'\sum_{\a\neq \b}n_{\a\uparrow}n_{\b\downarrow}+(U'-J)\sum_{\a<\b,\sigma}n_{\a\sigma}n_{\b\sigma}\\
    &{\phantom =}- J_X\sum_{\a\neq
      \b}d^{+}_{\a\uparrow}d_{\a\downarrow}d^{+}_{\b\downarrow}d_{\b\uparrow}+J_P\sum_{\a
      \neq
      \b}d^{+}_{\a\uparrow}d^{+}_{\a\downarrow}d_{\b\downarrow}d_{\b\uparrow}\\
\end{split}
\end{equation}
The first three terms represent the density-density part of the
interaction, where $U$ is the local intra-orbital Coulomb repulsion,
$U'$ the inter-orbital one and $J$ the Hund's coupling~\cite{Georges2013ACMP}.  
The final two terms are, respectively, the spin-exchange ($J_X$) and
the pair-hopping ($J_P$).
In the three-orbital case $N_\a=3$ a fully symmetric $SU(3)_\mathrm{orbital}\otimes SU(2)_\mathrm{spin}\otimes
U(1)_\mathrm{charge}$ form of the interaction is obtained by setting $U'=U-2J$ and
$J_X=J_P=J$~\cite{Georges2013ACMP}. Different choices, preserving part
of the combined symmetry group, can be made for other number of orbitals~\cite{Georges2013ACMP}.

\subsubsection{Bath and Hybrization}
The coupling between the impurity and the bath is described by
\begin{equation}\label{Hbath}
  \begin{split}
    \hat{H}_\mathrm{bath} &=
    \sum_p\sum_{\a\b\sigma\sigma'}h^p_{\a\b\sigma\sigma'}a^{+}_{p\a\sigma}a_{p\b\sigma'}\\
    %
    \hat{H}_\mathrm{hyb} &= \sum_p\sum_{\a\b\sigma\sigma'}V^p_{\a\b\sigma\sigma'}d^{+}_{\a\sigma}a_{p\b\sigma'}+H.c. \\
\end{split}
\end{equation}
where $p=1,\dots,N_\mathrm{bath}$ indexes the
bath elements. The operators $a_{p\alpha\sigma}$
($a^+_{p\alpha\sigma}$) correspond to the destruction (creation) of
bath electrons with index $p$, orbital $\alpha$ and spin $\sigma$.
Any bath element can be composed of several electronic levels
according the chosen bath topology. The  properties of each bath level are described by the
matrix $h^p_{\a\b\sigma\sigma'}$ and couples to the impurity through an amplitude
$V^p_{\a\b\s\sigma'}$.   


\subsubsection{Electron-Phonon coupling}
Finally, the electron-phonon part of the quantum impurity problems is
described by the Hamiltonian terms: 
\begin{equation}\label{Hph}
  \begin{split}
    \hat{H}_\mathrm{ph}&=\sum_q \omega_{0q} b_q^+b_q + \sum_q \sqrt{2}A_{q}(b^\dagger_q + b_q)  \\
    % 
    \hat{H}_\mathrm{e-ph} &= \sum_q\sum_{\a\b\sigma} g_{\a\b} d^+_{\a\sigma}d_{\b\sigma}(b_q+b_q^+)
\end{split}
\end{equation}
where $q=1,\dots,N_q$ indexes the number of local phonons, and $b_q$
($b_q^+$) are the destruction (creation) operators for a phonon with
frequency $\omega_{0q}$.
The matrix  $g_{\a\b}$ describe the electron-phonon coupling. 
Although feasible, dealing with more than one phonon mode becomes
quickly computationally very demanding, thus in the rest of the this
work we shall consider $N_q=1$.
The phonon's frequency is passed to the \NAME program via the variable { \tt W0\_PH } to be read from the input file. The displacement field acting on the phonon is passed through the variable {\tt A\_PH} from the input file. The electron-phonon coupling matrix $g_{\alpha \beta}$ instead can be passed in two different ways. If the matrix is diagonal ($g_{\alpha \beta} = g_\alpha \delta_{\alpha \beta}$), from the input file one can simply write in order the values $g_\alpha$ in the variable {\tt G\_PH }. For any general shape one can pass to the input file a {\tt GPHfile } variable containing the name of the file storing the $g_{\alpha \beta}$ array in Fortran style.
If {\tt GPHfile=NONE} the matrix $g_{\alpha \beta}$ is read from the variable {\tt G\_PH}, else it is read from the {\tt GPHfile}.

\subsubsection{System setup}
We consider a quantum impurity system composed by a single multi-orbital impurity, a bath discretized into a number $N_\mathrm{bath}$ of {\it elements} possibly endowed with an internal structure, and a number of available phonons. 
The total size of the system is determined by three contributions: i) the number of impurity orbitals $N_\a$, ii) the total count of electronic bath levels $N_\mathrm{b}$, and iii) by the number of phonons $N_\mathrm{ph}$. 
The latter is fixed to set a cut-off to the unbounded dimensions of the local phonons Hilbert space.
The number of bath degrees of freedom $N_\mathrm{b}$ is a
function of the bath topology and of $N_\mathrm{bath}$, which is determined internally by \NAME.
In the simplest case, each bath
element corresponds to an independent electronic level coupled to the
impurity, thus $N_\mathrm{b}\equiv N_\mathrm{bath}$.
The number of electronic levels in the quantum impurity systems is indicated with $N_\mathrm{s}$.


The setup of the quantum impurity problem is implemented in {\tt
  ED\_SETUP} through the input variables {\tt Nspin}$=N_\sigma$,
{\tt Norb}$=N_\a$ and {\tt Nbath}$=N_\mathrm{bath}$ globally defined {\tt
  ED\_INPUT\_VARS}. The {\tt Ns}$=N_\mathrm{s}$ variable, evaluated in
{\tt ed\_setup\_dimensions}, corresponds to the total number of
electronic levels. 
The local non-interacting Hamiltonian
$h^0_{\a\b\s\s'}$ is specified using the function {\tt ed\_set\_hloc} in {\tt ED\_AUX\_FUNX}.
The setup of the bath matrices $h^p_{\a\b\s\s'}$
requires a more involved procedure which will be illustrated in
\secu{sSecBath}. 



% \paragraph{{\bf Remark}} As extensively discussed in
% \onlinecite{Amaricci2022}, the inclusion of local phonons with
% truncated dimensions ultimately amounts to a sequential application of
% the procedures defined for the electronic part, i.e. one per phonon
% mode. This includes a linear scaling of the dimensions with $N_\mathrm{ph}$
% and of course largely limit the available degrees of freedom to
% describe electronic states. In the rest of the paper we focus
% specifically on the electronic part of the quantum impurity problem,
% referring to the phonons in specific sections when their presence
% introduces non-trivial modifications.  


















\subsection{The Fock basis states}\label{sSecBasis}
The Fock space of the quantum impurity problem is defined as
$\FF=\FF_\mathrm{e}\otimes \FF_\mathrm{ph}$, where: $$
\FF_\mathrm{e}=\bigoplus_{n=0}^{N_\mathrm{s}}
S_-\HH_\mathrm{e}^{\otimes n}
$$ 
is the electronic Fock space built 
from the local electronic Hilbert space $\HH_\mathrm{e}$, and 
$$
\FF_\mathrm{ph}=\bigoplus_{n=0}^{N_q}S_+\HH_\mathrm{ph}^{\otimes n}
$$
is the
phonon Fock space, with local phonon Hilbert space
$\HH_\mathrm{ph}=\{\ket{0},\ket{1},\dots,\ket{N_\mathrm{ph}}\}$. 
Here ($S_-$) $S_+$ is the (anti-)symmetrization operator.  
%
The total dimension of the Fock space is
$$
D=4^{N_\mathrm{s}}\cdot (N_\mathrm{ph}+1)=D_\mathrm{e}\cdot
D_\mathrm{ph},
$$ 
highlighting the exponential
growth with the number of electronic levels. 

The quantum states in the space $\FF$ are naturally represented in
the occupation number formalism of second quantization,
i.e.~the Fock basis.
For a system of $N_\mathrm{s}$ electrons, each Fock state
is given as $\ket{p}\ket{\vec{n}}$, with
\begin{equation} \label{eq:FockState_|nupndw>}
    \ket{\vec{n}}=\ket{n_{1\up},\dots,n_{N_\mathrm{s}\up},n_{1\dw},\dots,n_{N_\mathrm{s}\dw}},
\end{equation}
where $p=1,\dots,N_\mathrm{ph}$ is the number of local phonons and
$n_{a\sigma}=0,1$ indicates the absence or 
presence of an electron with spin $\sigma$ at level $a$.

The electronic part of the Fock state $\ket{\vec{n}}$ is represented
as a binary string of length $2N_\mathrm{s}$. Thus, any such state can be encoded
in a computer using a sequence of $2N_\mathrm{s}$ bits, or equivalently, as an integer $I=0,\dots 2^{2N_\mathrm{s}}-1$ such that $\ket{\vec{n}}=\ket{I}$.  

Destruction and creation operators, $c_{a\sigma}$ and $c^+_{a\sigma}$ 
respectively, act on the Fock space as:
\begin{align*}
  c_{a\sigma}\ket{\vec{n}} &=
    \begin{cases}
      (-1)^{\#_{a\sigma}}\ket{\dots,n_{a\sigma}\!-\!1,\dots}
      &\text{if $n_{a\sigma}\!=\! 1$}\\
      0 &\text{otherwise}
    \end{cases};\\
    c^{+}_{a\sigma}\ket{\vec{n}} &=
     \begin{cases}
      (-1)^{\#_{a\sigma}}\ket{\dots,n_{a\sigma}\!+\!1,\dots}
      & \text{if $n_{a\sigma}\!=\! 0$}\\
      0 & \text{otherwise}
    \end{cases}    
\end{align*}
where $\#_{a\sigma}=\sum_{b\sigma'<a\sigma} n_{b\sigma'}$ accounts for the fermionic sign imposed by the Pauli principle.


The implementation of Fock states and operators can be found in 
{\tt ED\_AUX\_FUNX}. In particular, in this module we define the bitwise action 
of fermionic creation and annihilation operators as functions 
{\tt CDG} and {\tt C}, used throughout the code. Additionally, 
we provide the function {\tt bdecomp} for reconstructing the Fock 
state bit sequence from the integer representation.


\begin{lstlisting}[style=fstyle,numbers=none]
  subroutine C(pos,in,out,fsgn) !$c_\mathrm{pos}|\mathrm{in}\rangle=|\mathrm{out}\rangle$
    integer,intent(in)    :: pos  !Position to be set to 1
    integer,intent(in)    :: in   !Input index
    integer,intent(inout) :: out  !Output index
    real(8),intent(inout) :: fsgn !Fermionic sign   
    integer               :: l
    if(.not.btest(in,pos-1))stop "C error: C_i|...0_i...>"
    fsgn=1d0
    do l=1,pos-1
       if(btest(in,l-1))fsgn=-fsgn
    enddo
    out = ibclr(in,pos-1)
  end subroutine C
\end{lstlisting}


\begin{lstlisting}[style=fstyle,numbers=none]
  subroutine CDG(pos,in,out,fsgn) !$c^\dagger_\mathrm{pos}|\mathrm{in}\rangle=|\mathrm{out}\rangle$
    integer,intent(in)    :: pos  !Position to be set to 1
    integer,intent(in)    :: in   !Input index
    integer,intent(inout) :: out  !Output index
    real(8),intent(inout) :: fsgn !Fermionic sign   
    integer               :: l
    if(btest(in,pos-1))stop "C^+ error: C^+_i|...1_i...>"
    fsgn=1d0
    do l=1,pos-1
       if(btest(in,l-1))fsgn=-fsgn
    enddo
    out = ibset(in,pos-1)
  end subroutine CDG
\end{lstlisting}


\begin{lstlisting}[style=fstyle,numbers=none]
 !Binary decomposition of the ${\color{comment-color} i\in\NNN}$ with Ntot-bits
 function Bdecomp(i,Ntot) result(ivec)
    integer :: Ntot,ivec(Ntot),l,i
    logical :: busy
    do l=0,Ntot-1
       busy=btest(i,l)
       ivec(l+1)=0
       if(busy)ivec(l+1)=1
    enddo
  end function Bdecomp
\end{lstlisting}














\subsection{Conserved quantum numbers}\label{sSecQNs}
To mitigate the exponential scaling of the Fock space dimension, it 
is essential to exploit suitable symmetries. Specifically, if the 
Hamiltonian $H$ commutes with a set of operators ${\cal \vec{Q}}=[{\cal Q}_1,{\cal Q}_2,\dots,{\cal Q}_M]$ such that 
$[H, {\cal Q}_i] = 0$, the Fock space can be decomposed into smaller, 
disjoint symmetry sectors labeled by quantum numbers $\vec{Q}$.

In the context of quantum impurity problems, two commonly used 
symmetries are: i) conservation of the total charge $N$ and ii) 
conservation of the total magnetization $S_z$. Although the total 
spin operator $S^2$ may also be conserved, its implementation is 
computationally challenging and typically provides only marginal 
gains, making it less practical in many cases.

In \NAME, three different symmetry configurations are available, 
controlled by the input variable {\tt ed\_mode} = {\bf normal}, 
{\bf superc}, or {\bf nonsu2}:

\begin{itemize}
\item{} The {\bf normal} case conserves both the total occupation $N$
and the total magnetization $S_z$, or equivalently, the total number
of electrons with spin up $N_\up$ and down $N_\dw$.
Optionally, the symmetry
can be extended to act indipendently to each orbital and spin
component, i.e.~$\vec{N_\s}=[N^1_\s,\dots,N^{N_\a}_\s]$. This
specific case is discussed extensively
Ref.~\cite{Amaricci2022} so we will not be further cover it here recalling that any consideration concerning the {\tt normal} case extends directly to this case as well.

%

\item{} The {\bf superc} case maintains only the $S_z$ conservation,
allowing the total charge to not be conserved. This setting captures
systems with $s$-wave superconductivity, including 
intra- and inter-orbital pairing.

\item{} The {\bf nonsu2} case conserves the total
charge $N$ while allowing spin symmetry group to be not conserved.
This scenario catpures effects such as local spin-orbit coupling
$\vec{L}\cdot\vec{S}$~\cite{something}, in-plane spin ordering~\cite{BellomiaKMH} or
in-plane spin-triplet exciton condensation~\cite{Amaricci2023_excitons,Blason}.  
\end{itemize}

From a computational perspective, constructing a symmetry
sector amounts to defining a injective map
$\MM:\SS_{\vec{Q}}\rightarrow \FF$ which relates the states $\ket{i}$
within a given symmetry sector $\SS_{\vec{Q}}$ to the states $\ket{I}$ in the
full Fock space.
This map is typically implemented as a rank-1
integer array whose size corresponds to the dimension of the sector $D_{\SS_\vec{Q}}$$. 


The {\bf normal} case deserves a special note. Since $N_\up$ and
$N_\dw$ are conserved independently, the local Hilbert
space and the electronic Fock space can be factorized as
$\HH_e=\HH_{e\up}\otimes\HH_{e\dw}$ and $\FF_\mathrm{e} = \FF_{e\up}\otimes \FF_{e\dw}$, respectively.  
Consequently, each Fock state can be written as a product
$\ket{\vec{n}_\up} \ket{\vec{n}_\dw}$. This factorization splits the
symmetry sector as $\SS_{\vec{Q}} = \SS_{N_\up}\otimes\SS_{N_\dw}$,
and finally the sector map can be expressed as the product $\MM = \MM_\up
\otimes \MM_\dw$.
%
Each state $\ket{i}=\ket{i_\up} \ket{i_\dw}$ in this factorized basis
is labeled by two integers $[i_\up,i_\dw]$, with 
$i_\sigma=1,\dots,D_{\SS_\sigma}$ such that $i=i_\up + i_\dw
D_{\SS_\dw}$.
The maps $\MM_\sigma$ then connect these basis states to Fock states
$\ket{I}=\ket{I_\up}\ket{I_\dw}$, labeled by two integers
$[I_\up,I_\dw]$ as $I=I_\up +   I_\dw 2^{N_\mathrm{s}}$.
For a more
detailed discussion on the structure of the Fock basis in this case, see Ref.~\cite{Amaricci2022}. 

The presence of a symmetry reduces the Hamiltonian matrix to
a block diagonal form, where each block, labeled by $\vec{Q}$, has dimension
$D_{\SS_\vec{Q}}$. The sector Hamiltonian matrix $H_\SS$ is represented in the
basis $\ket{i}\in\SS_{\vec{Q}}$ as a sparse matrix.
In the {\bf normal} case this block structure is particularly
symmetric due to the factorized nature of the sectors as discussed
above, see also Ref.~\cite{Amaricci2022}.
The analysis of the spectrum is then reduced to inspecting the
Hamiltonian within each symmetry sector, or to a subset thereof if a
additional constraints are present.
A summary of the sector properties is provided in
Table~(\ref{TabSector}). 
\begin{table}%[ht]
  \label{TabSector}
\begin{center}
\begin{tabularx}{\linewidth}{ |X|X|X| } 
 \hline
  {\tt ed\_mode} & {\it Quantum Numbers} & {\it Sector Dimension} \\
  \hline
  {\bf normal} & $[N,S_z]\equiv[N_\up,N_\dw]$ &
                                                $\binom{N_\mathrm{s}}{N_\up}\binom{N_\mathrm{s}}{N_\dw}$
  \\
  \hline
  {\bf superc} & $S_z\equiv N_\up-N_\dw$ &  $\sum_m 2^{N_\mathrm{s}-S_z-2m}\binom{N_\mathrm{s}}{N_\mathrm{s}-S_z-2m}\binom{S_z+2m}{m}$
  \\
  \hline
  {\bf nonsu2} & $N \equiv N_\up+N_\dw$ & $\binom{2N_\mathrm{s}}{N}$ \\ 
 \hline
\end{tabularx}
\end{center}
\caption{
  {\bf Quantum Numbers Table}.
A table summarizing the possible values of the input variable {\tt
  ed\_mode} selecting the symmetries of the problem. To each value
(first column) correspond different quantum numbers (second column).
The third column report the dimension of the symmetry sector for a
given realization of the quantum numbers.}
\end{table}

% Although the sectors have dimensions much smaller than the full Fock
% space, for large systems storing the Hamiltonian matrix in the memory
% can still be highly inefficient. In such cases, any Krylov  subspace  
% method~\cite{Lanczos1950JRNBSB,Lin1993CIP,Lehoucq1998,Maschhoff1996}
% can be implemented using a storage-free algorithm, performing the
% necessary linear operations on-the-fly.
% This solution has generally a negative impact on the execution
% time, however this can be well compensated by scaling in a distributed 
% parallel framework.

In \NAME the implementation of symmetry sectors is managed through the
{\tt sector} object, which is defined in {\tt
  ED\_VARS\_GLOBAL}. This object contains all the relevant
information for defining the symmetry, including the sector
dimensions, quantum numbers and the map $\MM$. The constructor
(destructor) for this object is defined in the {\tt
  ED\_SECTORS} module via the function {\tt build\_sector} ({\tt
  delete\_sector}).
These functions use different algorithms depending on the nature 
of the quantum numbers $\vec{Q}$, i.e. the value of {\tt ed\_mode}. The following  code snippet summarize the various available implementations:
    
\setbox0=\hbox{%
  \begin{minipage}{0.27\linewidth}
\begin{lstlisting}[style=fstyle,frame=none,numbers=none,basicstyle={\scriptsize\ttfamily}]
i=0
do Iup=0,2**Nbit-1     
  nup_ = popcnt(Iup) 
  if(nup_ /= Nups(1))cycle
  i = i+1
  H(iud)%map(i) = lup
enddo
i=0
do Idw=0,2**Nbit-1
  ndw_= popcnt(Idw)
  if(ndw_ /= Ndws(1))cycle
  i = i+1
  H(iud+Ns)%map(i) = Idw
enddo
\end{lstlisting}
\end{minipage}
}
\savestack{\listingA}{\box0}

\setbox0=\hbox{%
  \begin{minipage}{0.27\linewidth}
\begin{lstlisting}[style=fstyle,frame=none,numbers=none,basicstyle={\scriptsize\ttfamily}]
i=0
do Idw=0,2**Ns-1
  ndw_= popcnt(idw)
  do Iup=0,2**Ns-1
    nup_ = popcnt(iup)
    sz_  = nup_ - ndw_
    if(sz_ /= self%Sz)cycle
    i=i+1
    self%H(1)%map(i) = &
        Iup+Idw*2**N
  enddo
enddo
\end{lstlisting}
\end{minipage}
}
\savestack{\listingB}{\box0}

\setbox0=\hbox{%
  \begin{minipage}{0.3\linewidth}
\begin{lstlisting}[style=fstyle,frame=none,numbers=none,basicstyle={\scriptsize\ttfamily}]
i=0
do Idw=0,2**Ns-1
  ndw_= popcnt(Idw)
  do Iup=0,2**Ns-1
    nup_ = popcnt(Iup)
    nt_  = nup_ + ndw_
    if(nt_/=self%Ntot)cycle
    i=i+1
    self%H(1)%map(i) = &
        Iup+Idw*2**Ns
  enddo
enddo
\end{lstlisting}
\end{minipage}
}
\savestack{\listingC}{\box0}

\begin{tabular}{c|c|c}\label{list1}
    {\bf normal} & {\bf superc} & {\bf nonsu2}\\
    \hline
\stackinset{l}{}{t}{}{}{\listingA} &
\stackinset{l}{}{t}{}{}{\listingB} &
\stackinset{l}{}{t}{}{}{\listingC} \\
\end{tabular}
\vspace{2mm}

In addition to the basic construction and destruction routines, the
{\tt ED\_SECTORS} module also includes functions to
retrieve sector indices and quantum number
information. Furthermore, it provides a set of
essential functions for applying creation ({\tt apply\_op\_CDG}), destruction ({\tt apply\_op\_C}) or arbitrary linear combinations
({\tt apply\_Cops}) of these to a given Fock state $\ket{v}\in\SS$, i.e.:
$$
\OO\ket{v} = \sum_i a_i C_{\a_i,\s_i}+ b_i C^{\dagger}_{\b_i,\r_i}\ket{v}
$$ 
with $a_i, b_i \in\CCC$, $\a_i,\b_i=1,\dots,N_\a$ and $\s_i,\r_i=\up,\dw$. These functions are widely used throughout the code. 





















\subsection{Interaction setup}\label{sSecIntSetup}
The \NAME code offers two distinct methods to setup the interaction terms $\hat{H}^\mathrm{int}$ in \equ{Himp}, which are controlled by the input variables {\tt
  ED\_USE\_KANAMORI} and {\tt ED\_READ\_UMATRIX}. 
  
The generalized Hubbard-Kanamori interaction, as defined in \equ{Hint}, is natively
supported and controlled by the input parameters {\tt ULOC}$=U$, {\tt
  UST}$=U'$, {\tt JH}$=J$, {\tt JX}$=J_{x}$ and {\tt JP}$=J_{p}$.
These quantities can be specified either in the input file or directly
via the the command line, provided the logical input parameter {\tt ED\_USE\_KANAMORI=T} and setting {\tt ED\_READ\_UMATRIX=F}. In this mode, the maximum number of impurity orbitals {\tt NORB}$=N_\a$ is limited to $5$.


Alternatively, setting {\tt ED\_READ\_UMATRIX=T} and {\tt ED\_USE\_KANAMORI=F}, a list of two-body operators can be supplied by the user in a properly
formatted text file, whose name is specified by the input variable {\tt UMATRIX\_FILE}. The implementation of the list of interaction terms is contained in
the module {\tt ED\_PARSE\_UMATRIX}.  
The file must have the suffix {\tt <UMATRIX\_FILE>.re\-star\-t} and should be formatted
as follows: 
\begin{lstlisting}[style=mybash,numbers=none]
NORB BANDS
i1 j1 k1 l1 U_i1j1k1l1
i2 j2 k2 l2 U_i2j2k2l2
...
\end{lstlisting}
where {\tt NORB} is the numer of orbitals $N_\a$ and each line
defines a single two-body term of the form 
$U_{ijkl}c^{\dagger}_{i}c^{\dagger}_{j}c_{l}c_{k}$. Note that the
coefficient indices are swapped compared to the standard two-body
operator formulation \cite{??}.  
Empty lines and lines starting with {\tt \#, \%, !} are ignored.

While {\tt ED\_READ\_UMATRIX} and {\tt ED\_USE\_KANAMORI}
are mutually exclusive, we allow to set both to {\tt F}. 
In this case, the user must 
provide the interaction terms to the solver through the function 
{\tt add\_twobody\_operator} in the calling program or script, before  the impurity problem is solved.

For reference and future use, a list of the interaction operators used in each call to the solver are saved in the output file 
{\tt <UMATRIX\_FILE>.used}.

















\subsection{Classes}
The use of objects and classes greatly simplifies the implementation of critical mathematical concepts required for solving quantum 
impurity problems. This section provides an overview of the main 
classes used in \NAME, focusing on their structure and functionality.


\subsubsection{Sparse matrix}\label{CodeSparseMatrix}
Sparse matrix storage is handled through a dedicated class in the 
{\tt SPARSE\_MATRIX} module. This module defines the 
{\tt sparse\_matrix\_csr} object, which stores sparse matrices as 
hash tables. Each key corresponds to a row index, while the associated 
value contains a pair of dynamic arrays: one for the non-zero (NNZ) matrix 
elements and one for their respective column indices.

\begin{lstlisting}[style=fstyle,numbers=none]
! sparse row: contains the NNZ elements on anyrow of the sparse matrix.
type sparse_row_csr
   integer                                   :: size  !size of the row = NNZ
   real(8),dimension(:),allocatable          :: dvals !rank-1 array for double precision
   complex(8),dimension(:),allocatable       :: cvals !rank-1 array for double complex
   integer,dimension(:),allocatable          :: cols  !rank-1 array for column indices
end type sparse_row_csr
! Sparse Matrix: allocatable array of sparse rows
type sparse_matrix_csr
   type(sparse_row_csr),dimension(:),pointer :: row  !array of {\tt sparse\_row\_csr} 
   integer                                   :: Nrow !total number of rows
   integer                                   :: Ncol !total number of columns
   logical                                   :: status=.false. !Allocation status
#ifdef _MPI
   type(sparse_row_csr),dimension(:),pointer :: loc      !array for the diagonal blocks
   integer                                   :: istart=0 !start index MPI range
   integer                                   :: iend=0   !end index MPI range
   integer                                   :: ishift=0 !shift index MPI range
   logical                                   :: mpi=.false.
#endif
end type sparse_matrix_csr
\end{lstlisting}


Each instance of {\tt sparse\_matrix\_csr} can be stored in either 
a serial manner (one copy per process) or distributed across multiple 
processes, with rows dynamically assigned to each process. 
Matrix elements are inserted using the 
{\tt sp\_insert\_element} procedure, which leverages the Fortran 
intrinsic {\tt move\_alloc} for faster execution compared to 
implicit reallocation, i.e.~{\tt vec=[vec,new\_element]}. 

This approach offers several key advantages, including efficient 
memory management for matrices with unknown numbers of non-zero 
elements per row, and $O(1)$ element access time, both of which 
are critical for the efficient implementation of Krylov subspace 
methods.


%GBtodo placeholder: I passed on this already (except I don't like the
%minipage of the listings)

\subsubsection{Sparse map}\label{CodeSparseMap}
As discussed in \secu{sSecRDM}, the construction of a symmetry 
sector often requires associating each sector state $\ket{i}$ with 
disjoint information about the corresponding Fock state $\ket{I}$. 
In this context, the Fock state can be decomposed into bit chunks, 
e.g., $\ket{\vec{n}} = \ket{\vec{i}_\up\,\vec{b}_\up\,
\vec{i}_\dw\,\vec{b}_\dw}$, reflecting a natural grouping into impurity 
and bath components and where we highlight the overall ordering in
spin-up and spin-down parts (see \equ{eq:FockState_|nupndw>}).

The {\tt ED\_SPARSE\_MAP} module provides an efficient hash-table 
implementation, {\tt sparse\_map} which is part part of the {\tt
  sector} object and stores the relation between these bit chunks. 
Specifically, for each impurity configuration 
$\vec{i}_\s$ (key), it maintains a list of compatible bath 
configurations $\vec{b}_\s$ (values) consistent with the conserved 
quantum numbers of the given sector (see \secu{sSecQNs}).
The {\tt sparse\_map} ${\cal P}$ objects are constructed upon call of the {\tt
  build\_sector} ({\tt sector} constructor) using different algorithms 
for each value of {\tt ed\_mode}.


\begin{lstlisting}[style=fstyle,numbers=none]
!sparse row: contains bath states values for each impurity key 
type sparse_row
   integer                               :: size          !current size
   integer                               :: bath_state_min!smallest bath state
   integer                               :: bath_state_max!largest bath state
   integer,dimension(:),allocatable      :: bath_state    !rank-1 bath states
   integer,dimension(:),allocatable      :: sector_indx   !bath state sector indices
end type sparse_row
!Sparse Map: array of sparse rows 
type sparse_map
   type(sparse_row),dimension(:),pointer :: imp_state     !Key: impurity states
   integer                               :: Nimp_state    !Key upper limit 
   logical                               :: status=.false.!allocation status
end type sparse_map
\end{lstlisting}


In the {\bf normal} mode, the sector object contains two separate {\tt
  sparse\_maps} objects ${\cal P}_{\s=\up,\dw}$, reflecting the
factorization of the Fock and sector states into independent spin components: 
$\ket{J}=\ket{J_\up}\otimes\ket{J_\dw} \xleftarrow{\MM}
\ket{j_\up}\otimes\ket{j_\dw}=\ket{j}$.
The sparse maps are built as follows. 
For any spin state of the sector $\ket{J_\s}=\ket{{\vec{I}_{\s}\vec{B}_{\s}}}$,
the \emph{key} is determined by the integer $I_\s$ corresponding to the
impurity bitset $\vec{I}_\s$. The \emph{values} are given by any
integer $B_\s$ corresponding to any bath bitset
$\vec{B_\s}$ associated with $\vec{I}_\s$ by the sector symmetry constraint: $\#\vec{I}_\s + \#\vec{B}_\s = \mathtt{popcnt}(I_\s) + \mathtt{popcnt}(B_\s)= N_\s$.
Thus, any given \emph{key-value} combination 
reconstructs an integer $J_\s$ representing a Fock state in the
given spin sector according to the rule $J_s = I_\s +
2^{N_\mathrm{imp}}B_\s$, where $N_\mathrm{imp}$ is the number of impurity bits. 

In both {\bf superc} and {\bf nonsu2} modes a single sparse map is
used.
Here, each Fock state $\ket{J}$ is associated with four integers $I_\up, B_\up, I_\dw,
B_\dw$ representing the bit decomposition of the state. 
These integers satisfy the relationship
$$
J =I_\up +  B_\up2^{N_\mathrm{imp}} + (I_\dw +  B_\dw2^{N_\mathrm{imp}})2^{N_\mathrm{s}}
$$
where $N_\mathrm{imp}$ is the number of impurity bits and 
$N_\mathrm{s}$ is the total number of spin orbitals.
% To obtain a contiguous memory pattern %%> What? They are pointed lists...
We define the \emph{key} for the sparse
map as $I=I_\up + I_\dw2^{N_\mathrm{imp}}$ and the corresponding
\emph{values} as the integers $B=B_\up + B_\dw2^{N_\mathrm{b}}$.
Note that these relations can be easily inverted to obtain $I_{\sigma=\up,\dw}$ from
$I$ and $B_{\sigma=\up,\dw}$ from $B$ in order to reconstruct the Fock
state $\ket{J}$.
The four integers satisfy the symmetry constraints:   
$\mathtt{popcnt}(I_\up + B_\up2^{N_\mathrm{imp}}) + \mathtt{popcnt}(I_\dw + B_\dw2^{N_\mathrm{imp}}) = N$
for the \textbf{nonsu2} case and
$\mathtt{popcnt}(I_\up + B_\up2^{N_\mathrm{imp}}) - \mathtt{popcnt}(I_\dw + B_\dw2^{N_\mathrm{imp}}) = S_z$
for the \textbf{superc} case.
This structure ensures an efficient and compact representation 
of the many-body Hilbert space, enabling a rapid state lookup 
during the diagonalization process.

An overview of the implementation is reported in the following listing:
\setbox0=\hbox{%
  \begin{minipage}{0.42\linewidth}
\begin{lstlisting}[style=fstyle,frame=none,numbers=none,basicstyle={\scriptsize\ttfamily}]
i=0
do Iup=0,2**Nbit-1     
  nup_ = popcnt(Iup) 
  if(nup_ /= Nups(1))cycle
  i=i+1 
  !...
  iImp  = ibits(iup,0,Norb)
  iBath = ibits(iup,Norb,Norb*Nbath)
  call sp_insert_state(self%H(1)%sp,
                       iImp,&
                       iBath,&
                       i)
enddo
i=0
do Idw=0,2**Nbit-1
  ndw_= popcnt(Idw)
  if(ndw_ /= Ndws(1))cycle
  i=i+1 
  !...
  iIMP  = ibits(idw,0,Norb)
  iBATH = ibits(idw,Norb,Norb*Nbath)
  call sp_insert_state(self%H(2)%sp,&
                       iImp,&
                       iBath,&
                       i) 
enddo
\end{lstlisting}
\end{minipage}
}
\savestack{\listingA}{\box0}

\setbox0=\hbox{%
  \begin{minipage}{0.45\linewidth}
\begin{lstlisting}[style=fstyle,frame=none,numbers=none,basicstyle={\scriptsize\ttfamily}]
i=0
do Idw=0,2**Ns-1
  ndw_= popcnt(idw)
  do Iup=0,2**Ns-1
    nup_ = popcnt(iup)
    select case (ed_mode)
      case('superc') 
        sz_  = nup_ - ndw_
        if(sz_ /= self%Sz)cycle
      case('nonsu2') 
        nt_  = nup_ + ndw_
        if(nt_ /= self%Ntot)cycle 
    end select
    i=i+1 
    !...
    iImpUp = ibits(iup,0,Norb)
    iImpDw = ibits(idw,0,Norb)
    iBathUp= ibits(iup,Norb,Norb*Nbath)
    iBathDw= ibits(idw,Norb,Norb*Nbath)
    iImp   = iImpUp  + iImpDw*(2**Norb)
    iBath  = iBathUp + iBathDw*(2**(Norb*Nbath))
    call sp_insert_state(self%H(1)%sp,&
                         iImp,&
                         iBath,&
                         dim)
  enddo
enddo
\end{lstlisting}
\end{minipage}
}
\savestack{\listingB}{\box0}

\begin{tabular}{c|c}\label{list2}
{\bf normal} & {\bf superc/nonsu2}\\
\hline
  \stackinset{l}{}{t}{}{}{\listingA} & \stackinset{l}{}{t}{}{}{\listingB} 
\end{tabular}
%



  

  
\subsubsection{Eigenspace}\label{CodeEigenspace}
The {\tt ED\_EIGENSPACE} module contains the implementation of the 
{\tt sparse\_espace} class, which maintains an ordered linked list 
of selected eigenvalues, eigenvectors, and quantum numbers for the 
low-lying spectrum of the quantum impurity Hamiltonian. 
Note that, to reduce the memory footprint each eigenvector 
is automatically distributed among all processors in suitable shares
according to the nature of the quantum numbers $\vec{Q}$.
For zero-temperature calculations, only the groundstate (and its
degenerate counterparts) are stored. For finite temperatures
calculations, the list must also include excited states.


\begin{lstlisting}[style=fstyle,numbers=none]    
!Single element of the list: contains a single eigen-solution.
!Twin states are just pointers, no memory.
!double or cmplx vector are automatically MPI distributed.
type sparse_estate
   integer                             :: sector        !Symmetry sector index
   real(8)                             :: e             !eigenvalue: ordering key
   real(8),dimension(:),allocatable    :: dvec          !double  eigen-vector
   complex(8),dimension(:),allocatable :: cvec          !complex eigen-vector
   logical                             :: itwin=.false. !twin sector logical label
   type(sparse_estate),pointer         :: twin=>null()  !link to twin state in the list
   type(sparse_estate),pointer         :: next=>null()  !List next pointer
end type sparse_estate
!Ordered  list storing the lower part of the Hamiltonian spectrum: 
type sparse_espace
   integer                     :: size               !Current list
   real(8)                     :: emax               !Max energy  fixed by ${\color{}e^{-\beta {\tt emax}}<{\tt cutoff}}$
   real(8)                     :: emin               !Min energy:the groundstate energy
   logical                     :: status=.false.     !Allocation status
   type(sparse_estate),pointer :: root=>null()       !Root of the linked list
end type sparse_espace

\end{lstlisting}

To avoid unbounded growth of this list, a  
truncation mechanism is used. On the first call, a fixed number of
states per sector  
\texttt{lanc\_nstates\_sector} is collected, up to a
maximum total \texttt{lanc\_nstates\_total}, both set via input.  
The list is then truncated to retain only the states satisfying the condition $e^{-\beta(E_i-E_0)} < \mathtt{cutoff}$, where
$E_i$ is the energy of the $i^{\rm th}$ state in the list, $E_0$ is the
groundstate energy,  $\beta=1/T$ is the inverse temperature ($k_B=1$) and \texttt{cutoff}
is an input parameter fixing an a priori energy threshold.


The list dynamically adjusts to optimize the distribution of states 
across sectors, balancing memory use and computation time. The
variable \texttt{lanc\_nstates\_step} controls the increase or
decrease in the number of states per sector. 
A histogram  of the number of states per sector is produced after each diagonalization 
to monitor this distribution.



\subsubsection{GFmatrix}
One of the main goal of the \NAME is to evaluate dynamical correlations
functions (DCF), e.g. $D(t) = \ibra \TT[ A(t) A^+ ]\iket$. Using Krylov methods,
these DCFs can be expressed as truncated Kallen-Lehmann spectral sums of the form
$$
D(z) = \tfrac{1}{Z}\sum_n e^{-\beta E_n} \sum_{m=1}^{N} \tfrac{|w_{mn}|^2}{ z
  - dE_{mn}}
$$
where $w_{mn}$ is the weight determined by the projection of the
$m^{\rm th}$ eigenstate onto the $n^{\rm th}$ Krylov basis vector and
$dE_{mn}=E_m-E_n$ is the corresponding excitation energy.

The {\tt ED\_GFMATRIX} module implements the {\tt gfmatrix} class, 
which provides an efficient, multi-layer data structure for storing 
all weights and poles required for the evaluation of DCFs. This 
class is designed to handle multiple operators and sectors, allowing 
for rapid, on-the-fly evaluation of the DCF for any complex frequency 
$z\in\CCC$.

The use of this data structure significantly reduces the computational 
cost of evaluating DCFs by minimizing redundant calculations and 
avoiding repeated diagonalizations, making it a critical component 
for the high-performance execution of \NAME.

\begin{lstlisting}[style=fstyle,numbers=none]   
!The contributions to the GF Kallen-Lehmann sum are stored as
!GF_{ab,sr}%state%channel%{w,e}.
!A couple of weight,poles {w,e} is stored: 
!for each *channel, i.e. !applied operator, for any starting state ${\color{comment-color}\ket{n}}$.
!
!Sub-class: contains the actual weight and poles:
type GFspectrum
   complex(8),dimension(:),allocatable       :: weight
   real(8),dimension(:),allocatable          :: poles
end type GFspectrum
!
!N_channel = ${\color{comment-color} C,\, C^\dagger,\, C \pm C^\dagger,\, C \pm iC^\dagger}$, etc.
!Sub-class: contains a given set of weights and poles.
!Each instance of this sub-class correponds to a given input state 
!and a given operator in the Kallen-Lehman representation.  
type GFchannel
   type(GFspectrum),dimension(:),allocatable :: channel 
end type GFchannel
!
!Main class: stores  weights and poles of a given DCF 
!obtained through the dynamical Lanczos algorithm.
!state_list%size = # of state in the spectrum 
type GFmatrix
   type(GFchannel),dimension(:),allocatable  :: state
   logical                                   :: status=.false.!Allocation status
end type GFmatrix
\end{lstlisting}




















\subsection{Bath parametrization}\label{sSecBath}
The quantum impurity problem is characterized by the coupling between
a local impurity and a surrounding bath. Following the structure of
Eq.~\ref{Hbath}, the bath is parametrized by two components: the
Hamiltonian matrices, $h^p$, and the hybridization amplitudes,
$V^p$, for $p = 1, \dots, N_\mathrm{bath}$.
Internally, the bath is represented by a dedicated object, {\tt
  effective\_bath}, defined in the {\tt ED\_VARS\_GLOBAL} module. From
the user's perspective, all parameters are consolidated into a rank-1
array of doubles, managed using a reverse communication strategy. This
approach ensures that a local array remains accessible to the
user while preventing direct access to the internal copy, thereby
preserving data integrity and reducing memory overhead.


The bath topology, which defines the connectivity between the
electronic levels assigned to the bath, is specified
through the input variable {\tt bath\_type}. In \NAME this variable can take one of four possible values: {\bf normal}, {\bf hybrid}, {\bf replica}, and {\bf general}.

\paragraph{{\tt bath\_type}={\bf normal}.} In this configuration, the
bath consists of $N_\mathrm{bath}$
electronic sites coupled to each impurity orbital, resulting
in $N_\mathrm{b} = N_\a N_\mathrm{bath}$ bath levels and a total size of $N_\mathrm{s}=(N_\mathrm{bath}+1)N_\a$.
For {\tt ed\_mode}={\bf normal} the bath Hamiltonian is parametrized as diagonal matrices in both the orbital and spin spaces:
$$
h^p_{\a\b\s\s'}=\varepsilon_{\a\s}\delta_{\a\b}\delta_{\s\s'} .
$$
where $\varepsilon_{\a\s}$ represents  the on-site energies for each orbital and spin. 
%
If {\tt ed\_mode}={\bf superc},  anomalous
amplitudes connecting bath levels with opposite spins must also be
considered. In this case, the bath Hamiltonian gains 
an additional set of parameters $\Delta^p_{\a}\delta_{\a\b}\delta_{\s \overline{\s}}$, diagonal in orbital space but
off-diagonal in the spin, where $\Delta^p_\a$ represents the pairing amplitudes. 
This choice corresponds to a Nambu representation for each orbital component,
with the Hamiltonian matrices taking the form:
$$
\hat{h}^p_{\a\b} = \e_{\a}\delta_{\a\b}\tau_0 +
\Delta_{\a}\delta_{\a\b}\tau_x .
$$
where $\tau_{i=0,x,y,z}$ are Pauli matrices.
%
The hybridization amplitudes between the impurity and the bath levels
are similarly structured. For all values of {\tt ed\_mode} these
parameters are diagonal in both
spin and orbital space: $V^p_{\a\b\s\s'}=V^p_{\a\s}\delta_{\a\b}\delta_{\s\s'}$.
%
If {\tt ed\_mode}={\bf nonsu2}  an additional set including terms describing spin-flip processes (as total magnetization is not conserved) should be included $V^p_{\a\b\s\s'} =
W^p_{\a}\delta_{\a\b}\delta_{\s \overline{\s}}$. 

Thus, the total number of parameters used to determine the bath is $N_\mathrm{param}=2N_\a N_\mathrm{bath}$ for {\tt ed\_mode}={\bf normal} or $N_\mathrm{param}=3N_\a N_\mathrm{bath}$ for the other two values of {\tt ed\_mode}.


\paragraph{{\tt bath\_type}={\bf hybrid}.}
This hybrid topology is the simplest generalization of the bath pa\-ra\-me\-tri\-za\-tion which captures the effects of locally
coupled impurity orbitals. However this setup typically requires a more challenging optimization process, especially
with few available bath levels (see \secu{sSecFit}). 
The bath is formed by $N_\mathrm{bath}$ sites coupled to all the
impurity orbitals, so that there are $N_\mathrm{b}\equiv  N_\mathrm{bath}$ bath levels and   $N_\mathrm{s}=N_\mathrm{bath}+N_\a$. 
The parametrization of the bath Hamiltonian is 
diagonal in both orbital and spin space, i.e.,
$$
h^p_{\a\b\s\s'}=\varepsilon_{\a\s}\delta_{\a\b}\delta_{\s\s'}.
$$
%
The key difference with respect to the previous case is that the hybridization matrix elements are generally off-diagonal in the orbital indices:
$$
V^p_{\a\b\s\s'}=V^p_{\a\b\s}\delta_{\s\s'}.
$$
Moreover, the {\tt ed\_mode}={\bf superc} introduces additional anomalous components 
$\Delta^p_{\a\b}\delta_{\s\overline{\s}}$, including intra- and inter-orbital pairings.
%
If full spin symmetry is not preserved, i.e. for {\tt ed\_mode} = {\bf nonsu2}, a further 
set of parameters must be specified to account for spin-flip processes:
$V^p_{\a\b\s\s'} = W^p_{\a\b}\delta_{\s \overline{\s}}$. 

The resulting total number of available bath parameters are 
 $N_\mathrm{param}=N_\mathrm{bath}+ N_\a N_\mathrm{bath}$ for {\tt ed\_mode}={\bf normal},  
 $N_\mathrm{param}=2N_\mathrm{bath}+ N_\a N_\mathrm{bath}$ if  {\tt ed\_mode}={\bf superc} or 
$N_\mathrm{param}=N_\mathrm{bath}+ 2N_\a N_\mathrm{bath}$ for  {\tt ed\_mode}={\bf nonsu2}.



\paragraph{{\tt bath\_type}={\bf replica},{\bf general}.}
This configuration provides a more flexible parametrization of the 
bath. The original core idea \cite{Capone2004PRB,Civelli2006}
is to assign each bath element a structure 
that {\it replicates} the internal structure of the impurity, while 
maintaining diagonal coupling between bath elements and the impurity. 
This offloads the complexity of representing structured quantum 
impurities to the bath Hamiltonian rather than the hybridizations.

From a broader perspective, this can be formalized by considering  
a user-defined matrix basis
$\vec{\Gamma}=\{ \Gamma^\nu_{\a\b\s\s'} \}_{\nu=1,\dots,N_\mathrm{sym}}$ in the (Nambu-)spin-orbital
space, and expressing the bath Hamiltonian as
$$
h^p = \sum_{\nu=1}^{N_\mathrm{sym}} \lambda^p_\nu
\Gamma^\nu\equiv \vec{\lambda}^p\cdot \vec{\Gamma}
\label{eq:replica_bath_sym}
$$
where $\vec{\lambda}^p\in\RRR^{N_\mathrm{sym}}$ is a vector of variational parameters. 
The choice of the matrix basis can be inspired by symmetry group considerations \cite{Senechal}, by the internal structure
of the quantum impurity, i.e. $\hat{h}^0$, or determined
case-by-case, depending on the desired properties of the solution.
In this scheme, the total number of bath levels is  $N_\mathrm{b}
= N_\a N_\mathrm{bath}$. 


For the {\bf replica} topology, the coupling between the impurity 
and each bath element is independent on spin, orbital, and internal 
bath structure: $V^p_{\a\b\s\s'} = V^p$.
In the {\bf general} case, the coupling includes explicit 
diagonal
dependence on the internal spin and orbital indices: $V^p_{\a\b\s\s'}
= V^p_{\a\s}\delta_{\a\b}\delta_{\s\s'}$. 
%
The number of independent bath parameters to optimize is either 
$N_\mathrm{params} = (N_\mathrm{sym}+1)N_\mathrm{bath}$ for {\tt bath\_type}={\bf replica} or 
$N_\mathrm{params} = (N_\mathrm{sym}+N_\a N_\s)N_\mathrm{bath}$ for {\tt bath\_type}={\bf general}.

We summarize the total number $N_s$ of electronic levels of the quantum impurity system according to the value of $N_\a$, $N_\mathrm{bath}$ and the bath topology in the following table:
\begin{center}
\begin{tabular}{ |c||c|c|c|c| } 
 \hline     
{\tt bath\_type} & {\bf normal} & {\bf hybrid} & {\bf replica} & {\bf general}\\
 \hline 
  \hline    
  $N_s$ & 
 $(N_\mathrm{bath}+1)N_\a$ & 
 $N_\mathrm{bath}+N_\a$ & 
 $N_\a(N_\mathrm{bath}+1)$ & 
 $N_\a(N_\mathrm{bath}+1)$  \\ 
 \hline
\end{tabular}
\end{center}

\vspace{2mm}
All the procedures concerning the bath, either on the user side or concerning the internal {\tt effective\_bath}, are grouped into a set of modules wrapped by {\tt ED\_BATH}. We divided the set of modules in three categories, according to their scope.



\paragraph{Bath Auxiliary Tools}
This module group provides user-oriented utilities, including 
standard symmetry operations on the bath array, such as orbital 
symmetry and particle-hole symmetry, available in 
{\tt ED\_BATH\_USER}. The critical functionality here is the 
determination of the total bath array dimension, implemented in 
{\tt ED\_BATH\_DIM}. The function {\tt ed\_get\_bath\_dimension} 
calculates the required dimension $N_\mathrm{params}$ for user-allocated bath 
arrays, ensuring they contain exactly the necessary number of 
parameters. Any following call
to functions hosting the bath as an input verify the array's 
dimensionality using {\tt check\_bath\_dimension} to prevent 
allocation errors.

The following table summarizes the total number of parameters $N_\mathrm{params}$, as returned by the function {\tt ed\_get\_bath\_dimension} and required to describe the bath according to the values of {\tt ed\_mode} and {\tt bath\_type}:

\begin{center}
\begin{tabular}{ |c||c|c|c|c| } 
 \hline     
 $N_\mathrm{params}$ & {\bf normal} & {\bf hybrid} & {\bf replica} & {\bf general}\\
 \hline 
 \hline    
 {\bf normal} & 
 $2N_\a N_\mathrm{bath}$ & 
 $(N_\a+1)N_\mathrm{bath}$ & 
 $(N_\mathrm{sym}+1)N_\mathrm{bath}$ & 
 $(N_\mathrm{sym}+N_\a)N_\mathrm{bath}$\\
 \hline
   {\bf superc} & $3N_\a N_\mathrm{bath}$ & 
 $(N_\a+2)N_\mathrm{bath}$ & 
 $(N_\mathrm{sym}+1)N_\mathrm{bath}$ & 
 $(N_\mathrm{sym}+N_\a)N_\mathrm{bath}$\\
 \hline
   {\bf nonsu2} & $3N_\a N_\mathrm{bath}$ & 
 $(2N_\a+1)N_\mathrm{bath}$ & 
 $(N_\mathrm{sym}+1)N_\mathrm{bath}$ & 
 $(N_\mathrm{sym}+N_\a)N_\mathrm{bath}$\\
 \hline
\end{tabular}
\end{center}

\paragraph{Bath Replica (General).}
The module {\tt ED\_BATH\_REPLICA} defines the class {\tt Hreplica} ({\tt Hge\-ne\-ral}) for the {\bf replica}  ({\bf general}) bath parametrizations. In  addition to standard object construction, destruction, reading, and saving, this module provides matrix basis  
$\{ \Gamma^\nu \}_{\nu=1,\dots,N_\mathrm{sym}}$ setup as well as  the variational parameters $\vec{\lambda}$ initialization through {\tt set\_Hreplica} ({\tt set\_Hge\-ne\-ral}). 

The bath Hamiltonian is constructed with the function 
{\tt build\_Hreplica} ({\tt build\_Hge\-ne\-ral}) via the relation:
$$
h^p = \vec{\lambda}^p \cdot \vec{\Gamma}.
$$



\paragraph{Effective Bath.}
The module {\tt ED\_BATH\_DMFT} implements the class 
{\tt effective\_bath} (defined in {\tt ED\_VARS\_GLOBAL}), which 
manages all the actual bath parameters for any choice of 
{\tt ed\_mode} and {\tt bath\_type}. For the 
{\bf replica/general} topologies, it directly references the 
{\tt Hreplica} class. A global instance of this class, 
{\tt dmft\_bath}, is shared throughout the code, providing a 
centralized structure for bath parameter management.

The constructor for this class includes the function 
{\tt init\_dmft\_bath}, which either initializes bath parameters 
from scratch or reads them from a file specified by the input 
variable {\tt Hfile} as {\tt <Hfile>.restart}. Additionally, the class offers methods to 
translate bath parameters between the internal {\tt dmft\_bath} 
representation and the user-defined bath arrays via 
{\tt get/set\_dmft\_bath}.









\subsection{Lanczos based Diagonalization}\label{sSecHam}
In presence of symmetries (see \secu{sSecQNs}) the matrix representing
the Hamiltonian operator $\hat{H}$ can be reduced to a block-diagonal form. Each block corresponds to a symmetry sector
with a fixed set of quantum numbers $\vec{Q}$ and is represented by
a Hamiltonian matrix $H_{\SS_{\vec{Q}}}$. 
Consequently, the analysis of the quantum impurity energy spectrum reduces to solving
the secular equation within each individual symmetry sector:
$$
H_{\SS_{\vec{Q}}}\ket{v}=E_{\SS_{\vec{Q}}}\ket{v}.
$$

Even though the dimension of a given sector $\SS$ is much smaller than the
total Fock space dimension $D_\SS \ll D_\FF$, solving completely the
corresponding eigenvalue problem remains a formidable challenge
already for $N_\mathrm{s}\simeq 8$.
To outwit this, various
algorithms have been developed exploiting the sparse nature of
$H_\SS$, including Krylov subspace methods and related approaches
\cite{Lanczos,Arnoldi,Feast}.

In \NAME, the preferred algorithm is P-ARPACK, a state-of-the-art
Lanczos-based eigensolver with distributed memory support
\cite{P-Arpack}. This method incorporates re-orthogonalization within
a block-Lanczos routine, ensuring the accurate convergence of the desired eigen-pairs. However, it is also possible to select a simpler,
though less efficient, parallel Lanczos algorithm using the input variable {\tt lanc\_method}.

The core computational task in any Krylov-based diagonalization
algorithm is the Matrix-Vector Product (MVP), i.e.~the application
of the Hamiltonian to a given input vector:
\begin{equation}
H_\SS \ket{v} \to \ket{w}\qquad \ket{v},\ket{w}\in \SS_{\vec{Q}}.
\end{equation}
This operation accounts for more than 80\% of the overall
computational effort, making its optimization a critical aspect of
high-performance diagonalization algorithms. In \onlinecite{Amaricci2022} we discussed in full details 
the distributed-memory, massively parallel strategies currently employed in \NAME
to optimize this step. Here, we provide
a brief outline of the main ideas for the purely electronic case (i.e. neglecting electron-phonon part), following the notation introduced
in \onlinecite{Amaricci2022}, and focusing on the impact of the choice of {\tt ed\_mode}.

\paragraph{\bf normal}.
In this case, the tensor structure of the Fock space and the sector
symmetries are fully leveraged. Within a given sector, the electronic
part of the Hamiltonian can be expressed as:
\begin{equation}
H_\SS = H_\mathrm{d} + H_\up\otimes \11_\dw + \11_\up\otimes
H_\dw + H_\mathrm{nd},
\label{HssNormal}
\end{equation}
where $H_\mathrm{d}$ represents the diagonal (local) part of the
Hamiltonian, including density-density interactions, while
$H_\sigma$ captures hopping processes for electrons with spin
$\sigma=\up,\dw$. The term $H_\mathrm{nd}$ encompasses all remaining
non-diagonal contributions, such as spin-exchange and pair-hopping
terms.

In this formulation, a sector state $\ket{v}$ can be
represented in a matrix basis $\hat{v}$ with rows (columns)
corresponding to $\up$ ($\dw$) configurations. This structure allows
for efficient MVP operations using {\tt MPI\_All2AllV}, which aims to
optimize memory locality. However, terms in $H_\mathrm{nd}$ that
break this structure require {\tt MPI\_AllGatherV}, introducing a
slight communication overhead which partially reduces the parallel efficiency.





\paragraph{\bf superc/nonsu2.}
For these modes, symmetries enforce specific constraints between
$\up$ and $\dw$ configurations, preventing the direct use of the
factorized Fock space representation. The electronic
part of the Hamiltonian is typically structured as:
\begin{equation}
H_\SS = H_\mathrm{imp} + H_\mathrm{int} + H_\mathrm{bath} + H_\mathrm{imp-bath},
\end{equation}
where $H_\mathrm{imp}$ encodes the local impurity Hamiltonian
determined by $h^0_{\a\b\s\s'}$,
$H_\mathrm{int}$ contains the interaction terms, $H_\mathrm{bath}$
describes the effective bath contributions corresponding to
$h^p_{\a\b\s\s'}$, and $H_\mathrm{imp-bath}$ accounts for the
impurity-bath couplings $V^p_{\a\b\s\s'}$.
In an MPI setup, the first three terms contains also elements local to each node and
stored separately within each {\tt sparse\_matrix} instance representing $H_\SS$ (see \secu{CodeSparseMatrix}).
The MVP is carried out using the {\tt MPI\_AllGatherV} algorithm which, as noted  
\onlinecite{Amaricci2022}, requires reconstruction of distributed
arrays and incurs significant communication overhead.
\vspace{2mm}


\noindent
The diagonalization process itself is divided into two primary phases:
\paragraph{\bf Global Setup.} This phase allocates the required memory, initializes
the MPI environment, and configures the appropriate MVP procedure
based on the symmetries of the problem. This logic is implemented in
a set of independent modules, {\tt ED\_HAMILTONIAN\_?}, where
{\tt ed\_mode=?}. Any module includes two functions: {\tt build\_Hv\_sector\_?} and  {\tt vecDim\_Hv\_sector\_?}.

The {\tt build\_Hv\_sector\_?} function builds the symmetry sector and
allocates the MVP function by setting the shared abstract function pointer {\tt
  spHtimesV\_p} to the correct MVP function. 
  This latter step is controlled by the value of
{\tt ed\_sparse\_H=T/F}. If {\tt T} the Hamiltonian $H_\SS$
gets stored in a {\tt sparse\_matrix} instance and used to perform
the MVPs. The corresponding algorithms are implemented in the modules {\tt
  ED\_HAMILTONIAN\_?\_STORED\_HxV}
If {\tt ed\_sparse\_H} is {\tt F} the MVP is operated on-the-fly,
i.e. each element of $H_\SS$ is directly applied to the input
vector $\ket{v}$, either in serial or parallel mode as implemented in {\tt
  ED\_HAMILTONIAN\_?\_DIRECT\_HxV}.  

The function {\tt vecDim\_Hv\_sector\_?} returns the 
dimension of the vector used in the
MVP. In a MPI-parallel execution the returned value is the
dimension $d_i$ of the vector chunk per each node such that
$\sum_{i=1}^{N_\mathrm{nodes}}d_i = D_\SS$. Yet, the specific value of $d_i$
depends on the MPI algorithm used for the MVP function.

\paragraph{\bf Diagonalization}
This step is managed by the {\tt ED\_DIAG\_?}
modules, which contain the main functions {\tt diagonalize\_impurity\_?}.
This phase includes: (i) selecting sectors for diagonalization, (ii)
performing diagonalization within each sector, and (iii) analyzing
the resulting {\tt state\_list} of conserved eigenstates.




\subsection{Dynamical correlation functions}\label{sSecGF}
The determination of the low energy part of the Hamiltonian spectrum
enables the evaluation of the Dynamical Correlation Functions (DCFs) using Krylov sub-space algorithm.
This capability is central to the library when using \NAME as an
impurity solver within the DMFT framework.

Before delving into the implementation specifics, we outline the
generic approach. Consider the generic DCF:
\begin{equation}
  \label{eqGaa}
  C_\AA = \ibra \TT_\pm[ \AA(t) \AA^+ ]\iket
\end{equation}
where $\AA(t)=e^{iHt}\AA e^{-iHt}$, $\TT_\pm$ is the time-ordering
operator for fermions ($-$) or
bosons ($-$), and $\ibra \AA \iket=\frac{1}{Z}\Tr{ \left[ e^{-\beta
      H}\AA \right]}$, with $Z=\sum_ne^{-\beta E_n}$, the thermodynamic
average.
Using spectral decomposition, the expression \equ{eqGaa} reduces to a
K\"all\`en-Lehmann form:
\begin{equation}\label{KLgf}
  \begin{split}
    C_\AA(z) 
    &=  \ibra \AA \frac{1}{z-H} \AA^+\iket
    \mp \ibra \AA^+ \frac{1}{z+H} \AA\iket \cr
    %
    & =\frac{1}{Z}\sum_n e^{-\beta E_n}\sum_m
  \frac{ |\bra{\psi_m}\AA^+ \ket{\psi_n}|^2 }  {z-(E_m-E_n)}
  \mp
  \frac{ |\bra{\psi_m}\AA \ket{\psi_n}|^2 }  {z+(E_m-E_n)}\cr
\end{split}
\end{equation}
where $z\in\CCC$,  $\ket{\psi_n}$, $E_n$ are the eigen-solutions of the
Hamiltonian $H$. 
This form is appealing but computationally prohibitive, as it requires
the full Hamiltonian spectrum. However, the first line in \equ{KLgf}
highlights that the $C_\AA$ essentially corresponds to a specific
matrix element of the resolvant operator $(z-H)^{-1}$, which can be
efficiently approximated using the Krylov sub-space method.

To illustrate this approach, consider the normalized initial state: 
$$
\ket{\phi_n}=\AA^+\ket{\psi_n}/\NN_n
$$
where  $\ket{\psi_n}\in\SS$ is an eigenstate of the sector Hamiltonian and $\NN_n=\sqrt{\bra{\psi_n}\AA
  \AA^+\ket{\psi_n}}$.
The Krylov basis is constructed by repetead applications of the secctor Hamiltonian via MVP: 
$$
\mathcal{K}_{N} (\ket{\phi_n})=\{\ket{\phi_n}, H\ket{\phi_n}, \dots,
H^N\ket{\phi_n}\}\equiv \{\ket{v^n_0}, \ket{v^n_1},\dots, \ket{v^n_N}
\}
$$ 
with $1 \ll N \ll \DD_\SS$..
Given that any eigenstate $\ket{\psi_n}$ can be expressed within the Krylov basis as
$$
\ket{\psi_n} = \sum_i  \ibra v^n_i|\psi_n \iket  \ket{ v^n_i} =
\sum_i a^n_i \ket{v^n_i}, 
$$
we can approximate the expression \equ{KLgf} as:  
\begin{equation}
  \label{eqGKrylov}
  \begin{split}
    C_\AA(z)  &\simeq \frac{1}{Z}\sum_n e^{-\beta E_n}
    \sum_{m=1}^{N} \frac{\bra{\psi_n}\AA \AA^+\ket{\psi_n} |a^n_m|^2}{
      z - (E_m-E_n)} \mp \frac{\bra{\psi_n}\AA^+ \AA\ket{\psi_n}
      |a^n_m|^2}{ z + (E_m-E_n)}\cr
    %
    &= \frac{1}{Z}\sum_n\sum_{m=1}^{N} \sum_{\nu=\pm}\frac{w^{\nu}_{mn}[\AA]}{z - dE^\nu_{mn}[\AA]} 
    = \frac{1}{Z}\sum_n
    \sum_{m=1}^{N} \sum_{\nu=\pm} g_\AA(\nu, w^{\nu}_{mn},  dE^\nu_{mn}) \cr
  \end{split}
\end{equation}
where the terms are grouped as a sum over spectral weights and
poles. We introduced the notation $g(\nu, w(\AA)^{\nu}_{mn},  dE(\AA)^\nu_{mn})$
for the {\tt gfmatrix} object containing the weights $w(\AA)^{\nu}_{mn}$ and
poles $dE(\AA)^{\nu}_{mn}$ for the operator $\AA$, for every initial state $\ket{\psi_n}$
contributing to the low energy spectrum, for every order $m$ of the
Krylov sub-space algorithm and for channel $\nu$.
This approach significantly reduces the computational burden, as it
relies on a much smaller set of basis states.

However, this method is typically limited to diagonal DCF like
\equ{eqGaa}. In practice, many applications requires also to build off-diagonal
functions of the form:
$C_{\AA\BB}(z) = \ibra T_{\pm}[\AA(t) \BB^+]\iket$.
This can be addressed by introducing auxiliary operators, e.g.  $\OO=\AA +\BB$ and
$\PP=\AA-i\BB$, enabling the extraction of the desired function via
simple algebraic combinations:
$$
C_{\AA\BB} = \frac{1}{2}\left[C_\OO + C_\PP - (1-i)C_\AA -(1-i)C_\BB\right]
$$


In \NAME, the computation of the impurity Green's functions 
$G_{\a\b\s\s'}=\ibra \TT_\pm[ c_{\a\s}(t) c_{\b\s'}^+ ]\iket$
is handled by the \texttt{ED\_GREENS\_FUNCTIONS} module.
This integrates more specialized methods based on the symmetry
classification defined by the \texttt{ed\_mode} parameter.
Moreover, in the {\bf normal} mode, \NAME also includes spin, charge, pair, and excitonic susceptibility functions, providing a comprehensive framework for dynamical response calculations.
From a computational perspective, the construction of the Krylov basis
$\mathcal{K}_N(\OO\ket{\psi_n})$ for each eigenstate within the low-energy
spectrum is typically the most resource-intensive step.
As with the
diagonalization process, a significant performance gain is achieved through
the parallel execution of the MVP at the core of
the Hamiltonian tri-diagonalization algorithm.
The input variable
\texttt{lanc\_gfniter} regulates the maximum order of the Krylov basis,
determining the upper limit on the number of excitations considered in
\equ{eqGKrylov}.
Operationally, each symmetry mode (\texttt{ed\_mode=?}) requires a distinct
strategy for Green's function construction, implemented in the corresponding
\texttt{ED\_GF\_?} modules.


\paragraph{{\bf normal}.}
In this mode, all orbital-dependent and spin-diagonal Green's 
functions $G_{\a\b\s\s}$ must be evaluated. The diagonal 
case, where $\a=\b$, is straightforward and involves applying 
the operator $\AA=c_{\a\s}$ to any eigenstate $\ket{\psi_n}$ 
from the global {\tt state\_list} of the low-energy spectrum, 
which is represented by the {\tt sparse\_espace} object. This 
operation relies on the functions {\tt apply\_op\_C/CDG} in 
{\tt ED\_AUX\_FUNX}. 



The sector Hamiltonian matrix in this mode is assumed 
to be real symmetric, which significantly simplifies the evaluation of the off-diagonal terms. In this case, the following symmetry relation 
$G_{\a\b\s\s}=G_{\b\a\s\s}$ holds, allowing the computation of 
off-diagonal components using an auxiliary operator 
$\OO=c_{\a\s}+c_{\b\s}$ and the identity:
$G_{\a\b\s\s}=\tfrac{1}{2}(C_\OO - G_{\a\a\s\s} - G_{\b\b\s\s})$.

The diagonal spin, charge and pair susceptibility terms
$\chi^{S^z}_{\a\a}$, $\chi^N_{\a\a}$ and $\chi^\Delta_{\a\a}$
are constructed using the operators $S^z_\a = \sum_{\s\s'} c^+_{\a\s}
\tau^z_{\s\s'} c_{\a\s'}$, 
$N_\a = \sum_{\s\s'} c^+_{\a\s} \tau^0_{\s\s'} c_{\a\s'}$
and $\Delta_\a = c_{\a\dw}c_{\a\up}$,
where $\tau^{a=0,x,y,z}$ are the Pauli matrices.
Off-diagonal terms are  evaluated using the operators
$(S^z_\a + S^z_\b)$, $(N_\a + N_\b)$ or $(\Delta_\a + \Delta_\b)$. 
The Excitonic susceptibilities, $\chi^\vec{T}_{\a\b}$, are defined with 
respect to the vector operator: $T^i_{\a\b} = \sum_{\s\s'}
c^+_{\a\s}\tau^i_{\s\s'}c_{\b\s'}$, where $i=0$ represents the
spin-singlet exciton, and $i=x,y,z$  correspond to the spin-triplet exciton.


\paragraph{{\bf superc}.}
In the supercondutive case, the Nambu orbital-dependent $s$-wave
Green's function has the form:
\begin{equation}
  \label{GFnambu}
  \hat{G}_{\a\b} =
  \begin{bmatrix}
    G_{\a\b\up\up} & F_{\a\b\up\dw} \\
    \bar{F}_{\a\b\dw\up} & \bar{G}_{\a\b\dw\dw}
  \end{bmatrix}  
\end{equation}
Exploiting symmetries between matrix components, it is 
sufficient to compute only the top row elements along with 
a few auxiliary functions.

The diagonal normal component $G_{\a\a\up\up}$ can be 
evaluated using the same approach as in the {\bf normal} 
case. However, for the off-diagonal terms $G_{\a\b\up\up}$, 
we forgo symmetry arguments and instead define two 
auxiliary operators, $\OO = c_{\a\up} + c_{\b\up}$ and 
$\PP = c_{\a\up} - i c_{\b\up}$. This allows us to express 
the Green's function as::
$G_{\a\b\up\up}=\tfrac{1}{2}[C_\OO + C_\PP -
(1-i)(G_{\a\a\up\up}+G_{\b\b\up\up})$.

Evaluating the diagonal and off-diagonal anomalous terms 
$F_{\a\b\up\dw}$ requires distinct combinations of 
creation and annihilation operators. First, the component 
$\bar{G}_{\a\a\dw\dw}$ is evaluated as an auxiliary term 
using $\AA = c^+_{\a\dw}$. Then, we construct two further 
linear combinations:
\begin{align*}
\TT &= c_{\a\up} + c^+_{\b\dw}, \\
\RR &= c_{\a\up} - i c^+_{\b\dw},
\end{align*}
which contribute to the auxiliary functions $C_\TT$ and 
$C_\RR$, respectively. The final expression for the 
anomalous function reads:
\begin{equation}
F_{\a\b\up\dw} = \tfrac{1}{2} \left[ C_\TT + C_\RR - 
(1-i)(G_{\a\a\up\up} + \bar{G}_{\b\b\dw\dw}) \right].
\end{equation}



\paragraph{{\bf nonsu2}.}
In this case, all Green's function components 
must be explicitly evaluated, as the spin and orbital 
symmetries are in general not conserved. For the diagonal terms 
$G_{\a\a\s\s}$, the procedure follows the same approach 
outlined in the {\bf normal} case. 

The off-diagonal components $G_{\a\b\s\s'}$, however, 
require a more general treatment. These are computed using 
auxiliary operators defined as:
\begin{align*}
\OO &= c_{\a\s} + c_{\b\s'}, \\
\PP &= c_{\a\s} - i c_{\b\s'},
\end{align*}
which allows the Green's function to be expressed as:
\begin{equation}
G_{\a\b\s\s'} = \tfrac{1}{2} \left[ C_\OO + C_\PP - 
(1-i)(G_{\a\a\s\s} + G_{\b\b\s'\s'}) \right].
\end{equation}
This approach effectively reduces the complexity of 
evaluating the off-diagonal terms by leveraging auxiliary 
functions, despite the absence of full spin symmetry.





\subsection{Observables}\label{sSecObc}
A wide range of predefined impurity observables and local 
static correlations, such as occupation numbers, total 
energy, pair amplitudes, and excitonic order parameters, 
are computed in the \texttt{OBSERVABLES} module. Similar to 
previous cases, this module wraps different implementations 
depending on the operational mode specified by 
{\tt ed\_mode=?} and is distributed across the corresponding 
files {\tt ED\_OBSERVABLES\_?}. 



Local observables and correlations are generally defined 
through the thermal average 
$\ibra \OO\iket = \tfrac{1}{Z}\Tr\left[e^{-\beta H}\OO\right]$, 
where $Z = \sum_n e^{-\beta E_n}$ is the partition function. 
At zero or low temperatures, this can be efficiently 
evaluated using the stored low-energy part of the spectrum, 
taking advantage of the exponential suppression provided by 
the Boltzmann factor:
\begin{equation}
\ibra \OO\iket = \frac{1}{Z}\sum_n e^{-\beta E_n}
\bra{\psi_n} \OO \ket{\psi_n}\simeq \frac{1}{Z}\sum_{n=1}^{N_{\tt state\_list}} e^{-\beta E_n}
\bra{\psi_n} \OO \ket{\psi_n},
\label{eq:thermal_average}
\end{equation}
where $E_n$ and $\ket{\psi_n}$ are the low-lying eigenstates 
of the system stored in the {\tt state\_list}. This approach 
greatly reduces computational overhead by focusing on the 
relevant, low-energy sector.









\subsection{Impurity reduced density matrix}\label{sSecRDM}
The latest version of \NAME introduces the calculation of the 
impurity Reduced Density Matrix (iRDM, $\rho^\mathrm{imp}$), 
extending the algorithm initially proposed in 
Ref.~\onlinecite{BellomiaPhD}, to support the analysis of entanglement 
properties of quantum impurities for any value of {\tt ed\_mode}.

For sake of simplicity, this section focuses on the zero-temperature limit, 
assuming a non-degenerate ground state $\ket{\psi}$ present in the 
{\tt state\_list}. The generalization to the finite-temperature regime 
or degenerate ground states is straightforward, requiring only the  introduction of an
ensemble average $\ibra \rho^\mathrm{imp} \iket$, as defined in 
\equ{eq:thermal_average}.


A pure quantum state $\ket{\psi}$ belonging to a unique symmetry 
sector $\SS_{\vec{Q}}$ can be represented in the Fock basis as:
$
\ket{\psi} = \sum_I a_I \ket{I},
$
where the corresponding pure density matrix $\rho$ is given by:
\begin{equation}
\rho = \ket{\psi}\bra{\psi} = \sum_{IJ=1}^{4^{N_\mathrm{s}}} 
a^*_J a_I \ket{I}\bra{J} = \sum_{IJ=1}^{4^{N_\mathrm{s}}} 
\rho_{IJ} \ket{I}\bra{J}.
\end{equation}
The iRDM is obtained by tracing out the bath degrees of freedom:
\begin{equation}
\rho^\mathrm{imp} = \Tr_\mathrm{bath}(\rho).
\end{equation}
However, the memory footprint of $\rho$, as well as the CPU footprint 
of the summations involved in this trace scales exponentially 
with the system size, i.e.~$4^{N_\mathrm{s}}$, quickly becoming prohibitive.

To overcome the issue, we implement a fast algorithm that exploits the 
block structure of the Fock space defined by the symmetry sectors and
the subsequent map sparsity, to perform the trace \emph{on-the-fly}. 
This approach significantly reduces the computational cost by limiting 
the summation to the sector size $D_\SS$ of the symmetry sector 
$\SS$ to which the ground state (or any eigenstate) belongs, and avoiding
the storage of the large matrix associated with $\rho$.

To efficiently manage this decomposition, we employ a 
{\tt sparse\_map} ${\cal P}$, as detailed in \secu{CodeSparseMap}. 
This structure stores, for each impurity configuration 
(the \emph{key}), the 
corresponding bath configurations 
(the \emph{values}) that 
satisfy the symmetry constraints over the sector quantum numbers
imposed by the {\tt ed\_mode} variable.
We denote the number of (spin-dependent) keys and values respectively
as ${\cal D}_{i\s}$ and ${\cal D}_{b\s}$.
The fast summation algorithm for evaluating the iRDM differs 
significantly between the {\bf normal} and {\bf superc/nonsu2} modes, 
as outlined in the sections below.


\paragraph{{\bf normal}.}
In this case, we take advantage of spin-resolved sector decomposition, 
as discussed in detail in 
\secu{sSecQNs}. 
The global bitset can be split into spin-resolved 
impurity and bath components as:
\begin{equation}
\ket{\vec{n}} =
\ket{\vec{n}_\up}\otimes \ket{\vec{n}_\dw} =
\ket{\vec{i}_\up}\ket{\vec{b}_\up}\otimes \ket{\vec{i}_\dw}\ket{\vec{b}_\dw}.
\end{equation}
Here, creation (destruction) operators  $c^+_{p\sigma}$
($c^+_{p\sigma}$) at position $p$ and for a given spin $\sigma$
act only on the corresponding 
spin subspace, i.e.~they commute with the opposite spin 
subspace $\ket{\vec{n}_{\bar{\s}}}$ without introducing any 
fermionic sign.

In the {\bf normal} mode, the iRDM is restricted to 
{spin-diagonal} blocks. This follows from the observation 
that the conserved quantum numbers are 
\emph{additive} quantities, i.e. 
$N_\s = N_\s^\mathrm{imp} + N_\s^\mathrm{bath}$,
so that the corresponding generator of the symmetry group factorizes as
$U_{N_\s} = U_{N_\s^\mathrm{imp}} \otimes U_{N_\s^\mathrm{bath}}$. 
Since the iRDM acts only on the impurity Fock space, this implies:
\begin{equation}
\begin{aligned}
\rho^\mathrm{imp} &= U_{N_\s}^\dagger \rho^\mathrm{imp} U_{N_\s} = 
U_{N_\s^\mathrm{bath}}^\dagger \otimes U_{N_\s^\mathrm{imp}}^\dagger 
\rho^\mathrm{imp} 
U_{N_\s^\mathrm{imp}} \otimes U_{N_\s^\mathrm{bath}} \\
&= 
U_{N_\s^\mathrm{imp}}^\dagger \rho^\mathrm{imp} U_{N_\s^\mathrm{imp}},
\end{aligned}
\end{equation}
showing that $U_{N_\s^\mathrm{imp}}$ defines a symmetry of 
$\rho^\mathrm{imp}$, which is therefore block diagonal with respect to 
the impurity quantum numbers $N_\s^\mathrm{imp}$.
The resulting iRDM takes the form:
\begin{equation}
  \label{iRDMnormal}
  \begin{aligned}
  \rho^\mathrm{imp} &= \Tr_{b_\up b_\dw}{\rho} = 
  \sum_{b_\up=1}^{D_{b_\up}}
  \sum_{b_\dw=1}^{D_{b_\dw}}
  \bra{b_\up}\otimes\bra{b_\dw}
    \rho
    \ket{b_\dw}\otimes\ket{b_\up}    \cr
    %
    &=
    \sum_{b_\up=1}^{D_{b_\up}}
    \sum_{i_\up=1}^{D_{i_\up}}
    \sum_{p_\up=1}^{D_{p_\up}}
    \sum_{j_\up=1}^{D_{j_\up}} 
    \sum_{q_\up=1}^{D_{q_\up}}
    \Bigg(    \sum_{b_\dw=1}^{D_{b_\dw}}
    \sum_{i_\dw=1}^{D_{i_\dw}}
    \sum_{p_\dw=1}^{D_{p_\dw}}
    \sum_{j_\dw=1}^{D_{j_\dw}} 
    \sum_{q_\dw=1}^{D_{q_\dw}}
    C_{i,p}\,C_{j,q}\,a_{i_\up p_\up i_\dw p_\dw} a^*_{j_\up q_\up j_\dw q_\dw} \cr
    %
    &\qquad    
    \langle b_\up| p_\up\rangle| i_\up\rangle\langle j_\up |\langle q_\up| b_\up\rangle   \otimes \langle b_\dw| p_\dw \rangle|i_\dw\rangle \langle j_\dw  |\langle q_\dw| b_\dw\rangle \Bigg)
    \cr
&=
    \sum_{i_\up=1}^{D_{i_\up}}
    \sum_{j_\up=1}^{D_{j_\up}}
    \sum_{i_\dw=1}^{D_{i_\dw}}
    \sum_{j_\dw=1}^{D_{j_\dw}}
    \underbrace{\left(
    \sum_{b_\up=1}^{D_{b_\up}}
    \sum_{b_\dw=1}^{D_{b_\dw}}
    a_{i_\up b_\up i_\dw b_\dw} a^*_{j_\up b_\up j_\dw b_\dw}
    \right)}_{\rho^\mathrm{imp}_{i_\up j_\up} \otimes\, \rho^\mathrm{imp}_{i_\dw j_\dw} }
    \ket{i_\up}\bra{j_\up}\otimes \ket{i_\dw}\bra{j_\dw},
  \end{aligned}
\end{equation}
where the coefficients $a_I = a_{i_\up b_\up i_\dw b_\dw}$ are the
expansion coefficients of the state on the Fock basis
$\ket{\psi} = \sum_I a_I \ket{i_\uparrow\,  b_\uparrow\,} \otimes \ket{i_\downarrow
  \, b_\downarrow}$.
Notably, the factors $C_{i,b}$, which account for the potential 
fermionic sign from reordering bath and impurity components, are 
trivially 1 due to the absence of cross-spin interference in this 
mode, as enforced by the Kronecker deltas for bath and impurity 
indices.

The numerical implementation relies on the use of the {\tt
  sparse\_map} ($\%sp$) for the groundstate sector as reported in the listing below:  
\begin{lstlisting}[style=fstyle,numbers=none,basicstyle={\scriptsize\ttfamily}]
do IimpUp=0,2**Norb-1
  do JimpUp=0,2**Norb-1
    !Finding the unique bath states connecting IimpUp and JimpUp
    call sp_return_intersection(sectorI%H(1)%sp,IimpUp,JimpUp,BATHup,lenBATHup)
    if(lenBATHup==0)cycle
    do IimpDw=0,2**Norb-1
      do JimpDw=0,2**Norb-1
        !Finding the unique bath states connecting IimpDw and JimpDw -> BATHdw(:)
        call sp_return_intersection(sectorI%H(2)%sp,IimpDw,JimpDw,BATHdw,lenBATHdw)
        if(lenBATHdw==0)cycle
        do ibUP=1,lenBATHup
          IbathUp = BATHup(ibUP)
          do ibDW=1,lenBATHdw
            IbathDw = BATHdw(ibDW)
            !Allowed spin Fock space Istates:
            !Iup = IimpUp +  2^Norb * IbathUp
            !Idw = IimpDw +  2^Norb * IbathDw
            iUP= binary_search(sectorI%H(1)%map,IimpUp + 2**Norb*IbathUp)
            iDW= binary_search(sectorI%H(2)%map,IimpDw + 2**Norb*IbathDw)
            i  = iUP + (iDW-1)*sectorI%DimUp
            !Allowed spin Fock space Jstates:
            !Jup = JimpUp +  2^Norb * IbathUp
            !Jdw = JimpDw +  2^Norb * IbathDw
            jUP= binary_search(sectorI%H(1)%map,JimpUp + 2**Norb*IbathUp)
            jDW= binary_search(sectorI%H(2)%map,JimpDw + 2**Norb*IbathDw)
            j  = jUP + (jDW-1)*sectorI%DimUp
            ! 
            io = (IimpUp + 2**Norb*IimpDw) + 1
            jo = (JimpUp + 2**Norb*JimpDw) + 1
            irdm(io,jo) = irdm (io,jo) + psi(i)*psi(j)*weight
          enddo
        enddo
      enddo
    enddo
  enddo
enddo
\end{lstlisting}



\paragraph{{\bf superc/nonsu2}.}
For these lower-symmetry cases, the absence of a clean Fock space 
factorization introduces additional complexities. Specifically, the 
correct evaluation of the off-diagonal iRDM terms, which connect 
different $[N^\mathrm{imp}_\up,\,N^\mathrm{imp}_\dw]$ blocks, 
requires an explicit computation of fermionic permutation signs.


Consider a generic Fock basis state in the form 
$\ket{I} =\ket{{i}_\up\,{b}_\up\,{i}_\dw\,{b}_\dw}$, , and define the 
ground state as $\ket{\psi} = \sum_I a_I \ket{I}$. 
The pure density 
matrix is then given by
$\rho = \ket{\psi}\bra{\psi} = \sum_{IJ} a_I a^*_J \ket{I}\bra{J}$ 
while the iRDM is obtained by tracing over the bath degrees of 
freedom:
\begin{equation}
  \begin{aligned}
    \rho^\mathrm{imp} &= \Tr_{b_\up b_\dw}{\rho} =
    \sum_{b_\sigma=1}^{D_{b_\sigma}}
    \bra{b_\up\, b_\dw}
    \,\rho\,
    \ket{b_\dw\, b_\up} =
    \sum_{b_\sigma=1}^{D_{b_\sigma}}
    \ibra{b_\up\, b_\dw}
    \ket{\psi}\ibra{\psi}
    \ket{b_\dw\, b_\up}    \cr
    &=
    \sum_{b_\sigma=1}^{D_{b_\sigma}}
    \sum_{i_\sigma=1}^{D_{i_\sigma}}
    \sum_{p_\sigma=1}^{D_{p_\sigma}}
    \sum_{j_\sigma=1}^{D_{j_\sigma}} 
    \sum_{q_\sigma=1}^{D_{q_\sigma}}
    a_{i_\up p_\up i_\dw p_\dw} a^*_{j_\up q_\up j_\dw q_\dw}% \cr
    % &{\phantom =}
    \langle{b_\up\, b_\dw}|{i_\up\, p_\up\, i_\dw\, p_\dw}\rangle
    \langle{q_\dw \,  j_\dw \, q_\up\, j_\up }|{b_\dw\, b_\up}\rangle\, .
  \end{aligned}
\end{equation}
where $a_I = a_{i_\up b_\up i_\dw b_\dw}$ are the expansion
coefficient in the Fock basis.

To further simplify this expression, it is essential to eliminate the 
sums over the internal bath indices $p_\sigma$ and $q_\sigma$, ideally 
contracting them with the outer bath indices $b_\sigma$. This requires 
reorganizing the bit representation of the basis states to bring the 
bath bitsets before the impurity ones:
$$
\ket{i_\up\, p_\up\, i_\dw\, p_\dw} \rightarrow C_{p_\up,i_\dw} \ket{i_\up\, i_\dw \,p_\up\,p_\dw}
$$
where the fermionic sign factor
$C_{p_\up,i_\dw}  = (-1)^{\#\vec{n}_{p\up} \cdot
  \#\vec{n}_{i\dw}}$
accounts for the exchange of the bath $\ket{p_\up}$  and impurity
$\ket{i_\dw}$ bit configurations.
Here, $\#\vec{n}_{\alpha\sigma}$ denotes the number of ones in the 
occupation vector $\vec{n}_{\alpha\sigma}$. 

Substituting this relation back into the iRDM expression yields:
\begin{equation}
    \rho^\mathrm{imp} =
    \sum_{i_\up=1}^{D_{i_\up}}
    \sum_{j_\up=1}^{D_{j_\up}}
    \sum_{i_\dw=1}^{D_{i_\dw}}
    \sum_{j_\dw=1}^{D_{j_\dw}}
    \underbrace{\left(
    \sum_{b_\up=1}^{D_{b_\up}}
    \sum_{b_\dw=1}^{D_{b_\dw}}
    a_{i_\up b_\up i_\dw b_\dw} a^*_{j_\up b_\up j_\dw b_\dw}
    C_{b_\up,i_\dw}C_{b_\up,j_\dw}\right)}_{
    \rho^\mathrm{imp}_{i_\up i_\dw j_\dw j_\up}}
    \ket{i_\up\, i_\dw}\bra{j_\dw \, j_\up}
  \end{equation}
where the term 
$C_{b_\up,i_\dw}C_{b_\up,j_\dw}$ accounts for the fermionic 
sign associated with the bath-impurity bitset exchange.

  
In numerical implementations, this approach introduces a few 
key differences with respect to the {\bf normal} mode.
In particular, the 
ordering of the \emph{key-value} pairs in the {\tt sparse\_map} 
must reflect the contiguous bitset structure, which is critical 
for correctly reconstructing the Fock state indices.
See the following listing:
\begin{lstlisting}[style=fstyle,numbers=none,basicstyle={\scriptsize\ttfamily}]
do IimpUp=0,2**Norb-1
  do IimpDw=0,2**Norb-1
    do JimpUp=0,2**Norb-1
      do JimpDw=0,2**Norb-1
        !Build indices of the RDM in 1:4**Norb
        iImp = iImpUp + iImpDw*2**Norb
        jImp = jImpUp + jImpDw*2**Norb
        call sp_return_intersection(sectorI%H(1)%sp,iImp,jImp,Bath,lenBath)
        if(lenBATH==0)cycle
        do ib=1,lenBath
          iBath = Bath(ib)
          !Decompose iBath into B_Up, B_dw to reconstruct B bitset. 
          !B --> {B_up,B_dw}
          iBathUp = mod(iBath,2**Nbath)
          iBathDw = (iBath)/2**Nbath
          !Reconstruct the Fock state Ii map back to sector state i
          ii= iImpUp + iImpDw*2**Ns + 2**Norb*(IBathUp + IBathDw*2**Ns)
          i = binary_search(sectorI%H(1)%map,ii)
          !Reconstruct the Fock state Jj map back to sector state j
          jj= jImpUp + jImpDw*2**Ns + 2**Norb*(IBathUp + IBathDw*2**Ns)
          j = binary_search(sectorI%H(1)%map,jj)
          !Build the signs of each components of RDM(io,jo)
          nBup  = popcnt(Ibits(ii,Norb,Norb*Nbath))
          nIdw  = popcnt(Ibits(ii,Ns,Norb))
          nJdw  = popcnt(Ibits(jj,Ns,Norb))
          signI = (-1)**(nIdw*nBup)
          signJ = (-1)**(nJdw*nBup)
          sgn   = signI*signJ
          !  
          io = (iImpUp+1) + 2**Norb*iImpDw
          jo = (jImpUp+1) + 2**Norb*jImpDw
          rdm(io,jo) = rdm(io,jo) + psi(i)*conjg(psi(j))*weight*sgn
        enddo
      enddo
    enddo
  enddo
enddo
\end{lstlisting}


\subsection{Bath Functions}\label{sSecFunc}
The module {\tt ED\_BATH\_FUNCTIONS} implements the on-the-fly 
calculation of the hybridization function 
$\Delta_{\a\b\s\s'}(z)$ and the non-interacting Green's functions 
$G^0_{\a\b\s\s'}(z)$ for arbitrary complex frequencies $z \in \CCC$. 
These are defined as
\begin{equation}
\Delta_{\a\b\s\s'}(z) = \sum_p V^p_{\a\s} 
\left( z\11 - h^p_{\a\b\s\s'} \right)^{-1} V^p_{\b\s'},
\end{equation}
\begin{equation}
G^0_{\a\b\s\s'}(z) = 
\left[ (z + \mu)\delta_{\a\b\s\s'} - h^0_{\a\b\s\s'} - 
\Delta_{\a\b\s\s'}(z) \right]^{-1},
\end{equation}
where $V^p_{\a\s}$ and $h^p_{\a\b\s\s'}$ are the bath coupling 
and bath Hamiltonian matrices, respectively, and $\mu$ is the chemical 
potential.

The module supports all cases defined by the {\tt ed\_mode} and 
{\tt bath\_type} variables, including both user-supplied baths (provided 
as rank-1 arrays of doubles) and the internally allocated {\tt 
effective\_bath} instance {\tt dmft\_bath}. This flexibility ensures 
compatibility with a wide range of other solvers.

Different routines are available for directly evaluating $\Delta$, 
$G^0$, and its inverse $[G^0]^{-1}$, which are critical for computing 
the self-energy functions on demand (see \secu{sSecIO}). 

In the superconducting case, where {\tt ed\_mode}={\bf superc}, 
special care is needed to properly handle the anomalous (off-diagonal) 
components within the Nambu basis. In this case, the bath functions 
must include both the normal and anomalous components, 
which can significantly alter the form of the self-energy. Similar issues arise in the {\bf nonsu2} case, where spin off-diagonal components usually drive the physics of the problem.




\subsection{Bath Optimization}\label{sSecFit}
In the DMFT-ED framework, the bath parameters must be optimized to 
faithfully reproduce the Weiss field, 
${\GG^{-1}_{0}}_{\a\b\s\s'}(z)$, or its corresponding hybridization 
function 
\begin{equation}
\Theta(z) = (z + \mu)\11 - H^\mathrm{loc} - \GG_0^{-1}(z),
\end{equation}
where $\mu$ is the chemical potential and $H^\mathrm{loc}$ is the 
local non-interacting Hamiltonian. The Weiss field is obtained from the DMFT 
self-consistency equation~\cite{Georges1996RMP}, while the bath 
discretization requires a careful fitting of this continuous function 
using a finite set of bath parameters (see \secu{sSecBath}).

Several algorithms have been proposed for this optimization 
step~\cite{Garcia2004PRL,Taranto2012PRB,Mejuto_Bath_ASCI-DMFT}, each with strengths suited 
to different physical contexts. To maintain flexibility in \NAME, 
we keep the optimization part independent 
from the core impurity solver. However, we also include a fully 
integrated optimization routine based on the conjugate gradient (CG) 
minimization of the cost function:
\begin{equation}
\chi = \sum_{n=1}^{L_\mathrm{fit}} 
\frac{1}{W_n} \left\|X(i\omega_n) - 
X^\mathrm{QIM}(i\omega_n; \{V, h\}) \right\|_q,
\label{eq:chiq}
\end{equation}
where the $q$-norm is a suitably chosen distance metric in the 
matrix function space. Here, $X_{\a\b} = {\GG_{0}}_{\a\b\s\s'}$ or 
$\Theta_{\a\b\s\s'}$ are the user-supplied local functions, while 
$X_{\a\b}^\mathrm{QIM} = G^0_{\a\b\s\s'}$ or 
$\Delta_{\a\b\s\s'}$ are the corresponding quantities for the quantum 
impurity model, see \secu{sSecFunc}.

While more sophisticated optimization methods have been developed for 
truncated algorithms like sCI\cite{Mejuto_Bath_ASCI-DMFT} or DMRG\cite{boh}, 
which handle systems with a 
larger number of bath levels, the CG minimization approach has proven 
both efficient and flexible for the small to moderate bath sizes 
typical in ED solvers. 

The entire fit procedure is encapsulated in the function 
\texttt{ed\_chi2\_fitgf} provided by the module 
\texttt{ED\_BATH\_FIT}. To exploit the regularity of the bath functions, 
the fit is performed on the Matsubara frequency axis, where the functions 
are smooth and rapidly decaying. The form of $X_{\a\b\s\s'}$ is controlled 
by the input parameter \texttt{cg\_Scheme=Weiss,Delta}.

To provide maximum control over the fitting process, we include several 
tunable parameters:
\begin{itemize}
\item \texttt{cg\_method=0,1} - Chooses the CG algorithm: 
\texttt{0} for a Fletcher-Reeves-Polak-Ribiere variant adapted from 
Numerical Recipes~\cite{NumRec77}, and \texttt{1} for the original 
algorithm described in Ref. \cite{Georges1996RMP}, commonly used 
in the DMFT community.
\item \texttt{cg\_grad=0,1} - Sets the gradient calculation method: 
\texttt{0} for analytical gradients (when available), \texttt{1} for 
numerical gradients (required if \texttt{cg\_method=1}).
\item \texttt{cg\_Lfit} - Sets the number of Matsubara frequencies 
$L_\mathrm{fit}$ used in the fit. This can be used to restrict the 
fit to the low-frequency regime, where the function behavior is 
most relevant.
\item \texttt{cg\_Weight=0,1,2} - Determines the frequency weighting 
scheme: \texttt{0} for uniform, \texttt{1} for inverse frequency 
weighting, and \texttt{2} for inverse Matsubara index weighting, which 
can emphasize low-energy contributions.
\item \texttt{cg\_pow} - Sets the power $q$ of the cost function, 
allowing the user to fine-tune the sensitivity of the optimization 
to outliers.
\item \texttt{cg\_norm=elemental,frobenius} - Sets the matrix norm to be used to define the cost function in \equ{eq:chiq}. The default value (\texttt{elemental}) corresponds to a generic element-wise $\chi^q$ norm, defined as 
\begin{equation*}
    ||X-X^\mathrm{QIM}||_q \equiv {\sum_{ij} \left|X_{ij}-X^\mathrm{QIM}_{ij}\right|^q}.
\end{equation*}
The \texttt{frobenius} option implements instead the matrix distance induced by the Frobenius inner product as
\begin{equation*}
    ||X-X^\mathrm{QIM}||_q \equiv 
    \sqrt[q]{\Tr\left[(X-X^\mathrm{QIM})^\dagger(X-X^\mathrm{QIM})\right]} =
    \left(\sum_{ij} \left|X_{ij}-X^\mathrm{QIM}_{ij}\right|^2 \right)^{\!\!\!\frac{1}{q}}.
\end{equation*}
For $q=2$ (see \texttt{cg\_pow}) the Frobenius norm is equivalent
to the Euclidean distance in matrix space. 
%For $q\neq2$ we are implementing something that is not a matrix norm (better to not comment on it explicitly)
We prospect to expand the choices for \texttt{cg\_norm} in future updates of \NAME, as the \textbf{nonsu2} and \textbf{superc}
diagonalization modes entail nontrivial subtleties in optimizing 
the off-diagonal components of $X$.
\item \texttt{cg\_Ftol} - Controls the fit tolerance, setting the 
convergence threshold for the CG minimization.
\item \texttt{cg\_Niter} - Specifies the maximum number of allowed 
iterations for the CG minimization.
\item \texttt{cg\_stop=0,1,2} - Defines the exit condition of the 
minimization corresponding, respectively, to the options  $C_1+C_2$, $C_1$ and $C_2$, with:
\begin{align*}
C_1 & = |\chi^{n-1} - \chi^n| < \mathtt{cg\_Ftol} (1+\chi^n), \\
C_2 & = \left\|x_{n-1} - x_n\right\| < 
\mathtt{cg\_Ftol} (1+\left\|x_n\right\|),
\end{align*}
where $\chi^n$ is the cost function at the $n^\mathrm{th}$ step, and 
$x_n$ the corresponding parameter vector. The stop condition is a 
logical OR between these criteria, with the parameter value selecting 
which condition to apply.
\end{itemize}

Together, these parameters provide precise control over the fitting 
process, allowing users to balance speed and accuracy according to 
their specific needs.



\subsection{Input/Output}\label{sSecIO}
The \texttt{ED\_IO} module provides comprehensive access to the 
results of the Lanczos diagonalization of the quantum impurity 
problem. Since each instance of the code persists in memory until a 
new calculation is initiated, access to the relevant data is managed 
through a set of dedicated functions. These include routines for 
extracting dynamical response functions, self-energy components, and 
impurity observables, as well as for performing on-the-fly 
recalculation of the impurity Green's functions and self-energies at 
arbitrary points in the complex frequency domain. The latter 
capability is enabled through the efficient use of \texttt{gfmatrix} 
objects for data storage.

A full list of available functions, including parameter descriptions 
and usage examples, can be found in the online documentation 
Here, we highlight two representative examples:
The first is the function \texttt{ed\_get\_dens}, which populates the 
provided input array with the orbital impurity occupations 
$\langle n_{\a\s}\rangle$. This function is essential for extracting 
local density information, a key diagnostic in many DMFT studies.

The second example is \texttt{ed\_get\_sigma}, which retrieves the 
normal or anomalous components of the Matsubara or real-axis 
self-energy function $\Sigma(z)$. This function represents a central 
output of any DMFT calculation, as the self-energy encapsulates the 
full set of local electronic correlations and their frequency 
dependence.







\subsection{EDIpack2ineq: inequivalent impurities}\label{sSecIneq}
In many contexts, it is necessary to solve systems with multiple, 
independent quantum impurities. This situation frequently arises in 
DMFT when modeling lattices with complex unit cells containing 
inequivalent atomic sites, or in supercell calculations where 
translational symmetry is broken, as in heterostructures, disordered 
systems, or multiorbital setups. 

Given that \NAME allows only a single instance of the solver at a 
time, a dedicated extension is required to handle these more complex 
cases. To address this, we developed the {\tt EDIpack2ineq} 
sub-library, which extends the base functionality of \NAME by managing 
memory and procedures for multiple impurities. This approach ensures 
that all functions remain accessible through standard Fortran 
interfaces, seamlessly integrating both \NAME and {\tt EDIpack2ineq} 
without compromising overall software design.

Below, we provide a brief overview of the main features introduced by 
{\tt EDIpack2ineq}.

\subsubsection{Structure}\label{ssSecIneqStructure}
The core of the {\tt EDIpack2ineq} sub-library consists of several 
Fortran modules, all wrapped under the main interface module 
{\tt EDIPACK2INEQ}. This module provides access to the full range of 
procedures and variables required to solve inequivalent quantum 
impurity problems. To use this extension, the user must include both 
the main \NAME and the {\tt EDIpack2ineq} modules, as shown below:
\begin{lstlisting}[style=fstyle,numbers=none,basicstyle={\scriptsize\ttfamily}]
program test
  !Load EDIpack library 
  USE EDIPACK
  !Load the Inequivalent impurities extension
  USE EDIPACK2INEQ
  ...
\end{lstlisting}

A significant part of the {\tt EDIpack2ineq} extension is the 
definition of global variables that extend the memory pool of 
\NAME. This includes higher-rank arrays for storing impurity-specific 
data, ensuring that each impurity's state is maintained separately 
during the computation. While dedicated MPI communication could be 
used to manage specific objects in parallel, e.g. {\tt
  effective\_bath} or {\tt gfmatrix}, we opted for a simpler and safer  
file-based approach to maintain compatibility with the standard I/O 
procedures described in \secu{sSecIO}.


\subsubsection{Core routines}\label{ssSecIneqGlobal}
The module {\tt E2I\_MAIN} wraps the key extensions to the main 
algorithms of \NAME, including initialization, diagonalization, and 
finalization, while preserving the original function names for consistency: 

\paragraph{{\tt ed\_init}.} {\bf Initialization} of the solver. This function  extends the corresponding one in \NAME  to 
  accept a rank-2 bath array, where the leading dimension specifies 
  the number of inequivalent impurity problems. This ensures each bath 
  is properly initialized for subsequent diagonalization.

\paragraph{{\tt ed\_solve}.} {\bf Diagonalization} of the inequivalent quantum impurity problems. This function is extended to  accept a  
  rank-2 bath array and to manage the diagonalization of each impurity 
  problem. Parallel execution is controlled by the input flag 
  {\tt mpi\_lanc=T/F}, which determines whether the Lanczos 
  diagonalization is performed in parallel or sequentially across 
  different impurities.

\paragraph{{\tt ed\_finalize}.} {\bf Finalization} of the solver. This handles the global memory release extending the corresponding  function in \NAME, which clears the memory pool for all inequivalent impurity instances.

  


\subsubsection{Inequivalent Baths}\label{ssSecIneqBath}
The bath setup for multiple impurities is managed by the 
{\tt E2I\_BATH} module, which provides functions for defining 
site-specific bath matrices and their corresponding variational 
parameters. This includes support for conventional symmetry operations 
and the handling of replica bath structures. 

In the module {\tt E2I\_BATH\_REPLICA}, we extend the 
matrix basis definition for the variational parameters 
$\vec{\lambda}$, allowing for flexible bath optimization across 
multiple sites. Although the matrix basis is currently shared among 
all impurities, future versions may allow for fully independent 
bath parameterizations.

Additionally, the {\tt E2I\_BATH\_FIT} module extends the generic 
{\tt ed\_chi2\_fitgf} function to support simultaneous, independent 
bath optimization for all impurities using MPI, thereby improving the 
efficiency of large-scale calculations.


 
\subsubsection{Input/Output}\label{ssSecIneqIO}
A key component of the {\tt EDIpack2ineq} extension is the 
enhanced I/O capability for handling impurity-specific observables. 
The {\tt E2I\_IO} module includes a variety of functions for 
retrieving site-resolved quantities, such as local Green's functions, 
self-energies, and density matrices. These functions use the same 
naming conventions as the core \NAME library, ensuring a consistent 
user experience across single and multi-impurity calculations.

\end{document}
