\documentclass[edipack2.tex]{subfiles}
\begin{document}

\section{Implementation}\label{SecEDIpack}
In this section we introduce the generic quantum impurity system and
present a detailed overview of the \NAME library implementation. 













\subsection{The quantum impurity problem}\label{sSecQIM}
We consider a general quantum impurity problem described by the Hamiltonian:
$$
\hat{H} = \hat{H}_\mathrm{imp} + \hat{H}_\mathrm{bath} + \hat{H}_\mathrm{hyb} + \hat{H}_\mathrm{ph} + \hat{H}_\mathrm{e-ph}
$$
which describes a multi-orbital quantum impurity
coupled to an electronic bath and local phonons (e.g., Holstein
modes). For now, we assume no specific symmetries.

\subsubsection{Impurity Hamiltonian}
The impurity Hamiltonian is split into a quadratic and an 
interacting part:
\begin{equation}\label{Himp}
  \hat{H}_\mathrm{imp}  = \hat{H}^0_\mathrm{imp} + \hat{H}^\mathrm{int}_\mathrm{imp}
\end{equation}
where
\begin{equation}\label{H0imp}
  \hat{H}^0_\mathrm{imp}  =
  \sum_{\a\b\sigma\sigma'}h^{0}_{\a\b\sigma\sigma'}d^{+}_{\a\sigma}d_{\b\sigma'}\\
\end{equation}
represents the quadratic part, with $d_{\a\sigma}$ ($d^+_{\a\sigma}$) are the annihilation (creation)
operators for impurity electrons in 
orbital $\alpha=1,\dots,N_\a$, with $N_\a$ the number of orbitals,
and spin $\sigma=\up,\dw$.  The occupation number operator is defined
as  $n_{\alpha\sigma}=d^{+}_{\alpha\sigma}d_{\alpha\sigma}$.
The internal structure of the non-interacting part is captured by the 
matrix $h^{0}_{\a\b\sigma\sigma'}$, which can include 
orbital-dependent on-site energies, spin-orbit coupling or other 
single-particle terms.


The interaction part of the impurity Hamiltonian, 
 $\hat{H}^{\mathrm{int}}$ can in principle contain any 
set of two-body operators of the form
$U_{ijkl}c^{\dagger}_{i}c^{\dagger}_{j}c_{l}c_{k}$.
However, we typically 
adopt a generic formulation of the local multi-orbital Hubbard-Kanamori interaction~\cite{Georges2013ACMP}:
\begin{equation}\label{Hint}
  \begin{split}
    \hat{H}^\mathrm{int}_\mathrm{imp} &=U\sum_{\a}n_{\a\uparrow}n_{\a\downarrow}+U'\sum_{\a\neq \b}n_{\a\uparrow}n_{\b\downarrow}+(U'-J)\sum_{\a<\b,\sigma}n_{\a\sigma}n_{\b\sigma}\\
    &{\phantom =}- J_X\sum_{\a\neq
      \b}d^{+}_{\a\uparrow}d_{\a\downarrow}d^{+}_{\b\downarrow}d_{\b\uparrow}+J_P\sum_{\a
      \neq
      \b}d^{+}_{\a\uparrow}d^{+}_{\a\downarrow}d_{\b\downarrow}d_{\b\uparrow}\\
\end{split}
\end{equation}
The first three terms represent the density-density part of the
interaction, where $U$ is the local intra-orbital Coulomb repulsion,
$U'$ the inter-orbital one and $J$ the Hund's coupling~\cite{Georges2013ACMP}.  
The final two terms are, respectively, the spin-exchange ($J_X$) and
the pair-hopping ($J_P$).
In the three-orbital case $N_\a=3$ a fully symmetric $SU(3)_\mathrm{orbital}\otimes SU(2)_\mathrm{spin}\otimes
U(1)_\mathrm{charge}$ form of the interaction is obtained by setting $U'=U-2J$ and
$J_X=J_P=J$~\cite{Georges2013ACMP}. Different choices, preserving part
of the combined symmetry group, can be made for other number of orbitals~\cite{Georges2013ACMP}. 

\subsubsection{Bath and Hybrization}
The coupling between the impurity and the bath is described by
\begin{equation}\label{Hbath}
  \begin{split}
    \hat{H}_\mathrm{bath} &=
    \sum_p\sum_{\a\b\sigma\sigma'}h^p_{\a\b\sigma\sigma'}a^{+}_{p\a\sigma}a_{p\b\sigma'}\\
    %
    \hat{H}_\mathrm{hyb} &= \sum_p\sum_{\a\b\sigma\sigma'}V^p_{\a\b\sigma\sigma'}d^{+}_{\a\sigma}a_{p\b\sigma'}+H.c. \\
\end{split}
\end{equation}
where $p=1,\dots,N_\mathrm{bath}$ indexes the
bath elements. The operators $a_{p\alpha\sigma}$
($a^+_{p\alpha\sigma}$) correspond to the destruction (creation) of
bath electrons with index $p$, orbital $\alpha$ and spin $\sigma$.
Any bath element can be composed of several electronic levels
according the chosen bath topology. The  properties of each bath level are described by the
matrix $h^p_{\a\b\sigma\sigma'}$ and couples to the impurity through an amplitude
$V^p_{\a\b\s\sigma'}$.   


\subsubsection{Electron-Phonon coupling}
Finally, the electron-phonon part of the quantum impurity problems is
described by the Hamiltonian terms: 
\begin{equation}\label{Hph}
  \begin{split}
    \hat{H}_\mathrm{ph}&=\sum_q \omega_{0q} b_q^+b_q\\
    % 
    \hat{H}_\mathrm{e-ph} &= \sum_q\sum_{\a\b\sigma} g_{\a\b} d^+_{\a\sigma}d_{\b\sigma}(b_q+b_q^+)
\end{split}
\end{equation}
where $q=1,\dots,N_q$ indexes the number of local phonons, and $b_q$
($b_q^+$) are the destruction (creation) operators for a phonon with
frequency $\omega_{0q}$.
The matrix  $g_{\a\b}$ describe the electron-phonon coupling. 
Although feasible, dealing with more than one phonon mode becomes
quickly computationally very demanding, thus in the rest of the this
work we shall consider $N_q=1$. 

\subsubsection{System setup}
We consider a bath discretized into a  number
of bath degrees of freedom and a finite number of available phonons $N_\mathrm{ph}$,
to cut-off the unbounded dimensions of the local phonons Hilbert
space.
In the rest of this work we consider a system composed of $N_\mathrm{imp}=1$
impurities, i.e. a single impurity problem, $N_\mathrm{bath}$ bath elements
and $N_\mathrm{ph}$ phonons.
The total size of the system is determined by the (fixed)
number of phonons (fixed) $N_\mathrm{ph}$, the number of impurity orbitals 
$N_\a$ and that of the bath levels  $N_\mathrm{b}$. The latter is a
function of  the bath topology and $N_\mathrm{bath}$.
In the simplest case each bath
element corresponds to an independent electronic level coupled to the
impurity, thus $N_\mathrm{b}\equiv N_\mathrm{bath}$.
The total count of electronic levels is  $N_\mathrm{s}=N_\a +
N_\mathrm{b}$. 


The setup of the quantum impurity problem is implemented in {\tt
  ED\_SETUP} through the input variables {\tt Nspin}$=N_\sigma$,
{\tt Norb}$=N_\a$ and {\tt Nbath}$=N_\mathrm{bath}$ globally defined {\tt
  ED\_INPUT\_VARS}. The {\tt Ns}$=N_\mathrm{s}$ variable, evaluated in
{\tt ed\_setup\_dimensions}, corresponds to the total number of
electronic levels. 
The local non-interacting Hamiltonian
$h^0_{\a\b\s\s'}$ is specified using the function {\tt ed\_set\_hloc} in {\tt ED\_AUX\_FUNX}.
The setup of the bath matrices $h^p_{\a\b\s\s'}$
requires a more involved procedure which will be illustrated in
\secu{sSecBath}. 



% \paragraph{{\bf Remark}} As extensively discussed in
% \onlinecite{Amaricci2022}, the inclusion of local phonons with
% truncated dimensions ultimately amounts to a sequential application of
% the procedures defined for the electronic part, i.e. one per phonon
% mode. This includes a linear scaling of the dimensions with $N_\mathrm{ph}$
% and of course largely limit the available degrees of freedom to
% describe electronic states. In the rest of the paper we focus
% specifically on the electronic part of the quantum impurity problem,
% referring to the phonons in specific sections when their presence
% introduces non-trivial modifications.  


















\subsection{The Fock basis states}\label{sSecBasis}
The Fock space of the quantum impurity problem is defined as
$\FF=\FF_\mathrm{e}\otimes \FF_\mathrm{ph}$, where $\FF_\mathrm{e}=\bigoplus_{n=0}^{N_\mathrm{s}}
S_-\HH_\mathrm{e}^{\otimes n}$ is the electronic Fock space built 
from the local electronic Hilbert space $\HH_\mathrm{e}$, and 
$\FF_\mathrm{ph}=\bigoplus_{n=0}^{N_q}S_+\HH_\mathrm{ph}^{\otimes n}$
is the
phonon Fock space, with local phonon Hilbert space
$\HH_\mathrm{ph}=\{\ket{0},\ket{1},\dots,\ket{N_\mathrm{ph}}\}$. 
Here ($S_-$) $S_+$ is the (anti-)symmetrization operator.  

The total dimension of the Fock space is
$D=4^{N_\mathrm{s}}\cdot (N_\mathrm{ph}+1)=D_\mathrm{e}\cdot
D_\mathrm{ph}$, highlighting the exponential
growth with the number of electronic levels. 

The quantum states in the space $\FF$ are naturally represented in
the occupation number formalism of second quantization,
i.e., the Fock basis.
For a system of $N_\mathrm{s}$ electrons, each Fock state
is given as $\ket{p}\ket{\vec{n}}$, with
\begin{equation} \label{eq:FockState_|nupndw>}
    \ket{\vec{n}}=\ket{n_{1\up},\dots,n_{N_\mathrm{s}\up},n_{1\dw},\dots,n_{N_\mathrm{s}\dw}},
\end{equation}
where $p=1,\dots,N_\mathrm{ph}$ is the number of local phonons and
$n_{a\sigma}=0,1$ indicates the absence or 
presence of an electron with spin $\sigma$ at level $a$.

The electronic part of the Fock state $\ket{\vec{n}}$ is represented
as a binary string of length $2N_\mathrm{s}$. Thus, any such state can be encoded
in a computer using a sequence of $2N_\mathrm{s}$ bits, or equivalently, as an integer $I=0,\dots 2^{2N_\mathrm{s}}-1$ such that $\ket{\vec{n}}=\ket{I}$.  

Destruction and creation operators, $c_{a\sigma}$ and $c^+_{a\sigma}$ 
respectively, act on the Fock space as:
\begin{align*}
  c_{a\sigma}\ket{\vec{n}} &=
    \begin{cases}
      (-1)^{\#_{a\sigma}}\ket{\dots,n_{a\sigma}\!-\!1,\dots}
      &\text{if $n_{a\sigma}\!=\! 1$}\\
      0 &\text{otherwise}
    \end{cases};\qquad
    c^{+}_{a\sigma}\ket{\vec{n}} &=
     \begin{cases}
      (-1)^{\#_{a\sigma}}\ket{\dots,n_{a\sigma}\!+\!1,\dots}
      & \text{if $n_{a\sigma}\!=\! 0$}\\
      0 & \text{otherwise}
    \end{cases}    
\end{align*}
where $\#_{a\sigma}=\sum_{b\sigma'<a\sigma} n_{b\sigma'}$ accounts for the fermionic sign imposed by the Pauli principle.


The implementation of Fock states and operators can be found in 
{\tt ED\_AUX\_FUNX}. In particular, in this module we define the bitwise action 
of fermionic creation and annihilation operators as functions 
{\tt CDG} and {\tt C}, used throughout the code. Additionally, 
we provide the function {\tt bdecomp} for reconstructing the Fock 
state bit sequence from the integer representation.



















\subsection{Conserved quantum numbers}\label{sSecQNs}
To mitigate the exponential scaling of the Fock space dimension, it 
is essential to exploit suitable symmetries. Specifically, if the 
Hamiltonian $H$ commutes with a set of operators ${\cal Q}$ such that 
$[H, {\cal Q}] = 0$, the Fock space can be decomposed into smaller, 
disjoint symmetry sectors labeled by quantum numbers $\vec{Q}$.

In the context of quantum impurity problems, two commonly used 
symmetries are: i) conservation of the total charge $N$ and ii) 
conservation of the total magnetization $S_z$. Although the total 
spin operator $S^2$ may also be conserved, its implementation is 
computationally challenging and typically provides only marginal 
gains, making it less practical in many cases.

In \NAME, three different symmetry configurations are available, 
controlled by the input variable {\tt ed\_mode} = {\bf normal}, 
{\bf superc}, or {\bf nonsu2}:


 - The {\bf normal} case conserves both the total occupation $N$
and the total magnetization $S_z$, or equivalently, the total number
of electrons with spin up $N_\up$ and down $N_\dw$.
Optionally, the symmetry
can be extended to act indipendently to each orbital and spin
component, i.e., $\vec{N_\s}=[N^1_\s,\dots,N^{N_\a}_\s]$. This
specific case is discussed extensively
Ref.~[\onlinecite{Amaricci2022}] and will not be further covered here.

%

- The {\bf superc} case maintains onlu the $S_z$ conservation,
allowing the total charge to not be conserved. This setting captures
system with $s$-wave superconductivity, including 
intra- and inter-orbital pairing.

- The {\bf nonsu2} case conserves the total
charge $N$ while allowing spin symmetry group to be not conserved.
This scenario catpures effects such as local spin-orbit coupling
$\vec{L}\cdot\vec{S}$~\cite{something}, in-plane spin ordering~\cite{BellomiaKMH} or
in-plane spin-triplet exciton condensation~\cite{Amaricci2023_excitons,Blason}.  


From a computational perspective, constructing a symmetry
sector amounts to defining a injective map
$\MM:\SS_{\vec{Q}}\rightarrow \FF$ which relates the states $\ket{i}$
within a given symmetry sector $\SS_{\vec{Q}}$ to the states $\ket{I}$ in the
full Fock space.
This map is typically implemented as a rank-1
integer array, whose size corresponds to the dimension of the sector. 


The {\bf normal} case deserves a special note. Since $N_\up$ and
$N_\dw$ are conserved independently, the local Hilbert
space and the electronic Fock space can be factorized as
$\HH_e=\HH_{e\up}\otimes\HH_{e\dw}$ and $\FF_\mathrm{e} = \FF_{e\up}\otimes \FF_{e\dw}$, respectively.  
Consequently, each Fock state can be written as a product
$\ket{\vec{n}_\up} \ket{\vec{n}_\dw}$. This factorization splits the
symmetry sector as $\SS_{\vec{Q}} = \SS_{N_\up}\otimes\SS_{N_\dw}$,
and finally the sector map can be expressed as the product $\MM = \MM_\up
\otimes \MM_\dw$.

Each state $\ket{i}=\ket{i_\up} \ket{i_\dw}$ in this factorized basis
is labeled by two integers $[i_\up,i_\dw]$, with 
$i_\sigma=1,\dots,D_{\SS_\sigma}$ such that $i=i_\up + i_\dw
D_{\SS_\dw}$.
The maps $\MM_\sigma$ then connect these basis states to Fock states
$\ket{I}=\ket{I_\up}\ket{I_\dw}$, labeled by two integers
$[I_\up,I_\dw]$ as $I=I_\up +   I_\dw 2^{N_\mathrm{s}}$.
For a more
detailed discussion on the structure of the Fock basis in this case, see Ref.~[\onlinecite{Amaricci2022}]. 

The presence of a symmetry reduces the Hamiltonian matrix to
a block diagonal form, where each block, labeled by $\vec{Q}$, has dimension
$D_{\SS(\vec{Q})}$. The sector Hamiltonian matrix $H_\SS$ is represented in the
basis $\ket{i}\in\SS_{\vec{Q}}$ as a sparse matrix.
In the {\bf normal} case this block structure is particularly
symmetric due to the factorized nature of the sectors as discussed
above, see also Ref.~[\onlinecite{Amaricci2022}].
The analysis of the spectrum is then reduced toinspecting the
Hamiltonian within each symmetry sector, or to a subset thereof if a
additional constraints are present.
A summary of the sector properties is provided in
Table~(\ref{TabSector}). 
\begin{table}%[ht]
  \label{TabSector}
\begin{center}
\begin{tabularx}{\linewidth}{ |X|X|X| } 
 \hline
  {\tt ed\_mode} & {\it Quantum Numbers} & {\it Sector Dimension} \\
  \hline
  {\bf normal} & $[N,S_z]\equiv[N_\up,N_\dw]$ &
                                                $\binom{N_\mathrm{s}}{N_\up}\binom{N_\mathrm{s}}{N_\dw}$
  \\
  \hline
  {\bf superc} & $S_z\equiv N_\up-N_\dw$ &  $\sum_m 2^{N_\mathrm{s}-S_z-2m}\binom{N_\mathrm{s}}{N_\mathrm{s}-S_z-2m}\binom{S_z+2m}{m}$
  \\
  \hline
  {\bf nonsu2} & $N \equiv N_\up+N_\dw$ & $\binom{2N_\mathrm{s}}{N}$ \\ 
 \hline
\end{tabularx}
\end{center}
\caption{
  {\bf Quantum Numbers Table}.
A table summarizing the possible values of the input variable {\tt
  ed\_mode} selecting the symmetries of the problem. To each value
(first column) correspond different quantum numbers (second column).
The third column report the dimension of the symmetry sector for a
given realization of the quantum numbers.}
\end{table}

% Although the sectors have dimensions much smaller than the full Fock
% space, for large systems storing the Hamiltonian matrix in the memory
% can still be highly inefficient. In such cases, any Krylov  subspace  
% method~\cite{Lanczos1950JRNBSB,Lin1993CIP,Lehoucq1998,Maschhoff1996}
% can be implemented using a storage-free algorithm, performing the
% necessary linear operations on-the-fly.
% This solution has generally a negative impact on the execution
% time, however this can be well compensated by scaling in a distributed 
% parallel framework.

In \NAME the implementation of symmetry sectors is managed through the
{\tt sector} object, which is defined in {\tt
  ED\_VARS\_GLOBAL}. This object contains all the revelant
informations for defining the symmetry, inclduing the sector
dimensions, quantum numbers and the map $\MM$. The constructor
(destructor) for this object is defined in the {\tt
  ED\_SECTORS} module via the functions {\tt build\_sector}
(constructor) and {\tt
  delete\_sector} (destructor).
These functions use different algorithms depending on the nature 
of the quantum numbers $\vec{Q}$. The following  code
snippet summarize the various available implementations:
\setbox0=\hbox{%
  \begin{minipage}{0.3\linewidth}
    \center{\bf normal}
\begin{lstlisting}[style=fstyle,frame=none,numbers=none,basicstyle={\scriptsize\ttfamily}]
i=0
do Iup=0,2**Nbit-1     
  nup_ = popcnt(Iup) 
  if(nup_ /= Nups(1))cycle
  i = i+1
  H(iud)%map(i) = lup
enddo
i=0
do Idw=0,2**Nbit-1
  ndw_= popcnt(Idw)
  if(ndw_ /= Ndws(1))cycle
  i = i+1
  H(iud+Ns)%map(i) = Idw
enddo
\end{lstlisting}
\end{minipage}
}
\savestack{\listingA}{\box0}

\setbox0=\hbox{%
  \begin{minipage}{0.3\linewidth}
    \center{\bf superc}
\begin{lstlisting}[style=fstyle,frame=none,numbers=none,basicstyle={\scriptsize\ttfamily}]
i=0
do Idw=0,2**Ns-1
  ndw_= popcnt(idw)
  do Iup=0,2**Ns-1
    nup_ = popcnt(iup)
    sz_  = nup_ - ndw_
    if(sz_ /= self%Sz)cycle
    i=i+1
    self%H(1)%map(i) = &
        Iup+Idw*2**N
  enddo
enddo

\end{lstlisting}
\end{minipage}
}
\savestack{\listingB}{\box0}

\setbox0=\hbox{%
  \begin{minipage}{0.3\linewidth}
    \center{\bf nonsu2}
\begin{lstlisting}[style=fstyle,frame=none,numbers=none,basicstyle={\scriptsize\ttfamily}]
i=0
do Idw=0,2**Ns-1
  ndw_= popcnt(Idw)
  do Iup=0,2**Ns-1
    nup_ = popcnt(Iup)
    nt_  = nup_ + ndw_
    if(nt_ /= self%Ntot)cycle
    i=i+1
    self%H(1)%map(i) = &
        Iup+Idw*2**Ns
  enddo
enddo
\end{lstlisting}
\end{minipage}
}
\savestack{\listingC}{\box0}

\begin{tabular}{c|c|c}\label{list1}
  \stackinset{l}{}{t}{}{}{\listingA} &
\stackinset{l}{}{t}{}{}{\listingB} &
\stackinset{l}{}{t}{}{}{\listingC} \\
\end{tabular}


In addition to the basic construction and destruction routines, the
{\tt ED\_SECTORS} module also includes functions to
retrieve sector indices and quantum number
informations. Furthermore, it provdes a set of
essential functions for applying arbitrary linear combinations
of operators to a given Fock state $\ket{v}\in\SS$, i.e.
$\OO\ket{v} = \sum_i a_i C^{p_i\dagger}_{\a_i,\s_i}\ket{v}$ with
$a_i\in\CCC$ and $p_i=0,1$. This functionality is implemented through
the functions {\tt apply\_op\_C}, {\tt apply\_op\_CDG}, {\tt
apply\_Cops}, which  are widely used throughout the code. 





















\subsection{Interaction setup}
The \NAME code offers two distinct methods to setup the interaction terms $\hat{H}^\mathrm{int}$ in \equ{Himp}. 
The generalized Hubbard-Kanamori interaction, as defined in \equ{Hint}, is natively
supported and controlled by the input parameters {\tt ULOC}$=U$, {\tt
  UST}$=U^{'}$, {\tt JH}$=J$, {\tt JX}$=J_{x}$ and {\tt JP}$=J_{p}$.
These quantities can be specified either in the input file or directly
via the the command line, provided the logical input parameter {\tt
  ED\_USE\_KANAMORI} is set to {\tt T}. In this mode, the maximum
number of impurity orbitals {\tt NORB}$=N_\a$ is limited to $5$.

Alternatively, a list of two-body operators can be provided by the user in a properly
formatted text file, whose name is specified by the input variable {\tt
  UMATRIX\_FILE}. The implementation of the list of interaction terms is contained in
the class {\tt ED\_PARSE\_UMATRIX}.  
The file mush have the suffix {\tt \\.restart} and should be formatted
as follows: 
\begin{lstlisting}[style=mybash]
NORB BANDS
i1 j1 k1 l1 U_i1j1k1l1
i2 j2 k2 l2 U_i2j2k2l2
...
\end{lstlisting}
where {\tt NORB} is the numer of orbitals $N_\a$ and each line
defines a single two-body term of the form 
$U_{ijkl}c^{\dagger}_{i}c^{\dagger}_{j}c_{l}c_{k}$. Note tha the
coefficient indices are swapped compared to the standard two-body
operator formulation.  
Empty lines and lines starting with {\tt \#, \%, !} are ignored.

To enable the reading an interaction matrix file, the flag {\tt
  ED\_READ\_UMATRIX} must be set to {\tt T}.
Note that {\tt ED\_READ\_UMATRIX} and {\tt ED\_USE\_KANAMORI},
are mutually exclusive but can both be set to {\tt F}. 
In this case, the user must 
provide the interaction terms to the solver through the function 
{\tt add\_twobody\_operator} in the calling program or script, before 
the impurity problem is solved.

For reference and future use, the interaction operators used in each 
call to the solver are saved in the output file 
{\tt UMATRIX\_FILE.used}.

















\subsection{Classes}
The use of objects and classes greatly simplifies the implementation 
of critical mathematical concepts required for solving quantum 
impurity problems. This section provides an overview of the main 
classes used in \NAME, focusing on their structure and functionality.


\subsubsection{Sparse matrix}\label{CodeSparseMatrix}
Sparse matrix storage is handled through a dedicated class in the 
{\tt SPARSE\_MATRIX} module. This module defines the 
{\tt sparse\_matrix\_csr} object, which stores sparse matrices as 
hash tables. Each key corresponds to a row index, while the associated 
value contains a pair of dynamic arrays: one for the non-zero matrix 
elements and one for their respective column indices.

Each instance of {\tt sparse\_matrix\_csr} can be stored in either 
a serial manner (one copy per process) or distributed across multiple 
processes, with rows dynamically assigned to each process. 
Matrix elements are inserted using the 
{\tt sp\_insert\_element} procedure, which leverages the Fortran 
intrinsic {\tt move\_alloc} for faster execution compared to 
implicit reallocation, i.e., {\tt vec=[vec,new\_element]}. 

This approach offers several key advantages, including efficient 
memory management for matrices with unknown numbers of non-zero 
elements per row, and $O(1)$ element access time, both of which 
are critical for the efficient implementation of Krylov subspace 
methods.


%GBtodo placeholder: I passed on this already (except I don't like the
%minipage of the listings)

\subsubsection{Sparse map}\label{CodeSparseMap}
\fixme{GB: I don't like the minipage of the listing below.}
As discussed in \secu{sSecRDM}, the construction of a symmetry 
sector often requires associating each sector state $\ket{i}$ with 
disjoint information about the corresponding Fock state $\ket{I}$. 
In this context, the Fock state can be decomposed into bit chunks, 
e.g., $\ket{\vec{n}} = \ket{\vec{i}_\up\,\vec{b}_\up\,
\vec{i}_\dw\,\vec{b}_\dw}$, reflecting a natural grouping into impurity 
and bath components and where we highlight the overall ordering in
spin-up and spin-down parts (see \equ{eq:FockState_|nupndw>}).

The {\tt ED\_SPARSE\_MAP} module provides an efficient hash-table 
implementation, {\tt sparse\_map} which is part part of the {\tt
  sector} object and stores the relation between these bit chunks. 
Specifically, for each impurity configuration 
$\vec{i}_\s$ (key), it maintains a list of compatible bath 
configurations $\vec{b}_\s$ (values) consistent with the conserved 
quantum numbers of the given sector (see \secu{sSecQNs}).
The {\tt sparse\_map} ${\cal P}$ objects are constructed upon call of the {\tt
  build\_sector} ({\tt sector} constructor) using different algorithms 
for each value of {\tt ed\_mode}.

In the {\bf normal} mode, the sector object contains two separate {\tt
  sparse\_maps} objects ${\cal P}_{\s=\up,\dw}$, reflecting the
factorization of the Fock and sector states into independent spin components: 
$\ket{J}=\ket{J_\up}\otimes\ket{J_\dw} \xleftarrow{\MM}
\ket{j_\up}\otimes\ket{j_\dw}=\ket{j}$.
The sparse maps are built as follows. 
For any spin state of the sector $\ket{J_\s}=\ket{{\vec{I}_{\s}\vec{B}_{\s}}}$,
the \emph{key} is determined by the integer $I_\s$ corresponding to the
impurity bitset $\vec{I}_\s$. The \emph{values} are given by any
integer $B_\s$ corresponding to any bath bitset
$\vec{B_\s}$ associated with $\vec{I}_\s$ by the sector symmetry constraint: $\#\vec{I}_\s + \#\vec{B}_\s = \mathtt{popcnt}(I_\s) + \mathtt{popcnt}(B_\s)= N_\s$.
Thus, any given \emph{key-value} combination 
reconstructs an integer $J_\s$ representing a Fock state in the
given spin sector according to the rule $J_s = I_\s +
2^{N_\mathrm{imp}}B_\s$, where $N_\mathrm{imp}$ is the number of impurity bits. 

In both {\bf superc} and {\bf nonsu2} modes a single sparse map is
used.
Here, each Fock state $\ket{J}$ is associated with four integers $I_\up, B_\up, I_\dw,
B_\dw$ representing the bit decomposition of the state. 
These integers satisfy the relationship
$$
J =I_\up +  B_\up2^{N_\mathrm{imp}} + (I_\dw +  B_\dw2^{N_\mathrm{imp}})2^{N_\mathrm{s}}
$$
where $N_\mathrm{imp}$ is the number of impurity bits and 
$N_\mathrm{s}$ is the total number of spin components.
To obtain a contiguous memory pattern we define the \emph{key} for the sparse
map as $I=I_\up + I_\dw2^{N_\mathrm{imp}}$ and the corresponding
\emph{values} as the integers $B=B_\up + B_\dw2^{N_\mathrm{b}}$.
Note that these relations can be easily inverted to obtain $I_{\sigma=\up,\dw}$ from
$I$ and $B_{\sigma=\up,\dw}$ from $B$ in order to reconstruct the Fock
state $\ket{J}$.
The four integers satisfy the symmetry constraints:   
$\mathtt{popcnt}(I_\up + B_\up2^{N_\mathrm{imp}}) + \mathtt{popcnt}(I_\dw + B_\dw2^{N_\mathrm{imp}}) = N$
for the \textbf{nonsu2} case and
$\mathtt{popcnt}(I_\up + B_\up2^{N_\mathrm{imp}}) - \mathtt{popcnt}(I_\dw + B_\dw2^{N_\mathrm{imp}}) = S_z$
for the \textbf{superc} case.
This structure ensures an efficient and compact representation 
of the many-body Hilbert space, facilitating rapid state lookup 
during the diagonalization process.

An overview of the implementation is reported in the following listing:
\setbox0=\hbox{%
  \begin{minipage}{0.465\linewidth}
    \center{\bf normal}
\begin{lstlisting}[style=fstyle,frame=none,numbers=none,basicstyle={\scriptsize\ttfamily}]
i=0
do Iup=0,2**Nbit-1     
  nup_ = popcnt(Iup) 
  if(nup_ /= Nups(1))cycle
  i=i+1 
  !...
  iImp  = ibits(iup,0,Norb)
  iBath = ibits(iup,Norb,Norb*Nbath)
  call sp_insert_state(self%H(1)%sp,iImp,iBath,i)
enddo
i=0
do Idw=0,2**Nbit-1
  ndw_= popcnt(Idw)
  if(ndw_ /= Ndws(1))cycle
  i=i+1 
  !...
  iIMP  = ibits(idw,0,Norb)
  iBATH = ibits(idw,Norb,Norb*Nbath)
  call sp_insert_state(self%H(2)%sp,iImp,iBath,dim) 
enddo
\end{lstlisting}
\end{minipage}
}
\savestack{\listingA}{\box0}

\setbox0=\hbox{%
  \begin{minipage}{0.505\linewidth}
    \center{\bf superc/nonsu2}
\begin{lstlisting}[style=fstyle,frame=none,numbers=none,basicstyle={\scriptsize\ttfamily}]
i=0
do Idw=0,2**Ns-1
  ndw_= popcnt(idw)
  do Iup=0,2**Ns-1
    nup_ = popcnt(iup)
    select case (ed_mode)
      case('superc') 
        sz_  = nup_ - ndw_
        if(sz_ /= self%Sz)cycle
      case('nonsu2') 
        nt_  = nup_ + ndw_
        if(nt_ /= self%Ntot)cycle 
    end select
    i=i+1 
    !...
    iImpUp  = ibits(iup,0,Norb)
    iImpDw  = ibits(idw,0,Norb)
    iBathUp = ibits(iup,Norb,Norb*Nbath)
    iBathDw = ibits(idw,Norb,Norb*Nbath)
    iImp    = iImpUp  + iImpDw*(2**Norb)
    iBath   = iBathUp + iBathDw*(2**(Norb*Nbath))
    call sp_insert_state(self%H(1)%sp,iImp,iBath,dim)
  enddo
enddo
\end{lstlisting}
\end{minipage}
}
\savestack{\listingB}{\box0}

\begin{tabular}{c|c}\label{list2}
  \stackinset{l}{}{t}{}{}{\listingA} & \stackinset{l}{}{t}{}{}{\listingB} 
\end{tabular}
%



  

  
\subsubsection{Eigenspace}\label{CodeEigenspace}
The {\tt ED\_EIGENSPACE} module contains the implementation of the 
{\tt sparse\_espace} class, which maintains an ordered linked list 
of selected eigenvalues, eigenvectors, and quantum numbers for the 
low-lying spectrum of the quantum impurity Hamiltonian. 
Note that, to reduce the memory footprint each eigenvector 
is automatically distributed among all processors in suitable shares
according to the nature of the quantum numbers $\vec{Q}$.
For zero-temperature calculations, only the groundstate (and its
degenerate counterparts) are stored. For finite temperatures
calculations, the list must also include excited states.

To avoid unbounded growth of this list, a  
truncation mechanism is used. On the first call, a fixed number of
states per sector  
\texttt{lanc\_nstates\_sector} is collected, up to a
maximum total \texttt{lanc\_nstates\_total}, both set via input.  
The list is then truncated to retain only the states satisfying the condition $e^{-\beta(E_i-E_0)} < \mathtt{cutoff}$, where
$E_i$ is the energy of the $i^{\rm th}$ state in the list, $E_0$ is the
groundstate energy,  $\beta=1/T$ is the inverse temperature ($k_B=1$) and \texttt{cutoff}
is an input parameter fixing an a priori energy threshold.


The list dynamically adjusts to optimize the distribution of states 
across sectors, balancing memory use and computation time. The
variable \texttt{lanc\_nstates\_step} controls the increase or
decrease in the number of states per sector. 
A histogram  of the number of states per sector is produced after each diagonalization 
to monitor this distribution.



\subsubsection{GFmatrix}
One of the main goal of the \NAME is to evaluate dynamical correlations
functions (DCF) $\ibra \TT[ A(t) A^+ ]\iket$. Using Krylov methods,
these DCFs can be expressed as truncated Kallen-Lehmann spectral sums of the form
$
\tfrac{1}{Z}\sum_n e^{-\beta E_n} \sum_{m=1}^{N} \tfrac{|w_{mn}|^2}{ z
  - dE_{mn}}
$
where $w_{mn}$ is the weight determined by the projection of the
$m^{\rm th}$ eigenstate onto the $n^{\rm th}$ Krylov basis vector and
$dE_{mn}=E_m-E_n$ is the corresponding excitation energy.

The {\tt ED\_GFMATRIX} module implements the {\tt gfmatrix} class, 
which provides an efficient, multi-layer data structure for storing 
all weights and poles required for the evaluation of DCFs. This 
class is designed to handle multiple operators and sectors, allowing 
for rapid, on-the-fly evaluation of the DCF for any complex frequency 
$z\in\CCC$.

The use of this data structure significantly reduces the computational 
cost of evaluating DCFs by minimizing redundant calculations and 
avoiding repeated diagonalizations, making it a critical component 
for the high-performance execution of \NAME.





















\subsection{Bath parametrization}\label{sSecBath}
The quantum impurity problem is characterized by the coupling between
a local impurity and a surrounding bath. Following the structure of
Eq.~\ref{Hbath}, the bath is parametrized by two components: the
Hamiltonian matrices, $h^p$, and the hybridization amplitudes,
$V^p$, for $p = 1, \dots, N_\mathrm{bath}$.
Internally, the bath is represented by a dedicated object, {\tt
  effective\_bath}, defined in the {\tt ED\_VARS\_GLOBAL} module. From
the user's perspective, all parameters are consolidated into a rank-1
array of doubles, managed using a reverse communication strategy. This
approach ensures that a local array remains accessible to the
user while preventing direct access to the internal copy, thereby
preserving data integrity and reducing memory overhead.


The bath topology, which defines the connectivity between the
$N_\mathrm{b}$ electronic levels assigned to the bath, is specified
through the input variable {\tt bath\_type}. This variable can take
one of four possible values: {\bf normal}, {\bf hybrid}, {\bf
  replica}, and {\bf general} (see Fig.~\ref{figBaths}).



\paragraph{{\tt bath\_type}={\bf normal}} In this configuration, the
bath consists  of $N_\mathrm{bath}$
electronic levels coupled to each of the impurity orbital, resulting
in a total  $N_\mathrm{b} = N_\a N_\mathrm{bath}$ of bath levels.

For {\tt ed\_mode}={\bf normal} the bath Hamiltonian is parametrized
as diagonal matrices in both the orbital and spin spaces:
$$
h^p_{\a\b\s\s'}=\varepsilon_{\a\s}\delta_{\a\b}\delta_{\s\s'} .
$$
where $\varepsilon_{\a\s}$ represents  the on-site energies for each orbital and spin.
If {\tt ed\_mode}={\bf superc},  anomalous
amplitudes connecting bath levels with opposite spins must also be
considered. In this case, the bath Hamiltonian gains 
an additional set of parameters, diagonal in orbital space but
off-diagonal in the spin one:
$$
h^p_{\a\b\s\s'}=\Delta^p_{\a}\delta_{\a\b}\delta_{\s \overline{\s}} .
$$
where $\Delta^p_\a$ represents the pairing amplitudes. 
This choice corresponds to a Nambu representation for each orbital component,
with the Hamiltonian matrices taking the form:
$$
\hat{h}^p_{\a\b} = \e_{\a}\delta_{\a\b}\tau_0 +
\Delta_{\a}\delta_{\a\b}\tau_x .
$$
where $\tau_{i=0,x,y,z}$ are Pauli matrices.

The hybridization amplitudes between the impurity and the bath levels
are similarly structured. For all values of {\tt ed\_mode} these
parameters are diagonal in both
spin and orbital space: $V^p_{\a\b\s\s'}=V^p_{\a\s}\delta_{\a\b}\delta_{\s\s'}$.
If {\tt ed\_mode}={\bf nonsu2} the an additional set including terms
describing spin-flip processes (as total magnetization is not
conserved) should be included $V^p_{\a\b\s\s'} =
W^p_{\a}\delta_{\a\b}\delta_{\s \overline{\s}}$. 



\paragraph{{\tt bath\_type}={\bf hybrid}}
The bath is formed by $N_\mathrm{bath}$ levels coupled to all the
impurity orbitals, resulting in a total of 
$N_\mathrm{b}\equiv N_\mathrm{bath}$ electronic bath levels. 
The parametrization of the bath Hamiltonian is 
diagonal in both orbital and spin space, i.e.,
$$
h^p_{\a\b\s\s'}=\varepsilon_{\a\s}\delta_{\a\b}\delta_{\s\s'}.
$$

As for the previous case, the {\bf superc} mode introduces anomalous
components with the form
$$
h^p_{\a\b\s\s'}=\Delta^p_{\a}\delta_{\a\b}\delta_{\s
  \overline{\s}}.
$$
The key difference here is that the hybridization matrix elements are
generally off-diagonal in the orbital indices:
$$
V^p_{\a\b\s\s'}=V^p_{\a\b\s}\delta_{\s\s'}.
$$

If spin group is not conserved, i.e., for {\tt ed\_mode}={\bf nonsu2}, an additional
set of parameters must be specified to account for spin-flip processes:
$V^p_{\a\b\s\s'} = W^p_{\a\b}\delta_{\s \overline{\s}}$. 

This hybrid topology of the bath captures the effects of locally
hybridized impurity orbitals, but typically requires a more
challenging optimization process, specially
with few available bath levels (see \secu{sSecFit}). 

\paragraph{{\tt bath\_type}={\bf replica}/{\bf general}}
This configuration provides a more flexible parametrization of the 
bath. The core idea is to assign each bath element a structure 
that {\it replicates} the internal structure of the impurity, while 
maintaining diagonal coupling between bath elements and the impurity. 
This offloads the complexity of representing structured quantum 
impurities to the bath Hamiltonian rather than the hybridizations.

From a broader perspective, this can be formalized by considering  
a user-defined matrix basis
$\vec{\Gamma}=\{ \Gamma^\nu_{\a\b\s\s'} \}_{\nu=1,\dots,N_{sym}}$ in the (Nambu-)spin-orbital
space, and expressing the bath Hamiltonian as
$$
h^p = \sum_{\nu=1}^{N_{sym}} \lambda^p_\nu
\Gamma^\nu\equiv \vec{\lambda}^p\cdot \vec{\Gamma}
$$
where $\vec{\lambda}^p\in\RRR^{N_{sym}}$ is a vector of variational parameters. 
The choice of the matrix basis can be inspired by the internal structure
of the quantum impurity, i.e. $\hat{h}^0$, or determined
case-by-case by based on the physical properties of the system.
In this scheme, the total number of bath levels becomes: $N_\mathrm{b}
= N_{sym} N_\mathrm{bath}$.



For the {\bf replica} topology, the coupling between the impurity 
and each bath element remains diagonal in spin, orbital, and internal 
bath structure: $V^p_{\a\b\s\s'} = V^p$.
In the {\bf general} case, this is generalized to include explicit 
dependence on the internal spin and orbital indices: $V^p_{\a\b\s\s'}
= V^p_{\a\s}\delta_{\a\b}\delta_{\s\s'}$. 



All the procedures concerning the bath, either on the user side or the
internal {\tt effective\_bath}, are grouped into a set of modules
wrapped by {\tt ED\_BATH}. We divided the set of modules in three
categories, according to their scope.

\paragraph{Bath Auxiliary Tools}
This module group provides user-oriented utilities, including 
standard symmetry operations on the bath array, such as orbital 
symmetry and particle-hole symmetry, available in 
{\tt ED\_BATH\_USER}. The critical functionality here is the 
determination of the total bath array dimension, implemented in 
{\tt ED\_BATH\_DIM}. The function {\tt ed\_get\_bath\_dimension} 
calculates the required dimension $B$ for user-allocated bath 
arrays, ensuring they contain exactly the necessary number of 
parameters. Any following call
to functions hosting the bath as an input verify the array's 
dimensionality using {\tt check\_bath\_dimension} to prevent 
allocation errors.


\paragraph{Bath Replica (General)}
The module {\tt ED\_BATH\_REPLICA} defines the class {\tt Hreplica} 
for the {\bf replica} and {\bf general} bath parametrizations. In 
addition to standard object construction, destruction, reading, and 
saving, this module provides matrix basis setup 
$\{ \Gamma^\nu \}_{\nu=1,\dots,N_{sym}}$ and variational parameter 
initialization through {\tt set\_Hreplica} (or {\tt set\_Hgeneral}). 
The actual bath Hamiltonian is constructed with the function 
{\tt build\_Hreplica} (or {\tt build\_Hgeneral}) via the relation
$
h^p = \vec{\lambda}^p \cdot \Gamma.
$



\paragraph{Effective Bath}
The module {\tt ED\_BATH\_DMFT} implements the class 
{\tt effective\_bath} (defined in {\tt ED\_VARS\_GLOBAL}), which 
manages all the actual bath parameters for any choice of 
{\tt ed\_mode} and {\tt bath\_type}. For the 
{\bf replica/general} topologies, it directly references the 
{\tt Hreplica} class. A global instance of this class, 
{\tt dmft\_bath}, is shared throughout the code, providing a 
centralized structure for bath parameter management.

The constructor for this class includes the function 
{\tt init\_dmft\_bath}, which either initializes bath parameters 
from scratch or reads them from a file specified by the input 
variable {\tt Hfile}. Additionally, the class offers methods to 
translate bath parameters between the internal {\tt dmft\_bath} 
representation and the user-defined bath arrays via 
{\tt get/set\_dmft\_bath}.





% \begin{table}%[ht]
%   \label{TabBath}
% \begin{center}
% \begin{tabularx}{\linewidth}{ |X|X|X|X| } 
%   \hline
%   c  & {\bf normal} & {\bf superc} & {\bf  nonsu2} \\
%   \hline
%   {\bf normal} $[N_\mathrm{b}\!=\!N_\mathrm{bath}N_\a]$ & $\vec{\e}[N_\mathrm{b}],\vec{V}[N_\mathrm{b}]$ 
%                     & $\vec{\e}[N_\mathrm{b}], \vec{\Delta}[N_\mathrm{b}],\vec{V}[N_\mathrm{b}]$
%                                    &  $\vec{\e}[N_\mathrm{b}], \vec{V}[N_\mathrm{b}],\vec{W}[N_\mathrm{b}]$ \\
%   \hline
%   {\bf hybrid} $[N_\mathrm{b}\!=\!N_\mathrm{bath}N_\a]$ & $\vec{\e}[N_\mathrm{bath}],\vec{V}[N_\mathrm{b}]$ 
%                     & $\vec{\e}[N_\mathrm{bath}], \vec{\Delta}[N_\mathrm{bath}],\vec{V}[N_\mathrm{b}]$
%                                    &  $\vec{\e}[N_\mathrm{bath}], \vec{V}[N_\mathrm{b}],\vec{W}[N_\mathrm{b}]$ \\
%   \hline
%   {\bf replica} $[N_\mathrm{b}\!=\!N_\mathrm{bath}N_{sym}]$ & \multicolumn{3}{*{\hat{h} } \cr
%   \hline
%   {\bf general} $[N_\mathrm{b}\!=\!N_\mathrm{bath}N_{sym}]$ & \cline{2-4} & b&  c  \cr
%   \hline
% \end{tabularx}
% \end{center}
% \caption{Ciao}
% \end{table}






\subsection{Lanczos based Diagonalization}\label{sSecHam}
In presence of symmetries (see \secu{sSecQNs}) the matrix representing
the Hamiltonian operator $\hat{H}$ can be reduced to a block-diagonal form. Each block corresponds to a symmetry sector
with a fixed set of quantum numbers $\vec{Q}$ and is represented by
a Hamiltonian matrix $H_{\SS_{\vec{Q}}}$. 
Consequently, the analysis of the quantum impurity energy spectrum reduces to solving
the secular equation within each individual symmetry sector:
$$
H_{\SS_{\vec{Q}}}\ket{v}=E_{\SS_{\vec{Q}}}\ket{v}.
$$

Even though the dimension of a given sector $\SS$ is much smaller than the
total Fock space dimension $D_\SS \ll D_\FF$, solving completely the
corresponding eigenvalue problem remains a formidable challenge
already for $N_\mathrm{s}\simeq 8$.
To outwit this, various
algorithms have been developed exploiting the sparse nature of
$H_\SS$, including Krylov subspace methods and related approaches
\cite{Lanczos,Arnoldi,Feast}.

In \NAME, the preferred algorithm is P-ARPACK, a state-of-the-art
Lanczos-based eigensolver with distributed memory support
\cite{P-Arpack}. This method incorporates re-orthogonalization within
a block Lanczos routine, ensuring the accurate convergence of the
desired eigenpairs. However, it is also possible to select a simpler,
though less efficient, parallel Lanczos algorithm using the input
variable {\tt lanc\_method}.

The core computational task in any Krylov-based diagonalization
algorithm is the Matrix-Vector Product (MVP), i.e., the application
of the Hamiltonian to a given input vector:
\begin{equation}
H_\SS \ket{v} \to \ket{w}\qquad \ket{v},\ket{w}\in \SS_{\vec{Q}}.
\end{equation}
This operation easily accounts for more than 80\% of the overall
computational effort, making its optimization a critical aspect of
high-performance diagonalization algorithms. In \onlinecite{Amaricci2022},
the distributed-memory, massively parallel strategies employed in \NAME
to optimize this step are discussed in full detail. Here, we provide
a brief outline of the main ideas, following the notation introduced
in \onlinecite{Amaricci2022}, and focusing on the impact of the choice
of {\tt ed\_mode}.




\paragraph{\bf normal}
In this case, the tensor structure of the Fock space and the sector
symmetries are fully leveraged. Within a given sector, the electronic
part of the Hamiltonian can be expressed as:
\begin{equation}
H_\SS = H_\mathrm{d} + H_\up\otimes \mathbb{I}\dw + \mathbb{I}\up\otimes
H_\dw + H_\mathrm{nd},
\label{HssNormal}
\end{equation}
where $H_\mathrm{d}$ represents the diagonal (local) part of the
Hamiltonian, including density-density interactions, while
$H_\sigma$ captures hopping processes for electrons with spin
$\sigma=\up,\dw$. The term $H_\mathrm{nd}$ encompasses all remaining
non-diagonal contributions, such as spin-exchange and pair-hopping
terms.

In this formulation, a sector state $\ket{v}$ can be
represented in a matrix basis $\hat{v}$ with rows (columns)
corresponding to $\up$ ($\dw$) configurations. This structure allows
for efficient MVP operations using {\tt MPI\_All2AllV}, which aims to
optimize memory locality. However, terms in $H_\mathrm{nd}$ that
break this structure require {\tt MPI\_AllGatherV}, introducing a
slight communication overhead and reducing parallel efficiency.





\paragraph{\bf superc/nonsu2}
For these modes, symmetries enforce specific constraints between
$\up$ and $\dw$ configurations, preventing the direct use of the
factorized Fock space representation. The electronic
part of the Hamiltonian is typically structured as:
\begin{equation}
H_\SS = H_\mathrm{imp} + H_\mathrm{int} + H_\mathrm{bath} + H_\mathrm{imp-bath},
\end{equation}
where $H_\mathrm{imp}$ encodes the local impurity Hamiltonian
determined by $h^0_{\a\b\s\s'}$,
$H_\mathrm{int}$ contains the interaction terms, $H_\mathrm{bath}$
describes the effective bath contributions corresponding to
$h^p_{\a\b\s\s'}$, and $H_\mathrm{imp-bath}$ accounts for the
impurity-bath couplings $V^p_{\a\b\s\s'}$.
In an MPI setup, the first three terms contains also elements local to each node and
stored separately within each {\tt sparse\_matrix} instance representing $H_\SS$.
The MVP is carried out using the {\tt MPI\_AllGatherV} algorithm which, as noted in
\onlinecite{Amaricci2022}, requires reconstruction of distributed
arrays and incurs significant communication overhead.




The diagonalization process itself is divided into two primary phases:

\paragraph{\bf Global Setup}. This phase allocates the required memory, initializes
the MPI environment, and configures the appropriate MVP procedure
based on the symmetries of the problem. This logic is implemented in
a set of independent modules, {\tt ED\_HAMILTONIAN\_?}, where
{\tt ed\_mode=?}. Any module includes two functions: {\tt build\_Hv\_sector\_?} and  {\tt vecDim\_Hv\_sector\_?}.

The {\tt build\_Hv\_sector\_?} function builds the symmetry sector and
allocates the MVP function but setting the shared abstract function pointer {\tt
  sphtimesv\_p}. This latter step is controlled by the value of
{\tt ed\_sparse\_H=True/False}. If {\tt True} the Hamiltonian $H_\SS$
gets stored in a {\tt sparse\_matrix} instance and used to perform
the MVPs. The corresponding algorithms are implemented in the modules {\tt
  ED\_HAMILTONIAN\_?\_STORED\_HxV}
If {\tt ed\_sparse\_H} is {\tt False} the MVP is operated on-the-fly,
i.e. each element of $H_\SS$ is directly applied to the input
vector $\ket{v}$, either in serial or parallel mode as implemented in {\tt
  ED\_HAMILTONIAN\_?\_DIRECT\_HxV}.  

The function {\tt vecDim\_Hv\_sector\_?} returns the 
dimension of the vector used in the
MVP. In a MPI-parallel execution the returned value is the
dimension $d_i$ of the vector chunk per each node such that
$\sum_{i=1}^{N_\mathrm{nodes}}d_i = D_\SS$. Yet, the specific value of $d_i$
depends on the MPI algorithm used for the MVP function.

\paragraph{\bf Diagonalization}
This step is managed by the {\tt ED\_DIAG\_?}
modules, which contain the main functions {\tt diagonalize\_impurity\_?}.
This phase includes: (i) selecting sectors for diagonalization, (ii)
performing diagonalization within each sector, and (iii) analyzing
the resulting {\tt state\_list} of conserved eigenstates.




\subsection{Dynamical correlation functions}\label{sSecGF}
The determination of the low energy part of the Hamiltonian spectrum
enables the evaluation of Dynamical Correlation Functions (DCF) using Krylov
sub-space algorithm.
This capability is central to the library when using \NAME as an
impurity solver within the DMFT framework.

Before delving into the implementation specifics, we outline the
generic approach. Consider the generic DCF:
\begin{equation}
  \label{eqGaa}
  C_\AA = \ibra \TT_\pm[ \AA(t) \AA^+ ]\iket
\end{equation}
where $\AA(t)=e^{iHt}\AA e^{-iHt}$, $\TT_\pm$ is the time-ordering
operator for fermions ($-$) or
bosons ($-$), and $\ibra \AA \iket=\frac{1}{Z}\Tr{ \left[ e^{-\beta
      H}\AA \right]}$, with $Z=\sum_ne^{-\beta E_n}$, the thermodynamic
average.
Using spectral decomposition, the expression \equ{eqGaa} reduces to a
K\"all\`en-Lehmann form:
\begin{equation}\label{KLgf}
  \begin{split}
    C_\AA(z) 
    &=  \ibra \AA \frac{1}{z-H} \AA^+\iket
    \mp \ibra \AA^+ \frac{1}{z+H} \AA\iket \cr
    %
    & =\frac{1}{Z}\sum_n e^{-\beta E_n}\sum_m
  \frac{ |\bra{\psi_m}\AA^+ \ket{\psi_n}|^2 }  {z-(E_m-E_n)}
  \mp
  \frac{ |\bra{\psi_m}\AA \ket{\psi_n}|^2 }  {z+(E_m-E_n)}\cr
\end{split}
\end{equation}
where $z\in\CCC$,  $\ket{\psi_n}$, $E_n$ are the eigensolutions of the
Hamiltonian $H$. 
This form is appealing but computationally prohibitive, as it requires
the full Hamiltonian spectrum. However, the first line in \equ{KLgf}
highlights that the $C_\AA$ essentially corresponds to a specific
matrix element of the resolvant operator $(z-H)^{-1}$, which can be
efficiently approximated using the Krylov sub-space method.

To illustrate this approach, consider the normalized initial state: 
$$
\ket{\phi_n}=\AA^+\ket{\psi_n}/\NN_n
$$
where  $\ket{\psi_n}\in\SS$ and $\NN_n=\sqrt{\bra{\psi_n}\AA
  \AA^+\ket{\psi_n}}$.
The Krylov basis is then constructed as $$\mathcal{K}_{N} (\ket{\phi_n})=\{\ket{\phi_n}, H\ket{\phi_n}, \dots,
H^N\ket{\phi_n}\}\equiv \{\ket{v^n_0}, \ket{v^n_1},\dots, \ket{v^n_N}
\}$$ with $1 \ll N \ll \DD_\SS$, obtainaed by repeated applications of
the (sector) Hamiltonian via MVP functions.

Given that any eigenstate $\ket{\psi_n}$ can be expressed within the
Krylov basis as
$\ket{\psi_n} = \sum_i  \ibra v^n_i|\psi_n \iket  \ket{ v^n_i} =
\sum_i a^n_i \ket{v^n_i}$. we can approximate the expression
\equ{KLgf} as:  
\begin{equation}
  \label{eqGKrylov}
  \begin{split}
    C_\AA(z)  &\simeq \frac{1}{Z}\sum_n e^{-\beta E_n}
    \sum_{m=1}^{N} \frac{\bra{\psi_n}\AA \AA^+\ket{\psi_n} |a^n_m|^2}{
      z - (E_m-E_n)} \mp \frac{\bra{\psi_n}\AA^+ \AA\ket{\psi_n}
      |a^n_m|^2}{ z + (E_m-E_n)}\cr
    %
    &= \frac{1}{Z}\sum_n\sum_{m=1}^{N} \sum_{\nu=\pm}\frac{w^{\nu}_{mn}[\AA]}{z - dE^\nu_{mn}[\AA]} 
    = \frac{1}{Z}\sum_n
    \sum_{m=1}^{N} \sum_{\nu=\pm} g_\AA(\nu, w^{\nu}_{mn},  dE^\nu_{mn}) \cr
  \end{split}
\end{equation}
where the terms are grouped as a sum over spectral weights and
poles. We introduced the notation $g(\nu, w(\AA)^{\nu}_{mn},  dE(\AA)^\nu_{mn})$
for the {\tt gfmatrix} object containing the weights $w(\AA)^{\nu}_{mn}$ and
poles $dE(\AA)^{\nu}_{mn}$ for the operator $\AA$, for every initial state $\ket{\psi_n}$
contributing to the low energy spectrum, for every order $m$ of the
Krylov sub-space algorithm and for channel $\nu$.
This approach significantly reduces the computational burden, as it
relies on a much smaller set of basis states.


However, this method is typically limited to diagonal DCF like
\equ{eqGaa}. In practice, many applications requires also to build off-diagonal
functions of the form:
$C_{\AA\BB}(z) = \ibra T_{\pm}[\AA(t) \BB^+]\iket$.
This can addressed by introducing auxiliary operators, such as $\OO=\AA +\BB$ and
$\PP=\AA-i\BB$, enabling the extraction of the desired function via
simple algebraic combinations:
$$
C_{\AA\BB} = \frac{1}{2}\left[C_\OO + C_\PP - (1-i)C_\AA -(1-i)C_\BB\right]
$$


In \NAME, the computation of impurity Green's functions, such as
$G_{\a\b\s\s'}=\ibra \TT_\pm[ c_{\a\s}(t) c_{\b\s'}^+ ]\iket$,
is handled by the \texttt{ED\_GREENS\_FUNCTIONS} module.
This
module integrates more specialized methods based on the symmetry
classification defined by the \texttt{ed\_mode} parameter.
Moreove, in the {\bf normal} mod, it also includes spin, charge, pair, and excitonic
susceptibility functions, providing a comprehensive framework for
dynamical response calculations.
From a computational perspective, the construction of the Krylov basis
$\mathcal{K}_N(\OO\ket{\psi_n})$ for each eigenstate within the low-energy
spectrum is typically the most resource-intensive step.
As with the
diagonalization process, a significant performance gain is achieved through
the parallel execution of the Matrix-Vector Product (MVP) at the core of
the Hamiltonian tri-diagonalization algorithm.
The input variable
\texttt{lanc\_gfniter} regulates the maximum order of the Krylov basis,
determining the upper limit on the number of excitations considered in
\equ{eqGKrylov}.
Operationally, each symmetry mode (\texttt{ed\_mode=?}) requires a distinct
strategy for Green's function construction, implemented in the corresponding
\texttt{ED\_GF\_?} modules.


\paragraph{{\bf normal}}
In this mode, all orbital-dependent and spin-diagonal Green's 
functions, $G_{\a\b\s\s}$, must be evaluated. The diagonal 
case, where $\a=\b$, is straightforward and involves applying 
the operator $\AA=c_{\a\s}$ to any eigenstate $\ket{\psi_n}$ 
from the global {\tt state\_list} of the low-energy spectrum, 
which is represented by the {\tt sparse\_espace} object. This 
operation relies on the functions {\tt apply\_op\_C/CDG} in 
{\tt ED\_AUX\_FUNX}. 



The sector Hamiltonian matrix in this mode is typically assumed 
to be real symmetric, which significantly simplifies the evaluation 
of the off-diagonal terms. In this case, the relation 
$G_{\a\b\s\s}=G_{\b\a\s\s}$ holds, allowing the computation of 
off-diagonal components using an auxiliary operator 
$\OO = c_{\a\s} + c_{\b\s}$ and the identity:
$G_{\a\b\s\s}=\tfrac{1}{2}(C_\OO - G_{\a\a\s\s} - G_{\b\b\s\s})$.

The diagonal spin, charge and pair susceptibility terms
$\chi^{S^z}_{\a\a}$, $\chi^N_{\a\a}$ and $\chi^\Delta_{\a\a}$
are constructed using the operators $\AA = \sum_{\s\s'} c^+_{\a\s}
\tau^z_{\s\s'} c_{\a\s'} \equiv S^z_\a, $, 
$\AA = \sum_{\s\s'} c^+_{\a\s} \tau^0_{\s\s'} c_{\a\s'} \equiv N_\a, $
and $\AA = c_{\a\dw}c_{\a\up} \equiv \Delta_\a$,
where $\tau^{a=0,x,y,z}$ are the Pauli matrices.
Off-diagonal terms are similarly evaluated using the operators
$\AA=S^z_\a + S^z_\b$, $\AA=N_\a + N_\b$ or $\AA=\Delta_\a + \Delta_\b$. 
Excitonic susceptibilities, $\chi^T_{\a\b}$, are defined with 
respect to the vector operator: $T^i_{\a\b} = \sum_{\s\s'}
c^+_{\a\s}\tau^i_{\s\s'}c_{\b\s'}$, where $i=0$ represents the
spin-singlet exciton, and $i=x,y,z$  correspond to the spin-triplet excitons.


\paragraph{{\bf superc}}
In the supercondutive case, the Nambu orbital-dependent $s$-wave
Green's function reads:
\begin{equation}
  \label{GFnambu}
  \hat{G}_{\a\b} =
  \begin{bmatrix}
    G_{\a\b\up\up} & F_{\a\b\up\dw} \\
    \bar{F}_{\a\b\dw\up} & \bar{G}_{\a\b\dw\dw}
  \end{bmatrix}  
\end{equation}
Exploiting symmetries between matrix components, it is 
sufficient to compute only the top row elements along with 
a few auxiliary functions.

The diagonal normal component $G_{\a\a\up\up}$ can be 
evaluated using the same approach as in the {\bf normal} 
case. However, for the off-diagonal terms $G_{\a\b\up\up}$, 
we forgo symmetry arguments and instead define two 
auxiliary operators, $\OO = c_{\a\up} + c_{\b\up}$ and 
$\PP = c_{\a\up} - i c_{\b\up}$. This allows us to express 
the Green's function as::
$G_{\a\b\up\up}=\tfrac{1}{2}[C_\OO + C_\PP -
(1-i)(G_{\a\a\up\up}+G_{\b\b\up\up})$.

Evaluating the diagonal and off-diagonal anomalous terms 
$F_{\a\b\up\dw}$ requires distinct combinations of 
creation and annihilation operators. First, the component 
$\bar{G}_{\a\a\dw\dw}$ is evaluated as an auxiliary term 
using $\AA = c^+_{\a\dw}$. Then, we construct two further 
linear combinations:
\begin{align*}
\TT &= c_{\a\up} + c^+_{\b\dw}, \\
\RR &= c_{\a\up} - i c^+_{\b\dw},
\end{align*}
which contribute to the auxiliary functions $C_\TT$ and 
$C_\RR$, respectively. The final expression for the 
anomalous function reads:
\begin{equation}
F_{\a\b\up\dw} = \tfrac{1}{2} \left[ C_\TT + C_\RR - 
(1-i)(G_{\a\a\up\up} + \bar{G}_{\b\b\dw\dw}) \right].
\end{equation}



\paragraph{{\bf nonsu2}}
In the {\bf nonsu2} case, all Green's function components 
must be explicitly evaluated, as the spin and orbital 
symmetries are not conserved. For the diagonal terms 
$G_{\a\a\s\s}$, the procedure follows the same approach 
outlined in the {\bf normal} case. 

The off-diagonal components $G_{\a\b\s\s'}$, however, 
require a more general treatment. These are computed using 
auxiliary operators defined as:
\begin{align*}
\OO &= c_{\a\s} + c_{\b\s'}, \\
\PP &= c_{\a\s} - i c_{\b\s'},
\end{align*}
which allows the Green's function to be expressed as:
\begin{equation}
G_{\a\b\s\s'} = \tfrac{1}{2} \left[ C_\OO + C_\PP - 
(1-i)(G_{\a\a\s\s} + G_{\b\b\s'\s'}) \right].
\end{equation}
This approach effectively reduces the complexity of 
evaluating the off-diagonal terms by leveraging auxiliary 
functions, despite the absence of full spin symmetry.





\subsection{Observables}\label{sSecObc}
A wide range of predefined impurity observables and local 
static correlations, such as occupation numbers, total 
energy, pair amplitudes, and excitonic order parameters, 
are computed in the \texttt{OBSERVABLES} module. Similar to 
previous cases, this module wraps different implementations 
depending on the operational mode specified by 
{\tt ed\_mode=?} and is distributed across the corresponding 
files {\tt ED\_OBSERVABLES\_?}. 



Local observables and correlations are generally defined 
through the thermal average 
$\ibra \OO\iket = \frac{\Tr\left[e^{-\beta H}\OO\right]}{Z}$, 
where $Z = \sum_n e^{-\beta E_n}$ is the partition function. 
At zero or low temperatures, this can be efficiently 
evaluated using the stored low-energy part of the spectrum, 
taking advantage of the exponential suppression provided by 
the Boltzmann factor:
\begin{equation}
\ibra \OO\iket = \frac{1}{Z}\sum_n e^{-\beta E_n}
\bra{\psi_n} \OO \ket{\psi_n},
\label{eq:thermal_average}
\end{equation}
where $E_n$ and $\ket{\psi_n}$ are the low-lying eigenstates 
of the system stored in the {\tt state\_list}. This approach 
greatly reduces computational overhead by focusing on the 
relevant, low-energy sector.
\begin{equation}
  \ibra \OO\iket  = \tfrac{1}{Z}\sum_n e^{-\beta  E_n}
  \bra{\psi_n}\OO\ket{\psi_n},
  \label{eq:thermal_average}
\end{equation}
where $E_n$ and $\ket{\psi_n}$ are the low lying eigenstates of the
system stored in the {\tt state\_list}. 


\subsection{Reduced impurity density matrix}\label{sSecRDM}
The latest version of \NAME introduces the calculation of the 
impurity Reduced Density Matrix (iRDM, $\rho^\mathrm{imp}$), 
extending the algorithm initially proposed in 
Ref.~\onlinecite{BellomiaPhD} to support the analysis of entanglement 
properties of quantum impurities for any value of  {\tt ed\_mode}.

For simplicity, this section focuses on the zero-temperature limit, 
assuming a non-degenerate ground state $\ket{\psi}$ present in the 
{\tt state\_list}. The generalization to the finite-temperature regime 
or degenerate ground states is straightforward, requiring only the 
replacement of the pure state average with the thermal or degenerate 
ensemble average $\ibra \rho^\mathrm{imp} \iket$, as defined in 
\equ{eq:thermal_average}.


A pure quantum state $\ket{\psi}$ belonging to a unique symmetry 
sector $\SS_{\vec{Q}}$ can be represented in the Fock basis as:
$
\ket{\psi} = \sum_I a_I \ket{I},
$
where the pure density matrix $\rho$ is then given by:
\begin{equation}
\rho = \ket{\psi}\bra{\psi} = \sum_{IJ=1}^{4^{N_\mathrm{s}}} 
a^*_J a_I \ket{I}\bra{J} = \sum_{IJ=1}^{4^{N_\mathrm{s}}} 
\rho_{IJ} \ket{I}\bra{J}.
\end{equation}


The iRDM is obtained by tracing out the bath degrees of freedom:
\begin{equation}
\rho^\mathrm{imp} = \Tr_\mathrm{bath}(\rho).
\end{equation}
However, the summations involved in this trace quickly become 
computationally prohibitive, as their range scales exponentially 
with the system size, i.e., $4^{N_\mathrm{s}}$.

To address this, we implemented a fast algorithm that exploits the 
block structure of the Fock space defined by the symmetry sectors and
the subsequent map sparsity. 
This approach significantly reduces the computational cost by limiting 
the summation to the sector size $D_\SS$ of the symmetry sector 
$\SS$ to which the ground state (or any eigenstate) belongs.


Next, we decompose the Fock basis into spin-dependent impurity and 
bath parts. Any Fock state $\ket{I}$ can be split as:
$
\ket{I} = \ket{i_\uparrow \, b_\uparrow} \otimes 
\ket{i_\downarrow \, b_\downarrow},
$
where the impurity $i_\sigma$ and bath $b_\sigma$ states span subspaces of dimension 
$D^\s_\mathrm{imp}$ and $D^\s_\mathrm{bath}$, respectively, for each 
spin $\s = \uparrow, \downarrow$.


To efficiently manage this decomposition, we introduce a 
{\tt sparse\_map} ${\cal P}$, as detailed in \secu{CodeSparseMap}. 
This structure stores, for each impurity configuration 
$i_\s = 1, \dots, D^\s_\mathrm{imp}$ (the \emph{key}), the 
corresponding bath configurations 
$b_\s \in [1, \dots, D^\s_\mathrm{bath}]$ (the \emph{values}) that 
satisfy the symmetry constraints over the sector quantum numbers
imposed by the {\tt ed\_mode} variable.
We denote the number of keys as ${\cal D}_{i\s}$ and the 
number of values as ${\cal D}_{b\s}$.
The fast summation algorithm for evaluating the iRDM differs 
significantly between the {\bf normal} and {\bf superc/nonsu2} modes, 
as outlined in the sections below.





\paragraph{{\bf normal}}
In this case, we take advantage of the Fock space factorization and 
sector spin-resolved decomposition, as discussed in detail in 
\secu{sSecQNs}. 
The global bitset can be split into spin-resolved 
impurity and bath components as:
\begin{equation}
\ket{\vec{n}} =
\ket{\vec{n}_\up}\otimes \ket{\vec{n}_\dw} =
\ket{\vec{i}_\up}\ket{\vec{b}_\up}\otimes \ket{\vec{i}_\dw}\ket{\vec{b}_\dw}.
\end{equation}
Here, creation (destruction) operators  $c^+_{p\sigma}$
($c^+_{p\sigma}$) at position $p$ and for a given spin $\sigma$
act only on the corresponding 
spin subspace, i.e., they commute with the opposite spin 
subspace $\ket{\vec{n}_{\bar{\s}}}$ without introducing any 
fermionic sign.

In the {\bf normal} mode, the iRDM is restricted to 
{spin-diagonal} blocks. This follows from the observation 
that the conserved quantum numbers are 
\emph{additive} quantities, given by:
$N_\s = N_\s^\mathrm{imp} + N_\s^\mathrm{bath}$
where the corresponding generator of the symmetry group factorizes as
$U_{N_\s} = U_{N_\s^\mathrm{imp}} \otimes U_{N_\s^\mathrm{bath}}$. 
Since the iRDM acts only on the impurity Fock space, this implies:
% $$
% U_{N_\s}^\dagger \rho^\mathrm{imp} U_{N_\s} = 
% U_{N_\s^\mathrm{bath}}^\dagger \otimes U_{N_\s^\mathrm{imp}}^\dagger
% \rho^\mathrm{imp} U_{N_\s^\mathrm{imp}} \otimes U_{N_\s^\mathrm{bath}} =
% U_{N_\s^\mathrm{imp}}^\dagger
% \rho^\mathrm{imp} U_{N_\s^\mathrm{imp}} =
% \rho^\mathrm{imp},
% $$
\begin{equation}
\begin{aligned}
U_{N_\s}^\dagger \rho^\mathrm{imp} U_{N_\s} &= 
U_{N_\s^\mathrm{bath}}^\dagger \otimes U_{N_\s^\mathrm{imp}}^\dagger 
\rho^\mathrm{imp} 
U_{N_\s^\mathrm{imp}} \otimes U_{N_\s^\mathrm{bath}} \\
&= 
U_{N_\s^\mathrm{imp}}^\dagger \rho^\mathrm{imp} U_{N_\s^\mathrm{imp}}\\
& = 
\rho^\mathrm{imp},
\end{aligned}
\end{equation}
demonstrating that $U_{N_\s^\mathrm{imp}}$ defines a symmetry of 
$\rho^\mathrm{imp}$, which is therefore block diagonal with respect to 
the impurity quantum numbers $N_\s^\mathrm{imp}$.


The resulting iRDM takes the form:
\begin{equation}
  \label{iRDMnormal}
  \begin{aligned}
  \rho^\mathrm{imp} &= \Tr_{b_\up b_\dw}{\rho} = 
  \sum_{b_\up=1}^{D_{b_\up}}
  \sum_{b_\dw=1}^{D_{b_\dw}}
  \bra{b_\up}\otimes\bra{b_\dw}
    \rho
    \ket{b_\dw}\otimes\ket{b_\up}    \cr
    %
    &=
    \sum_{b_\up=1}^{D_{b_\up}}
    \sum_{i_\up=1}^{D_{i_\up}}
    \sum_{p_\up=1}^{D_{p_\up}}
    \sum_{j_\up=1}^{D_{j_\up}} 
    \sum_{q_\up=1}^{D_{q_\up}}
    \Bigg( \cr
    %
    &\qquad
    \sum_{b_\dw=1}^{D_{b_\dw}}
    \sum_{i_\dw=1}^{D_{i_\dw}}
    \sum_{p_\dw=1}^{D_{p_\dw}}
    \sum_{j_\dw=1}^{D_{j_\dw}} 
    \sum_{q_\dw=1}^{D_{q_\dw}}
    C_{i,p}\,C_{j,q}\,a_{i_\up p_\up i_\dw p_\dw} a^*_{j_\up q_\up j_\dw q_\dw}
    \langle b_\up| p_\up\rangle| i_\up\rangle\langle j_\up |\langle q_\up| b_\up\rangle   \otimes \langle b_\dw| p_\dw \rangle|i_\dw\rangle \langle j_\dw  |\langle q_\dw| b_\dw\rangle \Bigg)
    \cr
&=
    \sum_{i_\up=1}^{D_{i_\up}}
    \sum_{j_\up=1}^{D_{j_\up}}
    \sum_{i_\dw=1}^{D_{i_\dw}}
    \sum_{j_\dw=1}^{D_{j_\dw}}
    \underbrace{\left(
    \sum_{b_\up=1}^{D_{b_\up}}
    \sum_{b_\dw=1}^{D_{b_\dw}}
    a_{i_\up b_\up i_\dw b_\dw} a^*_{j_\up b_\up j_\dw b_\dw}
    \right)}_{\rho^\mathrm{imp}_{i_\up j_\up} \otimes\, \rho^\mathrm{imp}_{i_\dw j_\dw} }
    \ket{i_\up}\bra{j_\up}\otimes \ket{i_\dw}\bra{j_\dw},
  \end{aligned}
\end{equation}
where the coefficients $a_I = a_{i_\up b_\up i_\dw b_\dw}$ are the
expansion coefficients of the state on the Fock basis
$\ket{\psi} = \sum_I a_I \ket{i_\uparrow\,  b_\uparrow\,} \otimes \ket{i_\downarrow
  \, b_\downarrow}$.
Notably, the factors $C_{i,b}$, which account for the potential 
fermionic sign from reordering bath and impurity components, are 
trivially 1 due to the absence of cross-spin interference in this 
mode, as enforced by the Kronecker deltas for bath and impurity 
indices.

The numerical implementation relies on the use of the {\tt
  sparse\_map} ($\%sp$) for the groundstate sector as reported in the listing below:  
\begin{lstlisting}[style=fstyle,numbers=none,basicstyle={\scriptsize\ttfamily}]
do IimpUp=0,2**Norb-1
  do JimpUp=0,2**Norb-1
    !Finding the unique bath states connecting IimpUp and JimpUp
    call sp_return_intersection(sectorI%H(1)%sp,IimpUp,JimpUp,BATHup,lenBATHup)
    if(lenBATHup==0)cycle
    do IimpDw=0,2**Norb-1
      do JimpDw=0,2**Norb-1
        !Finding the unique bath states connecting IimpDw and JimpDw -> BATHdw(:)
        call sp_return_intersection(sectorI%H(2)%sp,IimpDw,JimpDw,BATHdw,lenBATHdw)
        if(lenBATHdw==0)cycle
        do ibUP=1,lenBATHup
          IbathUp = BATHup(ibUP)
          do ibDW=1,lenBATHdw
            IbathDw = BATHdw(ibDW)
            !Allowed spin Fock space Istates:
            !Iup = IimpUp +  2^Norb * IbathUp
            !Idw = IimpDw +  2^Norb * IbathDw
            iUP= binary_search(sectorI%H(1)%map,IimpUp + 2**Norb*IbathUp)
            iDW= binary_search(sectorI%H(2)%map,IimpDw + 2**Norb*IbathDw)
            i  = iUP + (iDW-1)*sectorI%DimUp
            !Allowed spin Fock space Jstates:
            !Jup = JimpUp +  2^Norb * IbathUp
            !Jdw = JimpDw +  2^Norb * IbathDw
            jUP= binary_search(sectorI%H(1)%map,JimpUp + 2**Norb*IbathUp)
            jDW= binary_search(sectorI%H(2)%map,JimpDw + 2**Norb*IbathDw)
            j  = jUP + (jDW-1)*sectorI%DimUp
            ! 
            io = (IimpUp + 2**Norb*IimpDw) + 1
            jo = (JimpUp + 2**Norb*JimpDw) + 1
            irdm(io,jo) = irdm (io,jo) + psi(i)*psi(j)*weight
          enddo
        enddo
      enddo
    enddo
  enddo
enddo
\end{lstlisting}



\paragraph{{\bf superc/nonsu2}}
For these lower-symmetry cases, the absence of a clean Fock space 
factorization introduces additional complexities. Specifically, the 
correct evaluation of the off-diagonal iRDM terms, which connect 
different $[N^\mathrm{imp}_\up,\,N^\mathrm{imp}_\dw]$ blocks, 
requires an explicit computation of fermionic permutation signs.


Consider a generic Fock basis state in the form 
$\ket{I} =\ket{{i}_\up\,{b}_\up\,{i}_\dw\,{b}_\dw}$, , and define the 
ground state as $\ket{\psi} = \sum_I a_I \ket{I}$. 
The pure density 
matrix is then given by
$\rho = \ket{\psi}\bra{\psi} = \sum_{IJ} a_I a^*_J \ket{I}\bra{J}$ 
while the iRDM is obtained by tracing over the bath degrees of 
freedom:
\begin{equation}
  \begin{aligned}
    \rho^\mathrm{imp} &= \Tr_{b_\up b_\dw}{\rho} =
    \sum_{b_\sigma=1}^{D_{b_\sigma}}
    \bra{b_\up\, b_\dw}
    \,\rho\,
    \ket{b_\dw\, b_\up} =
    \sum_{b_\sigma=1}^{D_{b_\sigma}}
    \ibra{b_\up\, b_\dw}
    \ket{\psi}\ibra{\psi}
    \ket{b_\dw\, b_\up}    \cr
    &=
    \sum_{b_\sigma=1}^{D_{b_\sigma}}
    \sum_{i_\sigma=1}^{D_{i_\sigma}}
    \sum_{p_\sigma=1}^{D_{p_\sigma}}
    \sum_{j_\sigma=1}^{D_{j_\sigma}} 
    \sum_{q_\sigma=1}^{D_{q_\sigma}}
    a_{i_\up p_\up i_\dw p_\dw} a^*_{j_\up q_\up j_\dw q_\dw}% \cr
    % &{\phantom =}
    \langle{b_\up\, b_\dw}|{i_\up\, p_\up\, i_\dw\, p_\dw}\rangle
    \langle{q_\dw \,  j_\dw \, q_\up\, j_\up }|{b_\dw\, b_\up}\rangle\, .
  \end{aligned}
\end{equation}
where $a_I = a_{i_\up b_\up i_\dw b_\dw}$ are the expansion
coefficient in the Fock basis.

To further simplify this expression, it is essential to eliminate the 
sums over the internal bath indices $p_\sigma$ and $q_\sigma$, ideally 
contracting them with the outer bath indices $b_\sigma$. This requires 
reorganizing the bit representation of the basis states to bring the 
bath bitsets before the impurity states:
$$
\ket{i_\up\, p_\up\, i_\dw\, p_\dw} \rightarrow C_{p_\up,i_\dw} \ket{i_\up\, i_\dw \,p_\up\,p_\dw}
$$
where the fermionic sign factor
$C_{p_\up,i_\dw}  = (-1)^{\#\vec{n}_{p\up} \cdot
  \#\vec{n}_{i\dw}}$
accounts for the exchange of the bath $\ket{p_\up}$  and impurity
$\ket{i_\dw}$ bit configurations.
Here, $\#\vec{n}_{\alpha\sigma}$ denotes the number of set bits in the 
occupation vector $\vec{n}_{\alpha\sigma}$. 

Substituting this relation back into the iRDM expression yields:
\begin{equation}
    \rho^\mathrm{imp} =
    \sum_{i_\up=1}^{D_{i_\up}}
    \sum_{j_\up=1}^{D_{j_\up}}
    \sum_{i_\dw=1}^{D_{i_\dw}}
    \sum_{j_\dw=1}^{D_{j_\dw}}
    \underbrace{\left(
    \sum_{b_\up=1}^{D_{b_\up}}
    \sum_{b_\dw=1}^{D_{b_\dw}}
    a_{i_\up b_\up i_\dw b_\dw} a^*_{j_\up b_\up j_\dw b_\dw}
    C_{b_\up,i_\dw}C_{b_\up,j_\dw}\right)}_{
    \rho^\mathrm{imp}_{i_\up i_\dw j_\dw j_\up}}
    \ket{i_\up\, i_\dw}\bra{j_\dw \, j_\up}
  \end{equation}
where the term 
$C_{b_\up,i_\dw}C_{b_\up,j_\dw}$ accounts for the fermionic 
signs associated with the bath-impurity bitset exchange.

  
In numerical implementations, this approach introduces a few 
key differences with respect to the {\bf normal} mode.
In particular, the 
ordering of the \emph{key-value} pairs in the {\tt sparse\_map} 
must reflect the contiguous bitset structure, which is critical 
for correctly reconstructing the Fock state indices.
See the following listing:
\begin{lstlisting}[style=fstyle,numbers=none,basicstyle={\scriptsize\ttfamily}]
do IimpUp=0,2**Norb-1
  do IimpDw=0,2**Norb-1
    do JimpUp=0,2**Norb-1
      do JimpDw=0,2**Norb-1
        !Build indices of the RDM in 1:4**Norb
        iImp = iImpUp + iImpDw*2**Norb
        jImp = jImpUp + jImpDw*2**Norb
        call sp_return_intersection(sectorI%H(1)%sp,iImp,jImp,Bath,lenBath)
        if(lenBATH==0)cycle
        do ib=1,lenBath
          iBath = Bath(ib)
          !Decompose iBath into B_Up, B_dw to reconstruct B bitset. 
          !B --> {B_up,B_dw}
          iBathUp = mod(iBath,2**Nbath)
          iBathDw = (iBath)/2**Nbath
          !Reconstruct the Fock state Ii map back to sector state i
          ii= iImpUp + iImpDw*2**Ns + 2**Norb*(IBathUp + IBathDw*2**Ns)
          i = binary_search(sectorI%H(1)%map,ii)
          !Reconstruct the Fock state Jj map back to sector state j
          jj= jImpUp + jImpDw*2**Ns + 2**Norb*(IBathUp + IBathDw*2**Ns)
          j = binary_search(sectorI%H(1)%map,jj)
          !Build the signs of each components of RDM(io,jo)
          nBup  = popcnt(Ibits(ii,Norb,Norb*Nbath))
          nIdw  = popcnt(Ibits(ii,Ns,Norb))
          nJdw  = popcnt(Ibits(jj,Ns,Norb))
          signI = (-1)**(nIdw*nBup)
          signJ = (-1)**(nJdw*nBup)
          sgn   = signI*signJ
          !  
          io = (iImpUp+1) + 2**Norb*iImpDw
          jo = (jImpUp+1) + 2**Norb*jImpDw
          rdm(io,jo) = rdm(io,jo) + psi(i)*conjg(psi(j))*weight*sgn
        enddo
      enddo
    enddo
  enddo
enddo
\end{lstlisting}


\subsection{Bath Functions}\label{sSecFunc}
The module {\tt ED\_BATH\_FUNCTIONS} implements the on-the-fly 
calculation of the hybridization function 
$\Delta_{\a\b\s\s'}(z)$ and the non-interacting Green's functions 
$G^0_{\a\b\s\s'}(z)$ for arbitrary complex frequencies $z \in \CCC$. 
These are defined as
\begin{equation}
\Delta_{\a\b\s\s'}(z) = \sum_\nu V^\nu_{\a\s} 
\left( z\11 - h^\nu_{\a\b\s\s'} \right)^{-1} V^\nu_{\b\s'},
\end{equation}
\begin{equation}
G^0_{\a\b\s\s'}(z) = 
\left[ (z + \mu)\delta_{\a\b\s\s'} - h^0_{\a\b\s\s'} - 
\Delta_{\a\b\s\s'}(z) \right]^{-1},
\end{equation}
where $V^\nu_{\a\s}$ and $h^\nu_{\a\b\s\s'}$ are the bath coupling 
and bath Hamiltonian matrices, respectively, and $\mu$ is the chemical 
potential.

The module supports all cases defined by the {\tt ed\_mode} and 
{\tt bath\_type} variables, including both user-supplied baths (provided 
as rank-1 arrays of doubles) and the internally allocated {\tt 
effective\_bath} instance {\tt dmft\_bath}. This flexibility ensures 
compatibility with a wide range of other solvers.

Different routines are available for directly evaluating $\Delta$, 
$G^0$, and its inverse $[G^0]^{-1}$, which are critical for computing 
the self-energy functions on demand (see \secu{sSecIO}). 

In the superconducting case, where {\tt ed\_mode}={\bf superc}, 
special care is needed to properly handle the anomalous (off-diagonal) 
components within the Nambu basis. In this case, the bath functions 
must include both the normal and anomalous components, 
which can significantly alter the form of the self-energy. 




\subsection{Bath Optimization}\label{sSecFit}
In the DMFT framework, the bath parameters must be optimized to 
faithfully reproduce the Weiss field, 
${\GG^{-1}_{0}}_{\a\b\s\s'}(z)$, or its corresponding hybridization 
function 
\begin{equation}
\Theta(z) = (z + \mu)\11 - H^\mathrm{loc} - \GG_0^{-1}(z),
\end{equation}
where $\mu$ is the chemical potential and $H^\mathrm{loc}$ is the 
local non-interacting Hamiltonian. The Weiss field is obtained from the DMFT 
self-consistency equation~\cite{Georges1996RMP}, while the bath 
discretization requires a careful fitting of this continuous function 
using a finite set of bath parameters (see \secu{sSecBath}).

Several algorithms have been proposed for this optimization 
step~\cite{Garcia2004PRL,Taranto2012PRB}, each with strengths suited 
to different physical contexts. To maintain flexibility in \NAME, 
we provide a general optimization interface that is independent 
from the core impurity solver. However, we also include a fully 
integrated optimization routine based on the conjugate gradient (CG) 
minimization of the cost function:
\begin{equation}
\chi = \sum_{n=1}^{L_\mathrm{fit}} 
\frac{1}{W_n} \left\|X(i\omega_n) - 
X^\mathrm{QIM}(i\omega_n; \{V, h\}) \right\|_q,
\end{equation}
where the $q$-norm is a suitably chosen distance metric in the 
matrix function space. Here, $X_{\a\b} = {\GG_{0}}_{\a\b\s\s'}$ or 
$\Theta_{\a\b\s\s'}$ are the user-supplied local functions, while 
$X_{\a\b}^\mathrm{QIM} = G^0_{\a\b\s\s'}$ or 
$\Delta_{\a\b\s\s'}$ are the corresponding functions for the quantum 
impurity model, as defined in \secu{sSecFunc}.

While more sophisticated optimization methods have been developed for 
truncated algorithms like sCI or DMRG, which handle systems with a 
larger number of bath levels, the CG minimization approach has proven 
both efficient and flexible for the small to moderate bath sizes 
typical in ED solvers. 

The entire fit procedure is encapsulated in the function 
\texttt{ed\_chi2\_fitgf} provided by the module 
\texttt{ED\_BATH\_FIT}. To exploit the regularity of the bath functions, 
the fit is performed on the Matsubara frequency axis, where the functions 
are smooth and rapidly decaying. The form of $X_{\a\b\s\s'}$ is controlled 
by the input parameter \texttt{cg\_Scheme=Weiss,Delta}.

To provide maximum control over the fitting process, we include several 
tunable parameters:
\begin{itemize}
\item \texttt{cg\_method=0,1} - Chooses the CG algorithm: 
\texttt{0} for a Fletcher-Reeves-Polak-Ribiere variant adapted from 
Numerical Recipes~\cite{NumRec77}, and \texttt{1} for the original 
algorithm described in Ref.\onlinecite{Georges1996RMP}, commonly used 
in the DMFT community.
\item \texttt{cg\_grad=0,1} - Sets the gradient calculation method: 
\texttt{0} for analytical gradients (when available), \texttt{1} for 
numerical gradients (required if \texttt{cg\_method=1}).
\item \texttt{cg\_Lfit} - Sets the number of Matsubara frequencies 
$L_\mathrm{fit}$ used in the fit. This can be used to restrict the 
fit to the low-frequency regime, where the function behavior is 
most relevant.
\item \texttt{cg\_Weight=0,1,2} - Determines the frequency weighting 
scheme: \texttt{0} for uniform, \texttt{1} for inverse frequency 
weighting, and \texttt{2} for inverse Matsubara index weighting, which 
can emphasize low-energy contributions.
\item \texttt{cg\_pow} - Sets the power $q$ of the cost function, 
allowing the user to fine-tune the sensitivity of the optimization 
to outliers.
\item \texttt{cg\_Ftol} - Controls the fit tolerance, setting the 
convergence threshold for the CG minimization.
\item \texttt{cg\_Niter} - Specifies the maximum number of allowed 
iterations for the CG minimization.
\item \texttt{cg\_stop=0,1,2} - Defines the exit condition of the 
minimization. The options are:
\begin{align*}
C_1 & = |\chi^{n-1} - \chi^n| < \mathtt{cg\_Ftol} (1+\chi^n), \\
C_2 & = \left\|x_{n-1} - x_n\right\| < 
\mathtt{cg\_Ftol} (1+\left\|x_n\right\|),
\end{align*}
where $\chi^n$ is the cost function at the $n^\mathrm{th}$ step, and 
$x_n$ the corresponding parameter vector. The stop condition is a 
logical OR between these criteria, with the parameter value selecting 
which condition to apply.
\end{itemize}

Together, these parameters provide precise control over the fitting 
process, allowing users to balance speed and accuracy according to 
their specific needs.

% In the DMFT context the bath needs to be optimized
% against a given realization of the Weiss field
% ${\GG^{-1}_{0}}_{\a\b\s\s'}(z)$, or the corresponding {\it hybridization} function
% $\Theta = (z + \mu)\11 - H^{loc} -\GG_0^{-1}](z)$. While the Weiss
% field is obtained from the DMFT self-consistency
% equation~\cite{Georges1996RMP}, bath discretization impose to  find an optimal
% description of the continuous Weiss field in terms of the finite
% number of parameters of the bath (see \secu{sSecBath}.
% Although different algorithms can be envisaged to perform this
% step~\cite{Garcia2004PRL,Taranto2012PRB} which are perfectly valid in
% some physical contexts.
% In order to enable the users to use their preferred 
% method in \NAME we keep the optimization implementation independent
% from the rest of the code. Yet, we offer a fully fledged optimization
% strategy based on the  conjugate gradient (CG) minimization of the cost function:
% $$
% \chi = \sum_{n=1}^{L_\mathrm{fit}}\frac{1}{W_n}||X(i\omega_n) - X^\mathrm{QIM}(i\omega_n;\{V,h\})||_q
% $$
% where the symbol $|| \cdot ||_q$ is a suitably defined $q$-norm in the
% matrix function space, $X_{\a\b}={\GG_{0}}_{\a\b\s\s'},\,\Theta_{\a\b\s\s'}$ are the user
% supplied local functions and
% $X_{\a\b}^\mathrm{QIM}=G^0_{\a\b\s\s'},\,\Delta_{\a\b\s\s'}$ the
% quantum impurity model functions, defined above.
% Notably, more sophisticated optimization algorithms have been
% recently implemented to better undertake the minimization of similar
% cost functions. However, these developments are designed to work with truncated
% algorithms, e.g. sCI or DMRG, describing systems with a larger number of
% bath levels.   
% In the ED context however, where the efficient and wise selection of
% the relatively few bath levels becomes crucial, the CG minimization of
% the local functions proved to be the most efficient and
% flexible optimization scheme so far. 

% The fit procedure is entirely wrapped by the single function {\tt
%   ed\_chi2\_fitgf} contained in the module \texttt{ED\_BATH\_FIT}.   
% In order to exploit regularity of the functions the fit is 
% performed using imaginary Matsubara frequency. 
% The actual form of $X_{\a\b\s\s'}$ is controlled by the input parameter
% \texttt{cg\_Scheme=Weiss,Delta}. 

% In order to fine tune the optimization step in \NAME\ we
% introduced a number of control parameters. To start with, we include
% two distinct CG algorithms in the library, controlled by the input variable
% \texttt{cg\_method=0,1}. The value \texttt{0} corresponds to a
% Fletcher-Reeves-Polak-Ribiere minimisation algorithm, adapted from
% Numerical Recipes~\cite{NumRec77}. Yet, in order to guarantee
% back-compatibility with respect to the past literature, we also provide the
% possibility of using the minimization procedure published in
% Ref.\onlinecite{Georges1996RMP} which has been largely used in the DMFT
% community.

% The gradient $\nabla\chi$ required by the CG algorithm can be
% evaluated either analytically or numerically as
% controlled by the value of the input parameter \texttt{cg\_grad=0,1}. For
% \texttt{cg\_method=1} only numerical gradient can be used.
% The number of Matsubara frequency $L_\mathrm{fit}$ used in the fit procedure
% is controlled  by the input parameter \texttt{cg\_Lfit}.
% This parameter can be used to restrict the fit to the low frequency
% part as the large frequency tails of the local Matsubara functions
% have universal behavior.
% Similarly, the weight  $W_n=1,1/L_\mathrm{fit},1/\omega_n$ is used to
% enhance the weight of low energy part with respect to the
% intermediate-to-large energy one in the cost function.
% This is controlled by the input parameter \texttt{cg\_Weight=0,1,2}.
% Another  factor contributing to determine the behavior
% of the fit is the power $q$ of the cost function $\chi$. By tuning
% this parameter, controlled by input variable \texttt{cg\_pow}, it is
% possible to enhance or suppress the differences in the $\chi$ in order
% to improve (or simplify) the optimization procedure.  

% Finally, we introduced few additional parameters which aim to
% control the quality of the fit. The first is the fit tolerance,
% controlled by the input parameter \texttt{cg\_Ftol}, which
% determines the convergence threshold of the minimization procedure.
% The second is the maximum number of iterations \texttt{cg\_Niter}
% allowed for the CG algorithm to determine the minimum.
% The last parameter \texttt{cg\_stop=0,1,2} selects the exit
% condition of the minimization procedure. We envisaged  three
% possible conditions: $C_1\cup C_2$, $C_1$, $C_2$ with 
% $C_1=|\chi^{n-1} -\chi^n|<\mathtt{cg\_Ftol}(1+\chi^n)$ and
% $C_2=||x_{n-1} -x_n||<\mathtt{cg\_Ftol}(1+||x_n||)$, where $\chi^n$
% is the cost function evaluated at the $n^{\rm th}$-step and $x_n$
% the corresponding argument. Increasing the value of the stop
% parameter generally loosens up the exit conditions of the minimization.   

{\bf REMARK TODO}
Notes on the norm function: a) the definition for conventional
matrices, ;b) the definition for the replica/general case where you
can choose between different norm defition.
{\color{red} I (GB) can take care of this, as I introduced the ``elemental" norm in the code.}
%GBtodo placeholder



\subsection{Input/Output}\label{sSecIO}
The \texttt{ED\_IO} module provides comprehensive access to the 
results of the Lanczos diagonalization of the quantum impurity 
problem. Since each instance of the code persists in memory until a 
new calculation is initiated, access to the relevant data is managed 
through a set of dedicated functions. These include routines for 
extracting dynamical response functions, self-energy components, and 
impurity observables, as well as for performing on-the-fly 
recalculation of the impurity Green's functions and self-energies at 
arbitrary points in the complex frequency domain. The latter 
capability is enabled through the efficient use of \texttt{gfmatrix} 
objects for data storage.

A full list of available functions, including parameter descriptions 
and usage examples, can be found in the online documentation 
Here, we highlight two representative examples:
The first is the function \texttt{ed\_get\_dens}, which populates the 
provided input array with the orbital impurity occupations 
$\langle n_{\a\s}\rangle$. This function is essential for extracting 
local density information, a key diagnostic in many DMFT studies.

The second example is \texttt{ed\_get\_sigma}, which retrieves the 
normal or anomalous components of the Matsubara or real-axis 
self-energy function $\Sigma(z)$. This function represents a central 
output of any DMFT calculation, as the self-energy encapsulates the 
full set of local electronic correlations and their frequency 
dependence.







\subsection{EDIpack2ineq: inequivalent impurities}\label{sSecIneq}
In many contexts, it is necessary to solve systems with multiple, 
independent quantum impurities. This situation frequently arises in 
DMFT when modeling lattices with complex unit cells containing 
inequivalent atomic sites, or in supercell calculations where 
translational symmetry is broken, as in heterostructures, disordered 
systems, or multiorbital setups. 

Given that \NAME allows only a single instance of the solver at a 
time, a dedicated extension is required to handle these more complex 
cases. To address this, we developed the {\tt EDIpack2ineq} 
sub-library, which extends the base functionality of \NAME by managing 
memory and procedures for multiple impurities. This approach ensures 
that all functions remain accessible through standard Fortran 
interfaces, seamlessly integrating both \NAME and {\tt EDIpack2ineq} 
without compromising overall software design.

Below, we provide a brief overview of the main features introduced by 
{\tt EDIpack2ineq}.

\subsubsection{Structure}\label{ssSecIneqStructure}
The core of the {\tt EDIpack2ineq} sub-library consists of several 
Fortran modules, all wrapped under the main interface module 
{\tt EDIPACK2INEQ}. This module provides access to the full range of 
procedures and variables required to solve inequivalent quantum 
impurity problems. To use this extension, the user must include both 
the main \NAME and the {\tt EDIpack2ineq} modules, as shown below:
\begin{lstlisting}[style=fstyle,numbers=none,basicstyle={\scriptsize\ttfamily}]
program test
  !Load EDIpack2 library 
  USE EDIPACK2 
  !Load the Inequivalent impurities extension
  USE EDIPACK2INEQ
  ...
\end{lstlisting}

A significant part of the {\tt EDIpack2ineq} extension is the 
definition of global variables that extend the memory pool of 
\NAME. This includes higher-rank arrays for storing impurity-specific 
data, ensuring that each impurity's state is maintained separately 
during the computation. While dedicated MPI communication could be 
used to manage specific objects in parallel, e.g. {\tt
  effective\_bath} or {\tt gfmatrix}, we opted for a simpler and safer  
file-based approach to maintain compatibility with the standard I/O 
procedures described in \secu{sSecIO}.


\subsubsection{Core routines}\label{ssSecIneqGlobal}
The module {\tt E2I\_MAIN} wraps the key extensions to the main 
algorithms of \NAME, including initialization, diagonalization, and 
finalization, while preserving the original function names for 
consistency. 

\paragraph{\bf Initialization} The function {\tt ed\_init} is extended to 
  accept a rank-2 bath array, where the leading dimension specifies 
  the number of inequivalent impurity problems. This ensures each bath 
  is properly initialized for subsequent diagonalization.

\paragraph{\bf Diagonalization} The function {\tt ed\_solve} also accepts this 
  rank-2 bath array and manages the diagonalization of each impurity 
  problem. Parallel execution is controlled by the input flag 
  {\tt mpi\_lanc=T/F}, which determines whether the Lanczos 
  diagonalization is performed in parallel or sequentially across 
  different impurities.

\paragraph{\bf Finalization} Memory release is handled through the extended 
{\tt ed\_finalize} function, which clears the memory pool for all 
inequivalent impurity instances.

  


\subsubsection{Inequivalent Baths}\label{ssSecIneqBath}
The bath setup for multiple impurities is managed by the 
{\tt E2I\_BATH} module, which provides functions for defining 
site-specific bath matrices and their corresponding variational 
parameters. This includes support for conventional symmetry operations 
and the handling of replica bath structures. 

In the module {\tt E2I\_BATH\_REPLICA}, we extend the 
matrix basis definition for the variational parameters 
$\vec{\lambda}$, allowing for flexible bath optimization across 
multiple sites. Although the matrix basis is currently shared among 
all impurities, future versions may allow for fully independent 
bath parameterizations.

Additionally, the {\tt E2I\_BATH\_FIT} module extends the generic 
{\tt ed\_chi2\_fitgf} function to support simultaneous, independent 
bath optimization for all impurities using MPI, thereby improving the 
efficiency of large-scale calculations.


 
\subsubsection{Input/Output}\label{ssSecIneqIO}
A key component of the {\tt EDIpack2ineq} extension is the 
enhanced I/O capability for handling impurity-specific observables. 
The {\tt E2I\_IO} module includes a variety of functions for 
retrieving site-resolved quantities, such as local Green's functions, 
self-energies, and density matrices. These functions use the same 
naming conventions as the core \NAME library, ensuring a consistent 
user experience across single and multi-impurity calculations.

\end{document}
