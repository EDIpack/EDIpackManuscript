\documentclass[edipack2.tex]{subfiles}
\begin{document}

\section{Implementation}\label{SecEDIpack}
Here we present an overview of the implementation of the
different parts of the \NAME library. 

\subsection{The quantum impurity problem}\label{sSecQIM}
We consider a general quantum impurity problem defined by the
following Hamiltonian:
$$
\hat{H} = \hat{H}_{imp} + \hat{H}_{bath} + \hat{H}_{hyb} + \hat{H}_{ph} + \hat{H}_{e-ph}
$$
which describes a  multi-orbital interacting quantum
impurity coupled to an electronic bath and to local, i.e. Holstein,
phonons. 
\begin{equation}\label{Himp}
  \begin{split}
    \hat{H}_{imp} & = \hat{H}^0_{imp} + \hat{H}^{int}_{imp}\\
    \hat{H}^0_{imp} & =
    \sum_{\a\b\sigma\sigma'}h^{0}_{\a\b\sigma\sigma'}d^{+}_{\a\sigma}d_{\b\sigma'}\\
\end{split}
\end{equation}

We assume for the moment that no particular symmetry
holds. The impurity part of the Hamiltonian can, in principle, consist of any set of
two-body quantum operators of the form $U_{ijkl}c^{\dagger}_{i}c^{\dagger}_{j}c_{l}c_{k}$.

A set of such operators is the celebrated Hubbard-Kanamori Hamiltonian: 

\begin{equation}\label{Hint}
  \begin{split}
    \hat{H}^{int}_{imp} &=U\sum_{\a}n_{\a\uparrow}n_{\a\downarrow}+U'\sum_{\a\neq \b}n_{\a\uparrow}n_{\b\downarrow}+(U'-J)\sum_{\a<\b,\sigma}n_{\a\sigma}n_{\b\sigma}\\
    &{\phantom =}- J_X\sum_{\a\neq
      \b}d^{+}_{\a\uparrow}d_{\a\downarrow}d^{+}_{\b\downarrow}d_{\b\uparrow}+J_P\sum_{\a
      \neq
      \b}d^{+}_{\a\uparrow}d^{+}_{\a\downarrow}d_{\b\downarrow}d_{\b\uparrow}\\
\end{split}
\end{equation}

where $d_{\a\sigma}$ ($d^+_{\a\sigma}$) are the destruction (creation)
second-quantization operators for impurity electrons in the
orbital $\alpha=1,\dots,N_\a$, with $N_\a$ the number of orbitals,
with spin $\sigma=\up,\dw$ and whose occupation is described
by the  operator  
$n_{\alpha\sigma}=d^{+}_{\alpha\sigma}d_{\alpha\sigma}$. 
The non-interacting internal structure of the impurity is described by
the $h^{0}_{\a\b\sigma\sigma'}$ matrix. 
$\hat{H}^{int}$ describes the  local multi-orbital
interaction~\cite{Georges2013ACMP} which, for simplicity, we take as a
generalized Hubbard-Kanamori form.  
The first three terms represent the density-density part of the
interaction, where $U$ is the local intra-orbital Coulomb repulsion,
$U'$ the inter-orbital one and $J$ the Hund's coupling~\cite{Georges2013ACMP}.  
The  remaining two terms are, respectively, the spin-exchange and
pair-hopping which we considered with their respective independent
couplings $J_X$ and $J_P$.
In the case $N_\a=3$ a fully symmetric $SU(3)_{orbital}\times SU(2)_{spin}\times
U(1)_{charge}$ form of the interaction is obtained by setting $U'=U-2J$ and
$J_X=J_P=J$~\cite{Georges2013ACMP}. Different choices, preserving part
of the combined symmetry group, can be made for other values of
$N_\a$~\cite{Georges2013ACMP}. 


The bath part and its coupling to the impurity has the form: 
\begin{equation}\label{Hbath}
  \begin{split}
    \hat{H}_{bath} &=
    \sum_p\sum_{\a\b\sigma\sigma'}h^p_{\a\b\sigma\sigma'}a^{+}_{p\a\sigma}a_{p\b\sigma'}\\
    %
    \hat{H}_{hyb} &= \sum_p\sum_{\a\b\sigma\sigma'}V^p_{\a\b\sigma\sigma'}d^{+}_{\a\sigma}a_{p\b\sigma'}+H.c. \\
\end{split}
\end{equation}
where $p=1,\dots,N_{bath}$ is an index running over a finite number of
bath elements, $a_{p\alpha\sigma}$ ($a^+_{p\alpha\sigma}$) are the destruction (creation) operators for
the bath electrons with index $p$, with orbital $\alpha$ and
spin $\sigma$.
The  properties of each bath level are described by the
matrices $h^p_{\a\b\sigma\sigma'}$. As such any bath element can be
composed of several electronic levels according the bath topology,
which will be discussed further in the following.
Each bath level couples to the impurity with an amplitude
$V^p_{\a\b\s\sigma'}$ which we allow to couple different orbital and
opposite spins.   

Finally, the electron-phonon part of the quantum impurity problems is
described by the Hamiltonian terms: 
\begin{equation}\label{Hph}
  \begin{split}
    \hat{H}_{ph}&=\sum_q \omega_{0q} b_q^+b_q\\
    % 
    \hat{H}_{e-ph} &= \sum_q\sum_{\a\b\sigma} g_{\a\b} d^+_{\a\sigma}d_{\b\sigma}(b_q+b_q^+)
\end{split}
\end{equation}
where $q=1,\dots,N_q$ indexes the number of local phonons, $b_q$
($b_q^+$) are the destruction (creation) operators for the phonon $q$
with frequency $\omega_{0q}$. The matrix  $g_{\a\b}$ expresses is the electron-phonon coupling. 
Although feasible, dealing with more than one phonon mode becomes
quickly computationally very demanding, thus in the rest of the this
work we shall consider $N_q=1$. 
In the following we consider a bath discretized into a  number
of bath degrees of freedom and a finite number of available phonons $N_{ph}$,
to cut-off the unbounded dimensions of the local phonons Hilbert space.


\paragraph{{\bf Remark}} As extensively discussed in
\onlinecite{amaricci2022}, the inclusion of local phonons with
truncated dimensions ultimately amounts to a sequential application of
the procedures defined for the electronic part, i.e. one per phonon
mode. This includes a linear scaling of the dimensions with $N_{ph}$
and of course largely limit the available degrees of freedom to
describe electronic states. In the rest of the paper we focus
specifically on the electronic part of the quantum impurity problem,
referring to the phonons in specific sections when their presence
introduces non-trivial modifications.  


More specifically, we consider a system composed of $N_{imp}=1$
impurities, i.e. a single impurity problem, $N_{bath}$ bath elements
and $N_{ph}$ phonons. The size of the system is determined by
the number of phonons (fixed) and that of {\it electronic} levels, i.e. levels with a local
electronic Hilbert space
$\HH_e=\{\ket{0},\ket{\up},\ket{\dw},\ket{\up\dw} \}$. 
Due to is internal structure, the single impurity contains
$N_i= N_\a$ electronic levels.
The total number of levels is then determined by
the electronic levels in the bath $N_b$. This is a function of the bath topology and $N_{bath}$,
i.e. the number of bath elements. In the simplest case each bath
element corresponds to an independent electronic levels coupled to the
impurity, thus $N_b\equiv N_{bath}$. 
We indicate with $N_s=N_i + N_b$ the total number of electronic levels. 

The setup of the general quantum impurity problem is implemented in
different parts of the \NAME software. The dimensions of the system
are controlled by input variables {\tt Nspin}$=N_\sigma$,
{\tt Norb}$=N_\a$ and {\tt Nbath}$=N_{bath}$ in {\tt
  ED\_INPUT\_VARS}. These are used to
determine the variables {\tt Ns}$=N_s$ and $N_b$, defined in the global
memory pool {\tt ED\_VARS\_GLOBAL}, using the functions contained
in {\tt ED\_SETUP}. 
The user can define the local non-interacting Hamiltonian
$h^0_{\a\b\s\s'}$ using the function {\tt ed\_set\_hloc} in {\tt ED\_AUX\_FUNX}.
The matrix is then stored in the internal memory and shared throughout the
code.
On the other hand the setup of the bath matrices $h^p_{\a\b\s\s'}$
requires a more involved procedure which will be illustrated in
\secu{sSecBath}. 


\subsection{The Fock basis states}\label{sSecBasis}
The Fock space of the quantum impurity problems is defined as
$\FF=\FF_e\otimes \FF_{ph}$, with $\FF_e=\bigoplus_{n=0}^{N_s}
S_-\HH_e^{\otimes n}$ the electronic Fock space,  $\FF_{ph}=\bigoplus_{n=0}^{N_q}S_+\HH_{ph}^{\otimes n}$ the
phonon Fock space,  $\HH_{ph}=\{\ket{0},\ket{1},\dots,\ket{N_{ph}}\}$ is the local phonon Hilbert space
and ($S_-$)  $S_+$ the (anti-)symmetrization operator.  
The total dimension of the Fock space is
$D=D_e\cdot D_{ph}=4^{N_s}\cdot (N_{ph}+1)$ making the exponential
growth with the number of electron levels transparent. 
The quantum states in the space $\FF$ are naturally represented in
terms of occupation number formalism of the second quantization,
i.e. the Fock basis.
For a system of $N_s$ electrons each Fock state
reads $\ket{p}\ket{\vec{n}}$ with
$$
\ket{\vec{n}}=\ket{\vec{n}_\up}{\vec{n}_\dw}=\ket{n_{1\up},\dots,n_{N_s\up},n_{1\dw},\dots,n_{N_s\dw}}
$$ 
where $p=1,\dots,N_{ph}$ is the number of local phonons while $n_{a\sigma}=0,1$ signals the absence or the
presence of an electron with spin $\sigma$ at the level $a$.
The electronic part of the Fock state $\ket{\vec{n}}$ is represented as a string of
zeros and ones of length $2N_s$. Thus, any such state can  be encoded
in a computer using a sequence of $2N_s$ bits or, analogously, as a
given integer $I=0,\dots 2^{2N_s}-1$ so that $\ket{\vec{n}}=\ket{I}$.  
Together with the basis states one defines  destruction and creation 
operators, respectively $c_{a\s}$ and $c^+_{a\s}$, which acts on the
Fock space as: 
$\ket{\vec{n}}$ as:  
\begin{align*}
  c_{a\sigma}\ket{\vec{n}} &=
    \begin{cases}
      (-1)^{\#_{a\sigma}}\ket{\dots,n_{a\sigma}\!-\!1,\dots}
      &\text{if $n_{a\sigma}\!=\! 1$}\\
      0 &\text{otherwise}
    \end{cases};\qquad
    c^{+}_{a\sigma}\ket{\vec{n}} &=
     \begin{cases}
      (-1)^{\#_{a\sigma}}\ket{\dots,n_{a\sigma}\!+\!1,\dots}
      & \text{if $n_{a\sigma}\!=\! 0$}\\
      0 & \text{otherwise}
    \end{cases}    
\end{align*}
where $\#_{a\sigma}=\sum_{b\sigma'<a\sigma} n_{b\sigma'}$ takes care
of the fermionic sign imposed by Pauli principle. 

The Fock states and operators implementation can be found in {\tt
  ED\_AUX\_FUNX}. There we define the bitwise action of generic fermionic creation
and annihilation operators {\tt CDG} and {\tt C}, the binary
decomposition {\tt bdecomp} required to reconstruct the Fock state as
bits sequence and other accessory functions. 

\subsection{Conserved quantum numbers}\label{sSecQNs}
In order to circumvent the exponential scaling of the dimensions of
the problem scales it is necessary to take into account suitable symmetries.
Indeed, considering operators ${\cal Q}$ such that $[H, {\cal Q}]=0$
reduces of the Fock space into several symmetry sectors
labelled by given quantum numbers $\vec{Q}$. 
In the context of quantum impurity problems two symmetries are often considered: i)
conservation of the total occupation $N$ and ii) the
conservation of the total magnetization $S_z$. Although the total spin
operator $S^2$ can also be conserved, the difficult  implementation
and the marginal gain makes it often non convenient to include this symmetry.
In \NAME we consider three different cases which are controlled by the
input variable {\tt ed\_mode}={\bf normal}, {\bf superc}, {\bf
  nonsu2}. 

The {\bf normal} case deals with independent conservation of the total occupation $N$
and the total magnetization $S_z$ or, equivalently, the total number of electrons with spin up $N_\up$ and down
$N_\dw$. Optionally, we consider the case in which the symmetry
applies separately for each orbital and spin,
i.e. $\vec{N_\s}=[N^1_\s,\dots,N^{N_\a}_\s]$. This special case has been
extensively discussed in \onlinecite{Amaricci2022} so it won't be covered in
this work.
%
The {\bf superc} case deals with the conservation of the total
magnetization only, so that total charge may not be conserved. This
case includes a description of $s$-wave superconductivity, featuring
intra- and inter-orbital components.
%
Finally, the {\bf nonsu2} case consider the conservation of the total
charge, whereas the spin symmetry group is not fully
conserved. Although there many possible realization of this scenario,
this particularly applies to the presence of local spin-orbit coupling
$\vec{L}\cdot\vec{S}$~\cite{something}, the emergence of in-plane spin ordering~\cite{KM} or
in-plane spin-triplet exciton condensation~\cite{ExcitonPRB,Amaricci,Blason}.  
%
From a computational point of view the construction of a symmetry
sector corresponds to the determination of a injective map
$\MM:\SS_{\vec{Q}}\rightarrow \FF$ relating the states $\ket{i}$
belonging to the sector $\SS_{\vec{Q}}$ to the states $\ket{I}$ in the
Fock space. Operatively, the map corresponds to an integer rank-1
array of dimension $D_\SS$ which is the {\it dimension} of the
sector. 
The table~\ref{TabSector} summarizes the properties of the symmetry
sectors. 

\begin{table}%[ht]
  \label{TabSector}
\begin{center}
\begin{tabularx}{\linewidth}{ |X|X|X| } 
 \hline
  {\tt ed\_mode} & {\it Quantum Numbers} & {\it Sector Dimension} \\
  \hline
  {\bf normal} & $[N,S_z]\equiv[N_\up,N_\dw]$ &
                                                $\binom{N_s}{N_\up}\binom{N_s}{N_\dw}$
  \\
  \hline
  {\bf superc} & $S_z\equiv N_\up-N_\dw$ &  $\sum_m 2^{N_s-S_z-2m}\binom{N_s}{N_s-S_z-2m}\binom{S_z+2m}{m}$
  \\
  \hline
  {\bf nonsu2} & $N \equiv[N_\up+N_\dw$ & $\binom{2N_s}{N}$ \\ 
 \hline
\end{tabularx}
\end{center}
\caption{Ciao}
\end{table}


The {\bf normal} case requires a brief remark. Because of the
independent conservation of $N_\up$ and $N_\dw$, the local Hilbert
space and the electronic Fock can be factorizes as, respectively,
$\HH=\HH_\up\otimes\HH_\dw$, $\FF_e = \FF_{e\up}\otimes \FF_{e\dw}$.  
Accordingly any Fock state is written as $\ket{\vec{n}_\up}\ket{\vec{n}_\dw}$, the symmetry sector can be written as  $\SS_{\vec{Q}} = \SS_{N_\up}\otimes
\SS_{N_\dw}$ and, correspondingly, the sector map splits in two
mutually exclusive ones $\MM = \MM_\up
\otimes \MM_\dw$.
Thus, each state $\ket{i}=\ket{i_\up}\ket{i_\dw}$ of the
sector is labelled by two integers $[i_\up,i_\dw]$, 
$i_\sigma=1,\dots,D_{\SS_\sigma}$ such that $i=i_\up + i_\dw
D_{\SS_\dw}$. The map $\MM$ connects any such state to a Fock state
$\ket{I}=\ket{I_\up}\ket{I_\dw}$ labelled by two integers
$[I_\up,I_\dw]$ as $I=I_\up +   I_\dw 2^{N_s}$. For a thorough
discussion about Fock basis organization in this case see
\onlinecite{amaricci2022}. 

The presence of a symmetry induces a factorization of the Fock space,
in turn inducing a block diagonal form to the Hamiltonian matrix.
Each block, labelled by the quantum numbers $\vec{Q}$, has dimension
$D_{\SS(\vec{Q})}$. The sector Hamiltonian matrix $H_\SS$ is represented in the
basis $\ket{i}\in\SS_{\vec{Q}}$ as a sparse matrix. In the {\bf
  normal} case $H_\SS$ takes a particularly symmetric form thanks to
the product structure of the sector and its map~\cite{amaricci2022}.
The analysis of the spectrum is then reconducted to the inspection of
the Hamiltonian in each symmetry sector. Should particular constraint
holds the search can be limited to only particular sector, further
reducing the computational cost. 

Although the sectors have dimensions much smaller than the full Fock
space, for large systems storing the Hamiltonian matrix in the memory
can still be highly inefficient.
In such cases, Krylov or Lanczos methods~\cite{Lanczos1950JRNBSB,Lin1993CIP,Lehoucq1998,Maschhoff1996} can
be implemented using a storage-free algorithm, performing the
necessary linear operations on-the-fly.
This solution has generally a negative impact on the execution
time, however this can be well compensated by scaling in a distributed 
parallel framework.


The object {\tt sector}, defined globally in {\tt
  ED\_VARS\_GLOBAL}, contains all the informations characterizing the
symmetry sector, its dimensions, its quantum numbers and an
implementation of the map $\MM$. The constructor/destructor are defined {\tt
  ED\_SECTORS} module with the function {\tt build\_sector}/{\tt
  delete\_sector} using different algorithms according to the nature
of the quantum numbers $\vec{Q}$ as reported in the following code
snippet.
\setbox0=\hbox{%
  \begin{minipage}{0.3\linewidth}
    \center{\bf normal}
\begin{lstlisting}[style=fstyle,frame=none,numbers=none,basicstyle={\scriptsize\ttfamily}]
i=0
do Iup=0,2**Nbit-1     
  nup_ = popcnt(Iup) 
  if(nup_ /= Nups(1))cycle
  i = i+1
  H(iud)%map(i) = lup
enddo
i=0
do Idw=0,2**Nbit-1
  ndw_= popcnt(Idw)
  if(ndw_ /= Ndws(1))cycle
  i = i+1
  H(iud+Ns)%map(i) = Idw
enddo
\end{lstlisting}
\end{minipage}
}
\savestack{\listingA}{\box0}

\setbox0=\hbox{%
  \begin{minipage}{0.3\linewidth}
    \center{\bf superc}
\begin{lstlisting}[style=fstyle,frame=none,numbers=none,basicstyle={\scriptsize\ttfamily}]
i=0
do Idw=0,2**Ns-1
  ndw_= popcnt(idw)
  do Iup=0,2**Ns-1
    nup_ = popcnt(iup)
    sz_  = nup_ - ndw_
    if(sz_ /= self%Sz)cycle
    i=i+1
    self%H(1)%map(i) = &
        Iup+Idw*2**N
  enddo
enddo

\end{lstlisting}
\end{minipage}
}
\savestack{\listingB}{\box0}

\setbox0=\hbox{%
  \begin{minipage}{0.3\linewidth}
    \center{\bf nonsu2}
\begin{lstlisting}[style=fstyle,frame=none,numbers=none,basicstyle={\scriptsize\ttfamily}]
i=0
do Idw=0,2**Ns-1
  ndw_= popcnt(Idw)
  do Iup=0,2**Ns-1
    nup_ = popcnt(Iup)
    nt_  = nup_ + ndw_
    if(nt_ /= self%Ntot)cycle
    i=i+1
    self%H(1)%map(i) = &
        Iup+Idw*2**Ns
  enddo
enddo
\end{lstlisting}
\end{minipage}
}
\savestack{\listingC}{\box0}

\begin{tabular}{c|c|c}\label{list1}
  \stackinset{l}{}{t}{}{}{\listingA} &
\stackinset{l}{}{t}{}{}{\listingB} &
\stackinset{l}{}{t}{}{}{\listingC} \\
\end{tabular}
%
Alongside these definitions, this module additional functions to
retrieve sector index or quantum number informations. Another set of
key functions concern the application of arbitrary linear combinations
of Fock operators  to a given vector $\ket{v}\in\SS$, i.e.
$\OO\ket{v} = \sum_i a_i C^{\dagger(p_i)}_{\a_i,\s_i}\ket{v}$ with
$a_i\in\CCC$ and $p_i=0,1$. These important operations which depend on
the sector informations are implemented
in the {\tt apply\_op\_C}, {\tt apply\_op\_CDG}, {\tt
apply\_Cops} functions within {\tt ED\_SECTORS}. 



\subsection{Interaction setup}
\NAME offers two distinct ways to setup the interaction term in \equ{Himp}. 
The Hubbard-Kanamori interaction \equ{Hint} is supported natively, via the user-accessible
variables {\tt ULOC}$=U$, {\tt UST}$=U^{'}$, {\tt JH}$=J$, {\tt JX}$=J_{x}$ and {\tt JP
}$=J_{p}$.These parameters can be specified in the input file, and they will be read and 
set if the flag {\tt ED\_USE\_KANAMORI} is set to {\tt T}. This is the default option.
If the interaction Hamiltonian is provided via {\tt ED\_USE\_KANAMORI}, {\tt NORB} is limited to a maximum of {\tt 5}.

Alternatively, the list of two-body operators can be provided by the user in a properly
formatted text file, the name of which is specified in the {\tt UMATRIX\_FILE} input variable. The file has to have the suffix {\tt \\.restart}.
Such file needs to be formatted in the following way

\begin{lstlisting}[style=mybash]
NORB BANDS
i1 j1 k1 l1 U_i1j1k1l1
i2 j2 k2 l2 U_i2j2k2l2
...
\end{lstlisting}

where {\tt NORB} is the numer of orbitals. Empty lines and lines starting with {\tt \#, \%, !} are ignored. Notice the swapped indices in the coefficient with respect to the standard 2-body operator formulation $U_{ijkl}c^{\dagger}_{i}c^{\dagger}_{j}c_{l}c_{k}$. To enable reading an interaction matrix file, the flag {\tt ED\_READ\_UMATRIX} needs to be set in the input file. {\tt ED\_READ\_UMATRIX} and {\tt ED\_USE\_KANAMORI} are mutually exclusive, but they can be both false.
Before the impurity problem is solved, the used can also provide interaction terms in the program or script. Extensive documentation is available at (\textcolor{red}{how should we do this?})
All the interaction operators used in each call of the solver are listed and written in an output file. called {\tt UMATRIX\_FILE.used}.

\subsection{Classes}
The use of suitable objects enormously simplifies the  implementation
of crucial mathematical concepts aking to the diagonalization of the
quantum impurity problems. Here we discuss three main classes which
are used in the code.    

\subsubsection{Sparse matrix}\label{CodeSparseMatrix}
A sparse matrix storage is performed using a
dedicated custom class, contained in the \texttt{SPARSE\_MATRIX} module. 
The class defines a \texttt{sparse\_matrix\_csr} object as a 
simplified hash-table. The keys corresponds to the rows of the matrix
while the value is associated to a pair dynamical arrays, containing values and
columns location of the non-zero elements of the sparse matrix.
The \texttt{sparse\_matrix\_csr} object can be stored either serially,
i.e. one copy per process, or be parallel distributed assigning a number of keys/values to each
process.
The elements are progressively stored in the dynamic arrays using
\texttt{sp\_insert\_element} procedure, ultimately making use of the Fortran intrinsic
\texttt{move\_alloc}.
This ensures a faster execution compared to implicit  
reallocation, i.e. \texttt{vec=[vec,new\_element]}.
This solution enables to deal with the a priori unknown number of
non-zero elements on each row, to optimize the memory footprint and
to guarantee $O(1)$ access  to any element of the matrix, which are
crucial aspect to speed-up the execution of the MVP. 

\subsubsection{Sparse map}\label{CodeSparseMap}
As it will be evident in the following \secu{sSecRDM}, there are cases in
which the sector construction requires to store, for any sector state,
disjoint information about the corresponding Fock state.
Let's consider a Fock state $\ket{I}$. Its bit decomposition
$\ket{\vec{n}}$ can be further split into chunks of bit corresponding,
for instance to impurity and bath degrees of freedom as 
$\ket{\vec{n}}=\ket{\vec{i}_\up\,\vec{b}_\up\,\vec{i}_\dw\,\vec{b}_\dw}$.  
The module {\tt ED\_SPARSE\_MAP} implements an hash-table {\tt
  sparse\_map}, which is included as an element in the {\tt sector} object and  
which stores  for every impurity configurations $\vec{i}_\s$ (key) the
bath states $\vec{b}_\s$ (values) corresponding to it.
The {\tt sparse\_map} ${\cal S}$ elements are constructed upon call in {\tt
  build\_sector} for any value of {\tt ed\_mode} using different
algorithms.
In the {\bf normal} case, the sector object contains two {\tt
  sparse\_maps} ${\cal S}_{\s=\up,\dw}$, in line with the
spin dependent factorization of the Fock and sector states: 
$\ket{J}=\ket{J_\up}\otimes\ket{J_\dw} \xleftarrow{\MM}
\ket{j_\up}\otimes\ket{j_\dw}=\ket{j}$.
The sparse maps are build as follows. 
For any spin state $\ket{J_\s}=\ket{{vec{i}_{\s}\vec{b}_{\s}}$ of the sector
the key is determined by the integer $I_\s$ corresponding to the
impurity bit set $\vec{i}_\s$. The values are given by any 
integer $B_\s$ corresponding to any bath bit set
$\vec{b_\s}$ associated with $\vec{i}_\s$.
Thus, any given combination of key-value
reconstructs an integer $J_\s$ representing the Fock states in the
given spin sector according to the rule $J_s = I_\s +
2^{N_{imp}}B_\s$, where $N_{imp}$ is the number of impurity bits. 

In the {\bf superc/nonsu2} case the construction of the unique sparse
map is similar. For any Fock state $\ket{J}$ corresponding to sector
state $\ket{j}$ we consider the four integers $I_\up, B_\up, I_\dw,
B_\dw$ corresponding, respectively, to the bit sets
$\vec{i}_\up,\vec{b}_\up,\vec{i}_\dw,\vec{b}_\dw}$ decomposition the
state. These integers fulfill the relation
$
J =I_\up +  B_\up2^{N_{imp}} + (I_\dw +  B_\dw2^{N_{imp}})2^{N_s}
$
To obtain a contiguous memory pattern we define as a key of the sparse
map the combination $I_\up + I_\dw2^{N_{imp}}$ and as corresponding
  values the integer $B_\up + B_\dw2^{N_b}$. Where needed the correct
  bit sets and Fock state can be reconstructed with simple algebra at
  no additional cost.   



\setbox0=\hbox{%
  \begin{minipage}{0.5\linewidth}
    \center{\bf normal}
\begin{lstlisting}[style=fstyle,frame=none,numbers=none,basicstyle={\scriptsize\ttfamily}]
i=0
do Iup=0,2**Nbit-1     
  nup_ = popcnt(Iup) 
  if(nup_ /= Nups(1))cycle
  i=i+1 
  !...
  iImp  = ibits(iup,0,Norb)
  iBath = ibits(iup,Norb,Norb*Nbath)
  call sp_insert_state(self%H(1)%sp,iImp,iBath,i)
enddo
i=0
do Idw=0,2**Nbit-1
  ndw_= popcnt(Idw)
  if(ndw_ /= Ndws(1))cycle
  i=i+1 
  !...
  iIMP  = ibits(idw,0,Norb)
  iBATH = ibits(idw,Norb,Norb*Nbath)
  call sp_insert_state(self%H(2)%sp,iImp,iBath,dim) 
enddo
\end{lstlisting}
\end{minipage}
}
\savestack{\listingA}{\box0}

\setbox0=\hbox{%
  \begin{minipage}{0.5\linewidth}
    \center{\bf superc/nonsu2}
\begin{lstlisting}[style=fstyle,frame=none,numbers=none,basicstyle={\scriptsize\ttfamily}]
i=0
do Idw=0,2**Ns-1
  ndw_= popcnt(idw)
  do Iup=0,2**Ns-1
    nup_ = popcnt(iup)
    !superc 
    sz_  = nup_ - ndw_
    if(sz_ /= self%Sz)cycle
    !nonsu2 
    !nt_  = nup_ + ndw_
    !if(nt_ /= self%Ntot)cycle 
    i=i+1 
    !...
    iImpUp  = ibits(iup,0,Norb)
    iImpDw  = ibits(idw,0,Norb)
    iBathUp = ibits(iup,Norb,Norb*Nbath)
    iBathDw = ibits(idw,Norb,Norb*Nbath)
    iImp    = iImpUp  + iImpDw*(2**Norb)
    iBath   = iBathUp + iBathDw*(2**(Norb*Nbath))
    call sp_insert_state(self%H(1)%sp,iImp,iBath,dim)
  enddo
enddo

\end{lstlisting}
\end{minipage}
}
\savestack{\listingB}{\box0}

\begin{tabular}{c|c}\label{list2}
  \stackinset{l}{}{t}{}{}{\listingA} &
\stackinset{l}{}{t}{}{}{\listingB} 
\end{tabular}
%



  

  
\subsubsection{Eigenspace}\label{CodeEigenspace}
The module \texttt{ED\_EIGENSPACE} implements a list
storing for the eigenvalues and eigenvectors of the quantum impurity
Hamiltonian. 
This class defines the object \texttt{sparse\_espace}, an  
ordered linked list storing the eigenvalue (the sorting key), the
eigenvector and the corresponding QNs. To save memory the eigenvectors
are automatically distributed to all processors in shares of the right
size according to the nature of the quantum numbers $\vec{Q}$. 

For zero temperature calculations only the groundstates (with degeneracies) are stored
in the list.
For a finite temperature the excited states need to be stored too.
In order to avoid unbounded growth of the list we adopt an 
truncation mechanism. In the first call we collect a number 
\texttt{lanc\_nstates\_sector} of states from each sector, up to a
given maximum number \texttt{lanc\_nstates\_total}, both set on input.  
The list is truncated by keeping the states which
fulfil the condition $e^{-\beta(E_i-E_0)} < \mathtt{cutoff}$, where
$E_i$ is the energy of the $i^{\rm th}$ state in the list, $E_0$ is the
groundstate energy,  $\beta=1/T$ is the inverse temperature ($k_B=1$) and \texttt{cutoff}
is an input parameter fixing an a priori energy threshold.
%  
Annealing is achieved by successive diagonalization of the problem.
The numbers of states required to any sector $\SS$ contributing to the list is increased by
\texttt{lanc\_nstates\_step} or it is reduced otherwise. After few calls
(of the order of ten) the distribution among the sectors of the
numbers of states reaches a steady state.
The corresponding annealed list contains all and just the states
contributing to the spectrum up to the required energy threshold.
A histogram of the number of states for each sector is produced after
each diagonalization to check the evolution of their distribution.



\subsubsection{GFmatrix}
One of the main goal of the code is to evaluate dynamical correlations
functions (DCF) $\ibra \TT[ A(t) A^+ ]\iket$. As we shall see in the following, using Krylov method it is
possible to express the dynamical correlations in terms of a suitably
truncated Kallen-Lehmann spectral sum of the form
$\tfrac{1}{Z}\sum_n e^{-\beta E_n} \sum_{m=1}^{N} \tfrac{|w_{mn}|^2}{ z
  - dE_{mn}}$ where $w_{mn}$ is a weight set by the 
projection of the $m^{\rm th}$ eigenstate onto the $n^{\rm th}$
component of the Krylov basis (which reduce the sector Hamiltonian
into a partial tri-diagonal form) while $dE_{mn}=E_m-E_n$ is an excitation energy. 
The {\tt ED\_GFMATRIX} module contains a class which efficiently store all
the {\it weights} $w_{mn}$ and {\it poles} $dE_{mn}$ contributing to
a specific correlation function. Specifically, the {\tt
  gfmatrix} object implements a dynamical multi-layer data structure
storing any DCF as the set of all the weights and poles,
from any contributing eigenstate  and for any
combination of operators appearing in its definition.
The use of this class enables the istantantaneous evaluation of a
given  DCF  $\GG(z)$ for any $z\in\CCC$ the complex frequency plane
using a suitable compressed form. 
  
\subsection{Bath parametrization}\label{sSecBath}
The bath parametrization is a key feature in determining the properties
of the quantum impurity problem.
Following the structure of Eq.~\ref{Hbath} the bath can be
parametrized by two terms: the Hamiltonian matrices $h^p$ and the
amplitudes $V^p$, for $p=1,\dots,N_{bath}$.
Internally, the bath is represented by a dedicated object {\tt
  effective\_bath} defined in {\tt ED\_VARS\_GLOBAL}. 
On the
user side all parameters are packed into a rank-1 array of
doubles handled using reverse communication strategy.
This ensures that a local array is always conserved by the user, while
it prevents direct access to the internal copy.


The bath topology, i.e. the links between the $N_b$ electronic levels
assigned to the bath, is determined by the input variable {\tt
  bath\_type} among 4 different choices: {\bf normal}, {\bf hybrid},
{\bf replica} and {\bf general} (see Fig.\ref{figBaths}).  
%
\paragraph{{\tt bath\_type}={\bf normal}} The bath is formed out of $N_{bath}$
electronic levels coupled to each of the impurity orbital. The total
count of bath levels is $N_b = N_\a N_{bath}$. The bath Hamiltonan
matrices include a parametrization diagonal in the orbital and spin space: 
$h^p_{\a\b\s\s'}=\varepsilon_{\a\s}\delta_{\a\b}\delta_{\s\s'}$.
If {\tt ed\_mode}={\bf superc} one needs to account for anomalous
amplitudes connecting bath levels with opposite spins. So we consider
an additional set of parameters, diagonal in orbital space but
off-diagonal in the spins:
$h^p_{\a\b\s\s'}=\Delta^p_{\a}\delta_{\a\b}\delta_{\s \overline{\s}}$.
This choice corresponds to consider, for every orbital component,
bath matrices with the following structure in the Nambu space:
$\hat{h}^p_{\a\b} = \e_{\a}\delta_{\a\b}\tau_0 +
\Delta_{\a}\delta_{\a\b}\tau_x$. 
The hybridization amplitudes between the impurity and the bath levels
include, for any value of {\tt ed\_mode} a set of parameters diagonal in both
spin and orbital space: $V^p_{\a\b\s\s'}=V^p_{\a\s}\delta_{\a\b}\delta_{\s\s'}$.
If {\tt ed\_mode}={\bf nonsu2} the an additional set including terms
describing spin-flip processes (as total magnetization is not
conserved) should be included $V^p_{\a\b\s\s'} =
W^p_{\a}\delta_{\a\b}\delta_{\s \overline{\s}}$. 



\paragraph{{\tt bath\_type}={\bf hybrid}} The bath is formed out of
$N_{bath}$ coupled to all the impurity levels, correspondingly
$N_b\equiv N_{bath}$ is the total count of electronic bath levels. 
The main parametrization of the bath Hamiltonian matrices is still
diagonal in both orbital and spin space, i.e.
$h^p_{\a\b\s\s'}=\varepsilon_{\a\s}\delta_{\a\b}\delta_{\s\s'}$.
As for the previous case, the {\bf superc} mode requires the inclusion
of a further set of parameters taking care of the anomalous components:
$h^p_{\a\b\s\s'}=\Delta^p_{\a}\delta_{\a\b}\delta_{\s
  \overline{\s}}$.
The key difference with respect to the {\bf normal} case lies in the
off-diagonal nature of the hybridization amplitudes:
$V^p_{\a\b\s\s'}=V^p_{\a\b\s}\delta_{\s\s'}$. If total magnetization
is not conserved, i.e. for {\tt ed\_mode}={\bf nonsu2}, an additional
set of parameters should be included to describe spin-flip processes:
$V^p_{\a\b\s\s'} = W^p_{\a\b}\delta_{\s \overline{\s}}$. 
These sets of hybridization parameters allow to capture the effects of locally
hybridized impurity orbitals. This comes at the cost of a
slightly harder optimization process (see \secu{sSecFit}) specially
for systems with reduced number of available bath levels with respect
to the impurity. 

\paragraph{{\tt bath\_type}={\bf replica}/{\bf general}} A more flexible
parametrization of the bath is represented by this topology. The
original idea of this approach is to give to each bath element a structure which {\it replicates}
that of the impurity while keeping a diagonal coupling between bath
elements and impurity. This offloads the difficulties related to the
representation and optimization of strucured quantum impurities to the
bath Hamiltonan rather than the hybridizations.
Taking a sligthly more general point of view we consider a user
defined matrix basis $\vec{\Gamma}=\{ \Gamma^\nu_{\a\b\s\s'} \}_{\nu=1,\dots,N_{sym}}$ in the (Nambu-)spin-orbital
space and parametrize any bath Hamiltonian as:
$$
h^p = \sum_{\nu=1}^{N_{sym}} \lambda^p_\nu
\Gamma^\nu\equiv \vec{\lambda}^p\cdot \vec{\Gamma}
$$
where $\vec{\lambda}^p\in\RRR^{N_{sym}}$ is a vector of variational parameters. 
The choice of the matrix basis can be inspired either by the internal structure
of the quantum impurity, i.e. $\hat{h}^0$, or be determined
case-by-case by the properties of the problem.
The total number of electronic levels used to describe the bath is in
this case: $N_b = N_{sym} N_{bath}$. 
For the {\bf replica}  topology the coupling between the impurity and
each bath elements is diagonal in the spin, orbital and internal bath
structure: $V^p_{\a\b\s\s'} = V^p$. The
{\bf general} setup introduces a generalization introducing a
dependence on the internal spin and orbital indices: $V^p_{\a\b\s\s'}
= V^p_{\a\s}\delta_{\a\b}\delta_{\s\s'}$. 


All the procedures concerning the bath, either on the user side or the
internal {\tt effective\_bath}, are grouped into a set of modules
wrapped by {\tt ED\_BATH}.
We divided the set of modules in three categories, according to their
scope.
\paragraph{Bath Auxiliary Tools}
This part contains some functions directed to the user as, for
istance, the implementation of suitable conventional symmetry
operations acting on the user bath array like, e.g., orbital symmetry,
particle-hole symmetry, etc. found in {\tt ED\_BATH\_USER}
However, the key functions of this group concerns the determination
of the total dimension of the user bath array in {\tt ED\_BATH\_DIM}.
Starting from the values
of some input variables the function {\tt ed\_get\_bath\_dimension}
returns the dimension $B$ to which the  user should allocate the bath
array to contains all and just the bath parameters. Any following call
to functions hosting the bath as an input will check that the user supplied
bath array has the correct dimensions compared to the value of $B$
using {\tt check\_bath\_dimension}. 

\paragraph{Bath Replica (General)}
The module {\tt ED\_BATH\_REPLICA} implements the class {\tt Hreplica}
for the  the {\bf replica} ({\bf general}) bath parametrization. Beside the
conventional operations of object construction, destructin, reading
and saving the module includes the matrix basis $\{ \Gamma^\nu
\}_{\nu=1,\dots,N_{sym}}$ and variatinal parameters 
$\vec{\lambda}^p$ setup, i.e. {\tt set\_Hreplica} ({\tt
  set\_Hgeneral}) as well as a dedicated function to build  the bath Hamiltonian $h^p =
\vec{\lambda}^p\cdot \Gamma$ in {\tt build\_Hreplica} ({\tt
  build\_Hgeneral}).


\paragraph{Effective Bath}
The module {\tt ED\_BATH\_DMFT} implements a class for the object {\tt
  effective\_bath} (already defined in {\tt ED\_VARS\_GLOBAL}). This
data structure contains and handles all the actual parameters of the
bath, for any choice of {\tt ed\_mode} and {\tt bath\_type},
referencing the class {\tt Hreplica} only for the {\bf
  replica/general} bath topology.
A global instance of the class {\tt dmft\_bath}  containing the
current bath parameters is shared throughout the code.   
The class constructor is supplemented with a specific procedure initializing
the effective bath {\tt init\_dmft\_bath} which guess the bath
parameters or read them from a file specified by the input variable {\tt
  Hfile}.
The class also contains procedures to transform the instance
{\tt dmft\_bath} to/from the user bath array: {\tt
  get/set\_dmft\_bath}.





% \begin{table}%[ht]
%   \label{TabBath}
% \begin{center}
% \begin{tabularx}{\linewidth}{ |X|X|X|X| } 
%   \hline
%   c  & {\bf normal} & {\bf superc} & {\bf  nonsu2} \\
%   \hline
%   {\bf normal} $[N_b\!=\!N_{bath}N_\a]$ & $\vec{\e}[N_b],\vec{V}[N_b]$ 
%                     & $\vec{\e}[N_b], \vec{\Delta}[N_b],\vec{V}[N_b]$
%                                    &  $\vec{\e}[N_b], \vec{V}[N_b],\vec{W}[N_b]$ \\
%   \hline
%   {\bf hybrid} $[N_b\!=\!N_{bath}N_\a]$ & $\vec{\e}[N_{bath}],\vec{V}[N_b]$ 
%                     & $\vec{\e}[N_{bath}], \vec{\Delta}[N_{bath}],\vec{V}[N_b]$
%                                    &  $\vec{\e}[N_{bath}], \vec{V}[N_b],\vec{W}[N_b]$ \\
%   \hline
%   {\bf replica} $[N_b\!=\!N_{bath}N_{sym}]$ & \multicolumn{3}{*{\hat{h} } \cr
%   \hline
%   {\bf general} $[N_b\!=\!N_{bath}N_{sym}]$ & \cline{2-4} & b&  c  \cr
%   \hline
% \end{tabularx}
% \end{center}
% \caption{Ciao}
% \end{table}

\subsection{Lanczos based Diagonalization}\label{sSecHam}
In presence of symmetries (see \secu{sSecQNs}) the matrix representing
the Hamiltonian operator $\hat{H}$ takes a block diagonal form. Each block
contains the Hamiltonian matrix $H_{\SS_{\vec{Q}}}$ for a
given symmetry sector with quantum number $\vec{Q}$.
The analysis of the energy spectrum of the quantum impurity problems
thus reduces to the sequential solution of the sector secular problem
$$
H_{\SS_{\vec{Q}}}\ket{v}=E_{\SS_{\vec{Q}}}\ket{v}.
$$

Although the dimension of any such sector $\SS$ are much smaller than the
total Fock space dimension $D_\SS \ll D_\FF$ still the complete solution of
the related eigenvalue problem represents an unsurmountable problem
already with $N_s\simeq 8$. 
In order to outwit this issue a number of
algorithms have been developed leveraging on the sparse nature of
$H_\SS$, e.g. Krylov or similar sub-space methods \cite{Lanczos,Arnoldi,Feast}.   
In \NAME the alghoritm of choice is P-ARPACK, which represents the
state-of-the-art Lanczos-based eigensolver with distributed memory
support~\cite{P-Arpack}. This method includes re-orthogonalization
within a block Lanczos algorithm which ensures convergence of the
requred eigenpairs. Using the input variable {\tt lanc\_method} it is
however possible to select a simple, but not as efficient, parallel
Lanczos algorithm.
The core of Krylov-based diagonalization algorithms is the Matrix-Vector Product
(MVP), i.e. the application of the Hamiltonian to a given input
vector:
$$
H_\SS \ket{v} \to \ket{w}\qquad \ket{v},\ket{w}\in \SS_{\vec{Q}}
$$

This operations easily takes over more than 80\% of the computation
time, so its optimization is a crucial aspect in any diagonalization
algorithms. In \onlinecite{amaricci2022} we covered in full details
some distrubuted memory massively parallel algorithms to address this
specific issue.
Here, using the same naming convention introduced in \cite{amaricci}, 
we briefly outline the main strategy for the implementation of the MVP
according to the value of {\tt ed\_mode}.


\paragraph{{\bf normal}}
This case relies on the tensor structure of the Fock space and the
symmetry sectors. In any given sector the electronic part of the
Hamiltonian matrix reads:
\begin{equation}
H_\SS = H_d  + H_\up\otimes \mathbb{I}_\dw + \mathbb{I}_\up\otimes
H_\dw + H_{nd}\,.
\label{HssNormal}
\end{equation}
where $H_d$ is a diagonal term containing the local part of the
Hamiltonian, there including the density-density terms of the
interaction,  $H_\sigma$ describes the hopping processes of the
electrons with spin $\sigma=\up,\dw$.
The term $H_{nd}$ contains all the remaining non-diagonal
elements which do not fit in the previous two components,
e.g. the spin-exchange and pair-hopping interaction terms.
Correspondingly, the any sector state $\ket{v}$ can be expressed in a matrix
basis $\hat{v}$ with rows (columns) running over spin $\up$ ($\down$)
configurations. Leveraging on this setup it is possible the MVP using the 
{\tt MPI\_All2AllV} which aims at optimizing locality in the memory
locality. Additional terms contained in $H_{nd}$ are treated using the
{\tt MPI\_AllGatherV} algorithm which includes a slight communication
overload ultimately reducing the parallel efficiency.  


\paragraph{{\bf superc/nonsu2}}
In this two cases the symmetry enforce a specific relation between $\up$ and
$\dw$ configurations ultimately suppressing the benefits arising from
Fock space factorization.
The electronic part of the Hamiltonian matrix is usually organized in this structure:
$$
H_\SS = H_{imp} + H_{int} + H_{bath} + H_{imp-bath} 
$$
where, with almost obvious meaning of the labels, $H_{imp}$ encodes
the non-interacting part of the impurity Hamiltonian determined by
$h^0_{\a\b\s\s'}$, $H_{int}$ the interaction term, $H_{bath}$ the
effective bath terms related to $h^p_{\a\b\s\s'}$ and finally
$H_{imp-bath}$ describes the coupling between impurity and bath
proportional to $V^p_{\a\b\s\s'}$. 
In an MPI setup the first three terms contains elements local in the
memory of each node. These are stored separately from the non-local
ones in any {\tt sparse\_matrix} representing $H_\SS$. 
The MVP is carried out using the {\tt MPI\_AllGatherV} algorithm
which, as discussed in \onlinecite{amaricci2022}, requires the
reconstruction of the distributed input array any node producing a
overflow in the MPI communication.  



The diagonalization procedure is divided in two main steps: a global
setup and the actual diagonalization.
%
The setup step takes care of allocating the required memory,
setup the MPI environment and allocate the correct 
Matrix-Vector Product (MVP) procedure according to the symmetries of
the problem. 
This part is implemented in a set of independent modules  {\tt
  ED\_HAMILTONIAN\_?}, where {\tt ed\_mode=?}.
Specifically, any such module includes two functions.
The first, {\tt  build\_Hv\_sector\_?}, builds the required sector and
allocate the MVP function, i.e. point the abstract function {\tt
  sphtimesv\_p} to the correct procedure determined by the value of
{\tt ed\_sparse\_H=True/False}.
If {\tt True} the Hamiltonian terms in $H_\SS$
get evaluated and stored in a {\tt sparse\_matrix} instance, possibly
using automatic parallel storage, and then used to perform
the MVP. This part is implemented in the modules {\tt
  ED\_HAMILTONIAN\_?\_STORED\_HxV}
If {\tt ed\_sparse\_H} is {\tt False} the MVP is operated on-the-fly,
i.e. each element of $H_\SS$ is direcrtly applied to the given input
vector $\ket{v}$ to determine the outgoing vector $H_\SS\ket{v}$,
either in serial or parallel mode as implemented in {\tt
  ED\_HAMILTONIAN\_?\_DIRECT\_HxV}.  



The function {\tt vecDim\_Hv\_sector\_?} returns the 
dimension of the vector to be used in the
MVP. In serial execution this number is just $D_\SS$ the dimension of
the sector, whereas in a parallel mode the returned value is the
dimension $d_i$ of the vector chunk per each node such that
$\sum_{i=1}^{N_{nodes}}d_i = D_\SS$. Yet, the specific value of $d_i$
depends on the MPI algorithm used for the MVP function, which in turn
is determined by the symmetry of the problem, i.e. {\tt ed\_mode}.


The sector-by-sector diagonalization for each
value of {\tt ed\_mode} is implemented in the modules {\tt
  ED\_DIAG\_?} through the main functions {\tt
  diagonalize\_impurity\_?}. The diagonalization proceeds in three main
steps: i) setup the diagonalization by selecting all or a sub-set of the
sectors to analyze; ii) sequential diagonalization cycle over all the suitable symmetry
sectors; iii) analysis of the resulting {\tt state\_list} containins
all the eigensolutions to be conserved.




\subsection{Dynamical correlation functions}\label{sSecGF}
The determination of the low energy part of the Hamiltonian spectrum
enables the evaluation of dynamical correlation functions using Krylov
sub-space algorithm.
This is a key part of the library when using \NAME as an impurity
solver within DMFT framework. 

Before entering into the implementation details we briefly outline the
generic algorithm. Let us consider the dynamical correlation function:
\begin{equation}
  \label{eqGaa}
  C_\AA = \ibra \TT_\pm[ \AA(t) \AA^+ ]\iket
  \end{equation}
where $\AA(t)=e^{iHt}\AA e^{-iHt}$, $\TT_\pm$ is the time-ordering operator for fermions or
bosons and $\ibra \AA \iket=\frac{1}{Z}\Tr{ \left[ e^{-\beta
      H}\AA \right]}$,  $Z=\sum_ne^{-\beta E_n}$, is the thermodynamic
average. Using spectral decomposition, the expression \equ{eqGaa} is reduced into Kallen-Lehman form:
\begin{equation}\label{KLgf}
  \begin{split}
    C_\AA(z) 
    &=  \ibra \AA \frac{1}{z-H} \AA^+\iket
    \mp \ibra \AA^+ \frac{1}{z+H} \AA\iket \cr
    %
    & =\frac{1}{Z}\sum_n e^{-\beta E_n}\sum_m
  \frac{ |\bra{\psi_m}\AA^+ \ket{\psi_n}|^2 }  {z-(E_m-E_n)}
  \mp
  \frac{ |\bra{\psi_m}\AA \ket{\psi_n}|^2 }  {z+(E_m-E_n)}\cr
\end{split}
\end{equation}
where $z\in\CCC$, 
$\ket{\psi_n}$, $E_n$ are the eigenpairs of the
Hamiltonian $H$ and $E_0$ is the groundstate energy.
While appealing, the previous expression requires the knowledge of the
entire Hamiltonian spectrum. A key simplification is obtained looking
at the first line in \equ{KLgf},
showing that the $C_\AA$ essentially corresponds to a given element of the inverse operator $(z-H)^{-1}$, i.e. the
resolvant. The Krylov sub-space method provides a controlled
approximation for this element, leveraging over the
reduction of the (sector) Hamiltonian to a partial tri-diagonal
form and returning an arbitrary number of amplitudes to (unknown)
excited states. To illustrate the algorithm let's consider the normalized initial state: 
$$
\ket{\phi_n}=\AA^+\ket{\psi_n}/\NN_n
$$
where  $\ket{\psi_n}\in\SS$ and $\NN_n=\sqrt{\bra{\psi_n}\AA
  \AA^+\ket{\psi_n}}$.
We can construct the Krylov basis $$\mathcal{K}_{N} (\ket{\phi_n})=\{\ket{\phi_n}, H\ket{\phi_n}, \dots,
H^N\ket{\phi_n}\}\equiv \{\ket{v^n_0}, \ket{v^n_1},\dots, \ket{v^n_N}
\}$$ with $1 \ll N \ll \DD_\SS$ by iteratively applying the (sector)
Hamiltonian through MVP functions. 
Any given eigenstate $\ket{\psi_n}$ has components along the Krylov basis $\mathcal{K}_{N} (\ket{\phi_n})$ which read: $\ket{\psi_n} =
\sum_i  \ibra v^n_i|\psi_n \iket  \ket{ v^n_i} =
\sum_i a^n_i \ket{v^n_i}$.   We can evaluate the operator components
$=\bra{\psi_m}\AA^+ \ket{\psi_n}\equiv \langle\psi_m| \phi_n\rangle =
\NN_n {a^{n*}_m}$. Inserting this expression into \equ{KLgf} we
obtain the following approximation to $C_\AA$:
\begin{equation}
  \label{eqGKrylov}
  \begin{split}
    C_\AA(z)  &\simeq \frac{1}{Z}\sum_n e^{-\beta E_n}
    \sum_{m=1}^{N} \frac{\bra{\psi_n}\AA \AA^+\ket{\psi_n} |a^n_m|^2}{
      z - (E_m-E_n)} \mp \frac{\bra{\psi_n}\AA^+ \AA\ket{\psi_n}
      |a^n_m|^2}{ z + (E_m-E_n)}\cr
    %
    &= \frac{1}{Z}\sum_n\sum_{m=1}^{N} \sum_{\nu=\pm}\frac{w^{\nu}_{mn}[\AA]}{z - dE^\nu_{mn}[\AA]} 
    = \frac{1}{Z}\sum_n
    \sum_{m=1}^{N} \sum_{\nu=\pm} g_\AA(\nu, w^{\nu}_{mn},  dE^\nu_{mn}) \cr
  \end{split}
\end{equation}
where we introduced the notation $g(\nu, w(\AA)^{\nu}_{mn},  dE(\AA)^\nu_{mn})$
for the {\tt gfmatrix} object containing the weights $w(\AA)^{\nu}_{mn}$ and
poles $dE(\AA)^{\nu}_{mn}$ for the operator $\AA$, for every initial state $\ket{\psi_n}$
contributing to the low energy spectrum, for every order $m$ of the
Krylov sub-space algorithm and for channel $\nu$. 

A stringent limitation of this procedure is to get applied to diagonal
dynamical correlation functions of the form \equ{eqGaa}. However, as
we will show in the following, many practical application requires to
evaluate off-diagonal functions of the form:
$C_{\AA\BB}(z) = \ibra T_{\pm}[\AA(t) \BB^+]\iket$.
A direct extensin of the method is obtained considering suitable
auxiliary operators prepared with independent linear combination of
$\AA$ and $\BB$.
A notable example is to consider the two auxiiary operators $\OO=\AA +\BB$ and
$\PP=\AA-i\BB$. Using simple algebra it is then straightforward to
obtain the desired function $C_{\AA \BB}$ from the evaluation of
$C_\OO$ and $C_\PP$:
$$
C_{\AA\BB} = \frac{1}{2}\left[C_\OO + C_\PP - (1-i)C_\AA -(1-i)C_\BB\right]
$$


In \NAME the impurity Green's functions $G_{\a\b\s\s'}=\ibra \TT_\pm[ c_{\a\s}(t)
c_{\b\s'}^+ ]\iket$,
is contained in \texttt{ED\_GREENS\_NORMAL}. This wraps more
specific methods according to the symmetry of the problem expressed by
{\tt ed\_mode}. In the {\bf normal} mode also spin,
charge, pair and excitonic susceptibilities functions. 
Computationally, the construction of the Krylov basis
$\mathcal{K}_N(\OO\ket{\psi_n})$ for any eigenstate of the low energy
spectrum is the most time consuming step. As for the diagonalization
part, here a crucial speed-up is obtained by the parallel execution of
the MVP lying at the earth of the Hamiltonian tri-diaagonalization
process. The input variable {\tt lanc\_gfniter} controls the largest order of
the Krylov basis, i.e. the maximum number of excitations in
\equ{eqGKrylov}.  
Operationally, each symmetry mode {\tt ed\_mode=?} requires a different construction of
the Green's functions implemented in {\tt ED\_GF\_?}

\paragraph{{\bf normal}}
In this case the all the orbital dependent and spin-diagonal Green's
functions $G_{\a\b\s\s}$ needs to be evaluated. The orbital diagonal case
$\a=\b$ proceeds as discussed above considering $\AA=c_{\a\s}$. This
step makes use of the {\tt apply\_op\_C/CDG} functions in {\tt
  ED\_AUX\_FUNX} on any eigenstate $\ket{\psi_n}$ in the {\tt
  state\_list}, i.e. a global instance of {\tt sparse\_espace}
containing the low energy spectrum of the problem.
The sector Hamiltonian matrix in this mode is assumed to be real
symmetric. This brings a simplification in the evaluation of the
off-diagonal components $G_{\a\b\s\s}=G_{\b\a\s\s}$.
These components are thus evaluated considering the auxiliary operator
$\OO=(c_{\a\s} + c_{\b\s})$ and using the relation
$G_{\a\b\s\s}=\tfrac{1}{2}(C_\OO - G_{\a\a\s\s} - G_{\b\b\s\s})$.

The diagonal spin, charge and pair susceptibility terms
$\chi^{S^z}_{\a\a}$, $\chi^N_{\a\a}$ and $\chi^\Delta_{\a\a}$ are
evaluated employing, respectively, the operators $\AA=\sum_{\s\s'}c^+_{\a\s}\tau^z_{\s\s'}c_{\a\s'}\equiv
S^z_\a$, $\AA=\sum_{\s\s'}c^+_{\a\s}\tau^0_{\s\s'}c_{\a\s'}\equiv
N_\a$) and $\AA=c_{\a\dw}c_{\a\up}\equiv
\Delta_\a$, where
$\tau^{a=0,x,y,z}$ are the Pauli matrices.
Similarly, yhe off-diagonal terms are obtained by considering the operator $\AA=S^z_\a
+ S^z_\b$, $\AA=N_\a + N_\b$ or $\AA=\Delta_\a + \Delta_\b$. 
The excitonic susceptibility $\chi^T_{\a\b}$ is defined with respect
to the vector operator: $T^i_{\a\b} = \sum_{\s\s'}
c^+_{\a\s}\tau^i_{\s\s'}c_{\b\s'}$, respectively, the spin-singlet
($i=0$) and the spin-triplet excitons ($i=x,y,z$) operators.


\paragraph{{\bf superc}}
In the supercondutive case the Nambu orbital
dependent $s$-wave Green's function reads:
\begin{equation}
  \label{GFnambu}
  \hat{G}_{\a\b} =
  \begin{bmatrix}
    G_{\a\b\up\up} & F_{\a\b\up\dw} \\
    \bar{F}_{\a\b\dw\up} & \bar{G}_{\a\b\dw\dw}
  \end{bmatrix}  
\end{equation}
However, leveraging on the symmetries holding between the different
components we can reduce to evaluate only the top row components plus
auxiliary functions.
The calculation of the diagonal normal component $G_{\a\a\up\up}$ follows the
very same scheme of the {\bf normal} case. For the off-diagonal terms
however we do not rely on any symmetry relation but we consider 
two auxiliary functions $C_\OO$, $C_\PP$ with $\OO=c_{\a\up} +
c_{\b\up}$, $\PP=c_{\a\up} -ic_{\b\up}$ so that:
$G_{\a\b\up\up}=\tfrac{1}{2}[C_\OO + C_\PP -
(1-i)(G_{\a\a\up\up}+G_{\b\b\up\up})$.
The diagonal and off-diagonal anomalous terms $F_{\a\b\up\dw}$ need to
be evaluated using different combinations of creation/destruction
operators. First we evaluate the $\bar{G}_{\a\a\dw\dw}$ component as
an auxiliary term considering $\AA=c^+_{\a\dw}$. 
Next, we consider the two linear combinations:
$\TT = c_{\a\up} + c^+_{\b\dw}$, $\RR=c_{\a\up} -i c^+_{\b\dw}$
contributing, respectively, to the auxiliary functions $C_\TT$,
$C_\RR$. The searched anomalous functions reads:
$F_{\a\b\up\dw} = \tfrac{1}{2}[ C_\TT + C_\RR - (1-i)(G_{\a\a\up\up} +
\bar{G}_{\b\b\dw\dw})]$. 


\paragraph{{\bf nonsu2}}
In this case all the Green's functions components need
to be evaluated. For the orbital and spin diagonal terms
$G_{\a\a\s\s}$  we proceeds as in the {\bf normal} case.
The remaining  off-diagonal components $G_{\a\b\s\s'}$ are
evaluated using auxiliary operators $\OO=c_{\a\s}+c_{\b\s'}$,
$\PP=c_{\a\s}-ic_{\b\s'}$ and the relation:
$G_{\a\b\s\s'}=\tfrac{1}{2}[C_\OO+C_\PP -
(1-i)(G_{\a\a\s\s}+G_{\b\b\s'\s'})]$.




\subsection{Observables}\label{sSecObc}
A number of predefined impurity observable or local static
correlations, e.g. occupation, total energy, pair amplitude, excitonic
order parameter ,etc.   are calculated in the module
\texttt{OBSERVABLES}. As for the previous cases, this module wraps the
different implementations and quantities to evaluate from the
operational modes {\tt ed\_mode=?} implemented in {\tt
  ED\_OBSERVABLES\_?}. 
Local observables and correlations are defined by the thermal average  $\ibra \OO\iket =
\Tr{\left[e^{-\beta H}\OO\right]}/Z$. This can be efficiently evaluated at zero and
low temperature using the stored low energy part of the spectrum
leveraging on the exponential cutoff from the Boltzmann factor:
$$
\ibra \OO\iket  = \tfrac{1}{Z}\sum_n e^{-\beta
  E_n}\bra{\psi_n}\OO\ket{\psi_n}
$$
where $E_n$ and $\ket{\psi_n}$ are the low lying eigenstates of the
system stored in the {\tt state\_list}. 



\subsection{Reduced impurity density matrix}\label{sSecRDM}
This version of the \NAME library features the calculation of the
impurity Reduced Density Matrix (iRDM), enabling the analysis of
entanglement properties of the quantum impurity for any value of {\tt
  ed\_mode}.
To simplify the discussion in this section we take the zero
temperature limit and consider the presence of a non-degenerate
groundstate $\ket{\psi}$ populating the {\tt state\_list}.
The generalization to the presence of degenerate states or the finite
temperature regime are straightforward.
The groundstate belongs to a given symmetry sector $\SS$ and it
represented in the Fock basis as:  $\ket{\psi} = \sum_I a_I \ket{I}$. 
The density matrix $\rho$ is defined as:
$$
\rho = \ket{\psi}\bra{\psi} = \sum_{nm=1}^{4^{N_s}} a^*_ma_n \ket{n}\bra{m} =\sum_{nm=1}^{4^{N_s}} \rho_{nm} \ket{n}\bra{m} 
$$
The iRDM is obtained from this by tracing out the bath degrees of
freedom: $\rho^{i}=Tr_{b}\rho$. The summation appearing in the
previous expressions becomes quickly unmaneagable with the system
size. To overcome this issue we implemented a fast algorithm
leveraging on symmetry sector and map sparsity.
Using quantum number conservation the summation extrema get reducedto
the size $D_S$ of the sector $S$ to which the groundstate (or in
general any eigenstate) belongs. 
Next we analyze the groundstate expansion on the Fock states, splitting the bit representation of any state $\ket{I}$ into
their spin-dependent impurity and bath parts as $\ket{I} = \ket{
  i_\uparrow\,  b_\uparrow\, i_\downarrow \, b_\downarrow}$. Each bit
set span a space of dimension $D^\a_{imp}$ or $D^\s_{bath}$. 
Finally, we store into the {\tt sparse\_map} ${\cal S}$, for every impurity configuration 
$i_\s =1,\dots,D^\s_{imp}$ (key) the corresponding bath states $j\in[1,\dots,D^\s_{bath}]$
(values) which contribute to that key, as detailed in
\secu{CodeSparseMap}.
We indicate with ${\cal D}^\s_{i}$ the number of values for the key $i_\s$.
The fast summation algorithm for the evaluation of the iRDM takes on a
different form for the two cases {\bf normal} and {\bf superc/nonsu2},
as outlined below.

\paragraph{{\bf normal}}
In this case we take advantage of the Fock and sector spin resolved
factorization discussed in \secu{sSecQNs}. As such we can also split
impurity and bath bits independently for each spin configuration:
$$
\ket{\vec{n}} =
\ket{\vec{n}_\up}\otimes \ket{\vec{n}_\dw} =
\ket{\vec{i}_\up}\ket{\vec{b}_\up}\otimes \ket{\vec{i}_\dw}\ket{\vec{b}_\dw}
$$
In addition it should be noted that creation (destruction) operators at
position $p$ for spin $\sigma$  $c^+_{p\sigma}$ ($c^+_{p\sigma}$) do
not operate on the opposite spin so that they pass through without
taking any fermionic sign. Finally, we observe that local iRDM admits
only diagonal terms in the {\bf normal} case. Thus we obtain for the iRDM:
\begin{equation}
  \label{iRDMnormal}
  \begin{aligned}
  \rho^i &=
  \sum_{\sigma=\up\dw}\sum_{b_\sigma=1}^{D_{b_\sigma}}
  \bra{b_\up}\otimes\bra{b_\dw}
    \rho
    \ket{b_\dw}\otimes\ket{b_\up}    \cr
    %
    &=\sum_{\sigma=\up\dw}
    \sum_{b_\sigma=1}^{D_{b_\sigma}}
    \sum_{i_\sigma=1}^{D_{i_\sigma}}
    \sum_{p_\sigma=1}^{D_{p_\sigma}}
    \sum_{j_\sigma=1}^{D_{j_\sigma}} 
    \sum_{q_\sigma=1}^{D_{q_\sigma}}
    C_{i,p}\,C_{j,q}\,a_{i_\up p_\up i_\dw p_\dw} a^*_{j_\up q_\up j_\dw q_\dw}
    \langle b_\up| p_\up\rangle| i_\up\rangle\langle j_\up |\langle q_\up| b_\up\rangle   \otimes \langle b_\dw| p_\dw \rangle|i_\dw\rangle \langle j_\dw  |\langle q_\dw| b_\dw\rangle
    \cr
&=
    \sum_{b_\sigma=1}^{D_{b_\sigma}}
    \sum_{i_\sigma=1}^{D_{i_\sigma}}
    a_{i_\up b_\up i_\dw b_\dw} a^*_{i_\up b_\up i_\dw b_\dw}
    \ket{i_\up}\bra{i_\up}\otimes \ket{i_\dw}\bra{i_\dw}
  \end{aligned}
\end{equation}
where the constant $C_{i,b}$ take care of the sign change due to
exchanging bath and impurity bit sets. As effect of the Kronecker
delta symbols for bath and impurity these constants are identically 1.  
The numerical implementation relies on the use of the {\tt
  sparse\_map} ($\%sp$) for the groundstate sector as reported in the
listing below:  
\begin{lstlisting}[style=fstyle,numbers=none,basicstyle={\scriptsize\ttfamily}]
do IimpUp=0,2**Norb-1
  do JimpUp=0,2**Norb-1
    !Finding the unique bath states connecting IimpUp and JimpUp
    call sp_return_intersection(sectorI%H(1)%sp,IimpUp,JimpUp,BATHup,lenBATHup)
    if(lenBATHup==0)cycle
    do IimpDw=0,2**Norb-1
      do JimpDw=0,2**Norb-1
        !Finding the unique bath states connecting IimpDw and JimpDw -> BATHdw(:)
        call sp_return_intersection(sectorI%H(2)%sp,IimpDw,JimpDw,BATHdw,lenBATHdw)
        if(lenBATHdw==0)cycle
        do ibUP=1,lenBATHup
          IbathUp = BATHup(ibUP)
          do ibDW=1,lenBATHdw
            IbathDw = BATHdw(ibDW)
            !Allowed spin Fock space Istates:
            !Iup = IimpUp +  2^Norb * IbathUp
            !Idw = IimpDw +  2^Norb * IbathDw
            iUP= binary_search(sectorI%H(1)%map,IimpUp + 2**Norb*IbathUp)
            iDW= binary_search(sectorI%H(2)%map,IimpDw + 2**Norb*IbathDw)
            i  = iUP + (iDW-1)*sectorI%DimUp
            !Allowed spin Fock space Jstates:
            !Jup = JimpUp +  2^Norb * IbathUp
            !Jdw = JimpDw +  2^Norb * IbathDw
            jUP= binary_search(sectorI%H(1)%map,JimpUp + 2**Norb*IbathUp)
            jDW= binary_search(sectorI%H(2)%map,JimpDw + 2**Norb*IbathDw)
            j  = jUP + (jDW-1)*sectorI%DimUp
            ! 
            io = (IimpUp + 2**Norb*IimpDw) + 1
            jo = (JimpUp + 2**Norb*JimpDw) + 1
            irdm(io,jo) = irdm (io,jo) + psi(i)*psi(j)*weight
          enddo
        enddo
      enddo
    enddo
  enddo
enddo
\end{lstlisting}

\paragraph{{\bf superc/nonsu2}}
In presence of these symmetries suitable modifications related to the
absence of Fock space factorization have to be taken into account. To
start with a generic Fock state appearing in the groundstate
decomposition has the form:
$$
\ket{\vec{n}} =\ket{\vec{i}_\up\vec{b}_\up\vec{i}_\dw\vec{b}_\dw}
%
$$
% where the second is just a formal identity.  
Inserting this latter in the definition of iRDM we obtain:
\begin{equation}
  \begin{aligned}
    \Tr_{b_\up, b_\dw}{\rho} &=
    \sum_{b_\sigma=1}^{D_{b_\sigma}}
    \bra{b_\up\, b_\dw}
    \rho
    \ket{b_\dw\, b_\up}    \cr
    &=
    \sum_{b_\sigma=1}^{D_{b_\sigma}}
    \sum_{i_\sigma=1}^{D_{i_\sigma}}
    \sum_{p_\sigma=1}^{D_{p_\sigma}}
    \sum_{j_\sigma=1}^{D_{j_\sigma}} 
    \sum_{q_\sigma=1}^{D_{q_\sigma}}
    a_{i_\up p_\up i_\dw p_\dw} a^*_{j_\up q_\up j_\dw q_\dw}% \cr
    % &{\phantom =}
    \langle{b_\up\, b_\dw}|{i_\up\, p_\up\, i_\dw\, p_\dw}\rangle
    \langle{q_\dw \,  j_\dw \, q_\up\, j_\up }|{b_\dw\, b_\up}\rangle\, .
  \end{aligned}
\end{equation}
In order to simplify this expression we should get rid of the sum with
respect to the bath indices $p_\sigma$ and $q_\sigma$, ideally
contracting them with the outer indices $b_\sigma$.
However, this requires to bring all the bath bits so to preced the
impurity ones:
$$
\ket{i_\up\, p_\up\, i_\dw\, p_\dw} \rightarrow C_{p_\up,i_\dw} \ket{i_\up\, i_\dw \,p_\up\,p_\dw}
$$
where $C_{p_\up,i_\dw}  = (-1)^{\#\vec{n}_{p\up} \cdot
  \#\vec{n}_{i\dw}}$ with   $\#\vec{n}=\sum_i n_i$ is an overall
fermionic sign which depends on the occupation of the $p_\up$ and the
$i_\dw$ bit configurations. Inserting this relation in the equation
for the iRDM we obtain:
\begin{equation}
  \begin{aligned}
    \Tr_{b_\up, b_\dw}{\rho} &=
    \sum_{i_\sigma=1}^{D_{i_\sigma}}
    \sum_{j_\sigma=1}^{D_{j_\sigma}}
    \left[\sum_{b_\sigma=1}^{D_{b_\sigma}}
    a_{i_\up b_\up i_\dw b_\dw} a^*_{j_\up b_\up j_\dw b_\dw}
    C_{b_\up,i_\dw}C_{b_\up,j_\dw}\right]
    \ket{i_\up\, i_\dw}\bra{j_\dw \, j_\up}\cr
&=
    \sum_{i_\sigma=1}^{D_{i_\sigma}}
    \sum_{j_\sigma=1}^{D_{j_\sigma}}
    \rho^{i}_{i_\up i_\dw j_\dw j_\up}
    \ket{i_\up\, i_\dw}\bra{j_\dw \, j_\up} 
  \end{aligned}
\end{equation}
The numerical implementation requires few modifications with respect
to the previous case. In particular it is important to recall that the
ordering of the key-value pairs in the {\tt sparse\_map} in this case
follow a contiguous ordering and that their decomposition is necessary
to reconstruct the correct Fock state index, see the following
listing:
\begin{lstlisting}[style=fstyle,numbers=none,basicstyle={\scriptsize\ttfamily}]
do IimpUp=0,2**Norb-1
  do IimpDw=0,2**Norb-1
    do JimpUp=0,2**Norb-1
      do JimpDw=0,2**Norb-1
        !Build indices of the RDM in 1:4**Norb
        iImp = iImpUp + iImpDw*2**Norb
        jImp = jImpUp + jImpDw*2**Norb
        call sp_return_intersection(sectorI%H(1)%sp,iImp,jImp,Bath,lenBath)
        if(lenBATH==0)cycle
        do ib=1,lenBath
          iBath = Bath(ib)
          !Decompose iBath into B_Up, B_dw to reconstruct B bit set. 
          !B --> {B_up,B_dw}
          iBathUp = mod(iBath,2**Nbath)
          iBathDw = (iBath)/2**Nbath
          !Reconstruct the Fock state Ii map back to sector state i
          ii= iImpUp + iImpDw*2**Ns + 2**Norb*(IBathUp + IBathDw*2**Ns)
          i = binary_search(sectorI%H(1)%map,ii)
          !Reconstruct the Fock state Jj map back to sector state j
          jj= jImpUp + jImpDw*2**Ns + 2**Norb*(IBathUp + IBathDw*2**Ns)
          j = binary_search(sectorI%H(1)%map,jj)
          !Build the signs of each components of RDM(io,jo)
          nBup  = popcnt(Ibits(ii,Norb,Norb*Nbath))
          nIdw  = popcnt(Ibits(ii,Ns,Norb))
          nJdw  = popcnt(Ibits(jj,Ns,Norb))
          signI = (-1)**(nIdw*nBup)
          signJ = (-1)**(nJdw*nBup)
          sgn   = signI*signJ
          !  
          io = (iImpUp+1) + 2**Norb*iImpDw
          jo = (jImpUp+1) + 2**Norb*jImpDw
          rdm(io,jo) = rdm(io,jo) + psi(i)*conjg(psi(j))*weight*sgn
        enddo
      enddo
    enddo
  enddo
enddo
\end{lstlisting}



\subsection{Bath Functions}\label{sSecFunc}
The module {\tt ED\_BATH\_FUNCTIONS} implements on-the-fly
calculations of the hybridization function $\Delta_{\a\b\s\s'}(z)=\sum_\nu
{V^\nu_{\a\s}}(z\11-h^\nu_{\a\b\s\s'})^{-1}V^\nu_{\b\s'}$ and the
non-interacting Green's functions $G^0_{\a\b\s\s'}(z) =
[(z + \mu)\delta_{\a\b\s\s'} - h^0_{\a\b\s\s'} -
\Delta_{\a\b\s\s'}(z)]^{-1}$ for any frequency $z\in\CCC$. 
The module contains implementations for any case according to the
values of {\tt ed\_mode} and {\tt bath\_type}, either with supplied
user bath (a rank-1 array of doubles) or using the allocated {\tt
  effective\_bath} instance {\tt dmft\_bath}. 
We provide different functions to get either $\Delta$, $G^0$ and its
directly its inverse $[G^0]^{-1}$, which are used to evaluate the
self-energy functions upon request, see \secu{sSecIO}.
In the superconductive case {\tt ed\_mode}={\bf superc} different
procedures can be used to retrieve the anomalous components of any
function defined above in the Nambu basis. 



\subsection{Bath Optimization}\label{sSecFit}
{\color{red} to be revised, copy\&paste from edipack paper: well it is
  essentiall the same shit} 
In the DMFT context the bath needs to be optimized
against a given realization of the Weiss field
${\GG^{-1}_{0}}_{\a\b\s\s'}(z)$, or the corresponding {\it hybridization} function
$\Theta = (z + \mu)\11 - H^{loc} -\GG_0^{-1}](z)$. While the Weiss
field is obtained from the DMFT self-consistency
equation~\cite{Georges1996RMP}, bath discretization impose to  find an optimal
description of the continuous Weiss field in terms of the finite
number of parameters of the bath (see \secu{sSecBath}.
Although different algorithms can be envisaged to perform this
step~\cite{Garcia2004PRL,Taranto2012PRB} which are perfectly valid in
some physical contexts.
In order to enable the users to use their preferred 
method in \NAME we keep the optimization implementation independent
from the rest of the code. Yet, we offer a fully fledged optimization
strategy based on the  conjugate gradient (CG) minimization of the cost function:
$$
\chi = \sum_{n=1}^{L_{fit}}\frac{1}{W_n}||X(i\omega_n) - X^{QIM}(i\omega_n;\{V,h\})||_q
$$
where the symbol $|| \cdot ||_q$ is a suitably defined $q$-norm in the
matrix function space, $X_{\a\b}={\GG_{0}}_{\a\b\s\s'},\,\Theta_{\a\b\s\s'}$ are the user
supplied local functions and
$X_{\a\b}^{QIM}=G^0_{\a\b\s\s'},\,\Delta_{\a\b\s\s'}$ the
quantum impurity model functions, defined above.
Notably, more sophisticated optimization algorithms have been
recently implemented to better undertake the minimization of similar
cost functions. However, these developments are designed to work with truncated
algorithms, e.g. sCI or DMRG, describing systems with a larger number of
bath levels.   
In the ED context however, where the efficient and wise selection of
the relatively few bath levels becomes crucial, the CG minimization of
the local functions proved to be the most efficient and
flexible optimization scheme so far. 

The fit procedure is entirely wrapped by the single function {\tt
  ed\_chi2\_fitgf} contained in the module \texttt{ED\_BATH\_FIT}.   
In order to exploit regularity of the functions the fit is 
performed using imaginary Matsubara frequency. 
The actual form of $X_{\a\b\s\s'}$ is controlled by the input parameter
\texttt{cg\_Scheme=Weiss,Delta}. 

In order to fine tune the optimization step in \NAME\ we
introduced a number of control parameters. To start with, we include
two distinct CG algorithms in the library, controlled by the input variable
\texttt{cg\_method=0,1}. The value \texttt{0} corresponds to a
Fletcher-Reeves-Polak-Ribiere minimisation algorithm, adapted from
Numerical Recipes~\cite{NumRec77}. Yet, in order to guarantee
back-compatibility with respect to the past literature, we also provide the
possibility of using the minimization procedure published in
Ref.\onlinecite{Georges1996RMP} which has been largely used in the DMFT
community.

The gradient $\nabla\chi$ required by the CG algorithm can be
evaluated either analytically or numerically as
controlled by the value of the input parameter \texttt{cg\_grad=0,1}. For
\texttt{cg\_method=1} only numerical gradient can be used.
The number of Matsubara frequency $L_{fit}$ used in the fit procedure
is controlled  by the input parameter \texttt{cg\_Lfit}.
This parameter can be used to restrict the fit to the low frequency
part as the large frequency tails of the local Matsubara functions
have universal behavior.
Similarly, the weight  $W_n=1,1/L_{fit},1/\omega_n$ is used to
enhance the weight of low energy part with respect to the
intermediate-to-large energy one in the cost function.
This is controlled by the input parameter \texttt{cg\_Weight=0,1,2}.
Another  factor contributing to determine the behavior
of the fit is the power $q$ of the cost function $\chi$. By tuning
this parameter, controlled by input variable \texttt{cg\_pow}, it is
possible to enhance or suppress the differences in the $\chi$ in order
to improve (or simplify) the optimization procedure.  

Finally, we introduced few additional parameters which aim to
control the quality of the fit. The first is the fit tolerance,
controlled by the input parameter \texttt{cg\_Ftol}, which
determines the convergence threshold of the minimization procedure.
The second is the maximum number of iterations \texttt{cg\_Niter}
allowed for the CG algorithm to determine the minimum.
The last parameter \texttt{cg\_stop=0,1,2} selects the exit
condition of the minimization procedure. We envisaged  three
possible conditions: $C_1\cup C_2$, $C_1$, $C_2$ with 
$C_1=|\chi^{n-1} -\chi^n|<\mathtt{cg\_Ftol}(1+\chi^n)$ and
$C_2=||x_{n-1} -x_n||<\mathtt{cg\_Ftol}(1+||x_n||)$, where $\chi^n$
is the cost function evaluated at the $n^{\rm th}$-step and $x_n$
the corresponding argument. Increasing the value of the stop
parameter generally loosens up the exit conditions of the minimization.   

{\bf REMARK TODO}
Notes on the norm function: a) the definition for conventional
matrices, ;b) the definition for the replica/general case where you
can choose between different norm defition.



\subsection{Input/Output}\label{sSecIO}
The module {\tt ED\_IO} provides access to the results of the Lanczos
diagonalization of the quantum impurity problem.
As any single instance of the code is preserved in the memory until a
new call is made, access to the memory pool is only possible through
specific functions implemented in {\tt ED\_IO}. For instance, dynamical response functions, self-energy components or impurity
observables can all be retrieved using dedicated functionalities.
Additionally we provide procedures to perform on-the-fly
re-calculation of the impurity Green's functions and self-energy on a
given arbitrary set of points in the complex frequency domain
exploiting their storage in terms of {\tt gfmatrix} objects.
A long list of available functions is contained in the on-line
documentation (see
\href{https://edipack.github.io/EDIpack2.0/edipack2/13_io.html#ed-io}{https://edipack.github.io/EDIpack2.0/edipack2/13\_io.html\#ed$-$io})
Here we limit the discussion to two paradigmatic examples.
The first is the function {\tt ed\_get\_dens} which write on the
provided input array the value of the orbital impurity occupations
$\langle n_{\a\s}\rangle$. Analogously {\tt ed\_get\_sigma} is used to
retrieve the normal or anomaous components of the Matsubara or
Real-axis self-energy function $\Sigma(z)$. This latter represents the
key output of the calculation in 
any DMFT application. 








\subsection{EDIpack2ineq: inequivalent impurities}\label{sSecIneq}
It is often necessary to solve systems with several, independent,
quantum impurities. Paradigmatic examples arise in the DMFT
framework when dealing with the effective description of lattices
built out of unit cells hosting multiple inequivalent atoms or large
super-cell systems with possibly broken translational symmetries,
e.g. heterostructures of correlated materials, disordered systems,
etc.
As the structure of \NAME allows the presence of a single instance of
the solver at any time, we implemented a suitable extension to deal
with multiple impurities. Specifically {\tt EDIpack2Ineq} is a
sub-library which complements \NAME, wrapping memory and procedures in
order to enable simultaneous treatment of  inequivalent impurities. 
Using standard Fortran interfaces it is possible to group all the
\NAME and {\tt EDIpack2ineq} functions under the same name without
compromising the software functionalities.  
Here below we briefly discuss the main additions introduced by {\tt
  EDIpack2ineq}. 

\subsubsection{Structure}\label{ssSecIneqStructure}
The sub-library is composed of a number of Fortran modules which are
wrapped by {\tt EDIPACK2INEQ}. This latter represents the main user
interface and gives access to all the available procedures and
variables as needed to solve quantum impurity problems.
The user needs to invoke use of this module alongside the \NAME one:
\begin{lstlisting}[style=fstyle,numbers=none,basicstyle={\scriptsize\ttfamily}]
program test
  !Load EDIpack2 library 
  USE EDIPACK2 
  !Load the Inequivalent impurities extension
  USE EDIPACK2INEQ
  ...
\end{lstlisting}


A major part of the {\tt EDIpack2ineq} library is to define global
variables which wrap and conserve the memory pool of \NAME.
For instance we implement a number of
globally shared arrays with an increased rank to store the
variables in any memory instance of \NAME and accessible through
the input/output procedures (see \secu{sSecIO}).
Specific objects, e.g. {\tt effective\_bath} or {\tt gfmatrix}, in
principle require dedicated MPI
communication when parallel execution of the solver among independent
impurities. However, we opt for the much simpler and economic solution
of reading these objects from the file in which they get saved
anyway. 


\subsubsection{Core routines}\label{ssSecIneqGlobal}
The module {\tt E2I\_MAIN} wraps the extensions to the main algorithms
of \NAME, namely: initialization, diagonalization and finalization,
preserving the original naming convention.  
The initialization process is handled by {\tt ed\_init} which is
extended to accepts a bath array or rank-2 (as opposed to rank-1 array
in the \NAME implementation). The leading dimension now determines the
number of inequivalent impurity problems to be solved. This procedure
initialize all the {\tt EDIpack2ineq} variables and prepare each bath
for the diagonalization step. 
In {\tt ed\_solve}, which accepts the same rank-2 bath array, performs the
diagonalization of each quantum impurity problem in either serial of
parallel mode. The parallel mode is further controlled by the input
function {\tt mpi\_lanc=T/F}. If true Lanczos diagonalization is
performed in parallel and inequivalent sites are treated
sequentially. The inverse if false.   
The finalization procedure with full memory release is performed in
{\tt ed\_finalize}.





\subsubsection{Inequivalent Baths}\label{ssSecIneqBath}
The inequivalent impurities extension is encoded in {\tt E2I\_BATH}
which contains procedures to control the baths setup on the user side
and the  implementation of conventional symmetry operations.
In the {\tt E2I\_BATH\_REPLICA} module we extend all the functions
which set the replica/general bath matrix basis 
$\vec{\Gamma}$ and the corresponding initial variational parameters
$\vec{\lambda}$. Although the variational parameters are generally
different from site to site, in the current implementation the matrix
basis is independent from the impurities number. This will possibly be
relaxed in a future release. 
Analogously, in the module {\tt E2I\_BATH\_FIT} we implement an extension of the generic
function {\tt ed\_chi2\_fitgf} to perform multiple independent
bath optimization for all inequivalent impurities in terms of an MPI iterative cycle. 
 
\subsubsection{Input/Output}\label{ssSecIneqIO}
A key part of the {\tt EDIpack2ineq} library is the extension for the
input/output procedures to return observables or dynamical functions per inequivalent impurity.
The module {\tt E2I\_IO} implements numerous functions which retrieve
or evaluate on-the-fly any quantity accessible in \NAME for any given
impurity (or all of them) using the same naming original convention
defined in \NAME.       

\end{document}