%% Use the options 1p,twocolumn; 3p; 3p,twocolumn; 5p; or
%% 5p,twocolumn, preprint, review
\documentclass[final,3p,10pt]{elsarticle}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[english]{babel}
\usepackage{amsmath,amssymb,amsfonts,amsthm}
\usepackage{makecell}

\usepackage{stackengine}
\newlength\llength
\llength=1.38ex\relax
\usepackage{xcolor}


%% natbib.sty is loaded by default. natbib options with \biboptions{...}
\biboptions{sort&compress,super}

% Hypelinks in the document; settings
\usepackage[colorlinks=true,linkcolor=blue,citecolor=red]{hyperref}
% \usepackage[normalem]{ulem}


\usepackage{listings}
\lstdefinestyle{fstyle}{
  frame=lines,
  language=fortran,
  basicstyle=\footnotesize,
  stringstyle=\ttfamily,
  commentstyle=\itshape,
  fontadjust=true,
  keywordstyle=\color{red},
  % morekeywords={*,...},
  mathescape,
  numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=3pt
}

\lstdefinestyle{mybash}{
  frame=lines,
  language=bash,
  basicstyle=\footnotesize,
  captionpos=b,
  stringstyle=\color{mymauve},%\ttfamily,
  commentstyle=\itshape,
  fontadjust=true,
  keywordstyle=\bfseries,
  morekeywords={*,git,mkdir,cmake,make},
  mathescape,
  numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=3pt
}


% % MINTED:
% % \usepackage[cache=true,cachedir=minted-cache]{minted}
% % \usepackage[finalizecache=true,cachedir=minted-cache]{minted}
% \usepackage[frozencache=true,cachedir=minted-cache]{minted}
% \setminted[fortran]{linenos,mathescape,frame=lines,style=bw,framesep=1mm,
%   baselinestretch=1,fontsize=\footnotesize}



\usepackage{array}
\usepackage{tabularx}
\usepackage{ltablex}

\renewcommand{\arraystretch}{1.4}
% \newcolumntype{T}[1]{>{\tt\footnotesize}m{{#1}}}
% \newcolumntype{D}[1]{>{\it\footnotesize}m{#1}}
% \newcolumntype{M}[1]{>{\scriptsize}m{#1}}

\newcolumntype{T}[1]{>{\tt\footnotesize\raggedright\arraybackslash}p{#1}}
\newcolumntype{D}[1]{>{\it\footnotesize\raggedright\arraybackslash}p{#1}}
\newcolumntype{M}[1]{>{\scriptsize\raggedright\arraybackslash}p{#1}}


\newcommand{\onlinecite}[1]{\nocite{#1}\hspace{-0.1cm}\citenum{#1}}

\newcommand {\note}[1]{{\color{blue} [{\bf NOTE}: \bf #1]}}
\newcommand {\aac}[1]{{\color{red} [{\bf AA}: \bf #1]}}
\newcommand {\new}[1]{{\color{blue}\it #1}}
%\newcommand {\new}[1]{{#1}}
% \DeclareMathAlphabet\mathbfcal{OMS}{cmsy}{b}{n}


%Reference to a given labelled equation
%and definition of a bib. element.
%-------------------------------------------
\newcommand{\equ}[1]
{Eq.~(\ref{#1})}

\newcommand{\figu}[1]
{Fig.~\ref{#1}}

\newcommand{\secu}[1]
{Sec.~\ref{#1}}

\newcommand{\ket}[1]
{|#1\rangle}

\newcommand{\bra}[1]
{\langle #1|}

\newcommand{\sgn}
{\mathop{\mathrm{sgn}}}



%SIMBOLI VARI
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\bcen{\begin{center}}
\def\ecen{\end{center}}

\def\a{\alpha}       \def\b{\beta}   \def\g{\gamma}   \def\d{\delta}
\def\e{\varepsilon}  \def\z{\zeta}   \def\h{\eta}     \def\th{\theta}
\def\k{\kappa}       \def\l{\lambda} \def\m{\mu}      \def\n{\nu}
\def\x{\xi}          \def\p{\pi}     \def\r{\rho}     \def\s{\sigma}
\def\t{\tau}         \def\f{\varphi} \def\ph{\varphi} \def\c{\chi}
\def\ps{\pi}        \def\y{\upsilon}\def\o{\omega}   \def\si{\varsigma}
\def\G{\Gamma}       \def\D{\Delta}  \def\Th{\Theta}  \def\L{\Lambda}
\def\X{\Xi}          \def\P{\Pi}     \def\Si{\Sigma}  \def\F{\Phi}
\def\Ps{\Psi}        \def\O{\Omega}  \def\Y{\Upsilon} \def\lg{\langle}

\def\PP{{\cal P}}\def\EE{{\cal E}}\def\MM{{\cal M}} \def\VV{{\cal V}}
\def\CC{{\cal C}}\def\FF{{\cal F}}\def\HH{{\cal H}}\def\WW{{\cal W}}
\def\TT{{\cal T}}\def\NN{{\cal N}}\def\BB{{\cal B}} \def\II{{\cal I}}
\def\RR{{\cal R}}\def\LL{{\cal L}}\def\JJ{{\cal J}} \def\OO{{\cal O}}
\def\DD{{\cal D}}
\def\AA{{\cal A}}
\def\GG{{\cal G}} \def\SS{{\cal S}}
\def\ZZ{{\cal Z}} \def\UU{{\cal U}}
\def\SB{{\cal S}{\cal B}}
\def\aa{{\V \a}}
\def\hh{{\V h}}\def\HHH{{\V H}}
%\def\AA{{\V A}}
%\def\GG{{\V G}}\def\BB{{\V B}}\def\aaa{{\V a}}\def\bbb{{\V b}}
\def\nn{{\V \n}}\def\pp{{\V p}}\def\mm{{\V m}}\def\qq{{\bf q}}
\def\RRR{\mathbb{R}} \def\CCC{\mathbb{C}} \def\NNN{\mathbb{N}}
\def\ZZZ{\mathbb{Z}}
%\def\TTT{\hbox{\msytw T}}



\def\ul{\underline}
\def\=={\equiv}
\def\defi{{\buildrel def \over =}}
\def\lft{\left} \def\rgt{\right} \def\dpr{\partial} \def\der{{\rm d}}
\def\us{\underline \s} \def\ue{{\underline \e}}
\def\la{\left\langle}
\def\ra{\right\rangle}
\def\qed{\raise1pt\hbox{\vrule height5pt width5pt depth0pt}}
\def\iome{i\omega_n} \def\iom{i\omega} \def\iom#1{i\omega_{#1}}
\def\iomn{i\omega_n}
\def\epsk{\epsilon({\bf k})} \def\Ga{\Gamma_{\alpha}}
\def\Seff{S_{eff}}  \def\dinf{$d\rightarrow\infty\,$}
\def\cG0{{\cal G}_0}
\def\cG{{\cal G}}  \def\cU{{\cal U}}  \def\cS{{\cal S}}
\def\spinup{\uparrow} \def\spindown{\downarrow} \def\spindw{\downarrow}
\def\up{\uparrow} \def\down{\downarrow} \def\dw{\downarrow}


\def\Ak{{\bf A}} \def\Akt{{\bf A}(t)} \def\Ek{{\mathbf E}}
% \def\Im{\mbox{Im}}
\def\=={\equiv}
\def\defi{{\buildrel def \over =}} \def\nt{\widetilde{n}}
\def\Im{{\rm Im}} \def\Re{{\rm Re}} \def\Tr{{\rm Tr}\,}
\def\det{{\rm det}\,} 


\def\ibra{\langle}
\def\iket{\rangle}

\def\ka{{\bf k}}
\def\vk{{\bf k}}
\def\qa{{\bf q}}
\def\vQ{{\bf Q}}
\def\vr{{\bf r}}
\def\q{{\bf q}}
\def\R{{\bf R}}
\def\vR{{\bf R}}
\def\kx{{ k_x}}
\def\ia{{\bf i}}
\def\ja{{\bf j}}

\usepackage{bbold}
\def\11{\mathbb{1}}
\def\00{\mathbf{0}}
\def\NAME{{\rm EDIpack2 }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 


 
\journal{Computer Physics Communications}

\begin{document}

\begin{frontmatter}

\title{EDIpack2: interoperable Lanczos-based solver for generic quantum impurity problems}
\author[a,b,c]{L.~Crippa}
\author[a]{I.~Krivenko}
\author[d]{S.~Giuli}
\author[d]{G.~Bellomia}
\author[e]{A.~Scazzola}
\author[f]{F.~Petocchi}
\author[g]{G.~Mazza}
\author[h]{L.~de Medici}
\author[d]{M.~Capone}
\author[i]{A.~Amaricci}

% \cortext[author] {Corresponding author.\\\textit{E-mail address:} amaricci@iom.cnr.it}
\newcommand{\CNRIOM}{CNR-IOM, Istituto Officina dei Materiali,
  Consiglio Nazionale delle Ricerche, Via Bonomea 265, 34136
  Trieste, Italy}
\newcommand{\SISSA}{Scuola Internazionale Superiore di Studi Avanzati (SISSA),
  Via Bonomea 265, 34136 Trieste, Italy}
\newcommand{\ITPHamburg}{I. Institute of Theoretical Physics,
  University of Hamburg, Notkestrasse 9, 22607 Hamburg, Germany}
\newcommand{\WZBURG}{Institut f\"ur Theoretische Physik und
  Astrophysik,Universit\"at W\"urzburg, 97074 W\"urzburg, Germany}
\newcommand{\CTQMAT}{W\"urzburg-Dresden Cluster of Excellence ct.qmat, 01062 Dresden, Germany}
\newcommand{\Geneve}{Department of Quantum Matter Physics, University of
  Geneva, Quai Ernest-Ansermet 24, 1211 Geneva, Switzerland}
\newcommand{\UPISA}{Department of Physics ``E. Fermi'' University of
  Pisa, Largo B. Pontecorvo 3, 56127 Pisa, Italy}
\newcommand{\ESPCI}{LPEM, ESPCI Paris, PSL Research University, CNRS, Sorbonne Universit\'e, 75005 Paris, France}

\address[a]{\ITPHamburg}
\address[b]{\CTQMAT}
\address[c]{\WZBURG}
\address[d]{\SISSA}
\address[e]{Politecnico di Torino, Turin, Italy}
\address[f]{\Geneve}
\address[g]{\UPISA}
\address[h]{\ESPCI}
\address[i]{\CNRIOM}
% \cortext[AA]{Corresponding author:lorenzo.crippa@uni-hamburg.de}
\cortext[BB] {Corresponding author:giuli@sissa.it}
\cortext[CC]{Corresponding author:bellomia@sissa.it}

\begin{abstract}
  
\end{abstract}

\begin{keyword}
  %% keywords here, in the form: keyword \sep keyword
  Exact diagonalization \sep
  Quantum Impurity models\sep  
  Strongly correlated electrons \sep  
  Dynamical Mean-Field Theory
\end{keyword}

\end{frontmatter}

% Computer program descriptions should contain the following
% PROGRAM SUMMARY.
\noindent
{\bf PROGRAM SUMMARY}
\begin{small}
  \noindent
  \\
  {\em Program Title:}  EDIpack2                                        \\
{\em Licensing provisions:} GPLv3\\
{\em Programming language:}  Fortran, Python \\
{\em Classification:} 6.5, 7.4, 20 \\
{\em Required dependencies:} CMake ($>=3.0.0$), Scifortran, MPI\\
{\em Nature of problem:}. \\
{\em Solution method:} .\\
\end{small}


\tableofcontents

\section{Introduction and Motivation}\label{SecIntro}

A few words about the motivations who led us to develop this
software, possible applications and advantages:


* flexibility: can address generic cases including multi-orbital,
superconducting or spin-non-conserving regimes

* zero and low finite temperatures

* direct access to (well approximated) analytic dynamical functions

* direct access to impurity Fock space quantities

bla bla bla







% ##################################################################
% ##################################################################
% ##################################################################



\section{Structure and derived software}\label{SecStruct}
\NAME is a modular library which contains three principal structures.
At the core is the exact diagonalization solver: \NAME.
Next there is a {\tt EDIpack2ineq} which extends application to the case of multiple
inequivalent impurity problems. Finally, there we provide a Fortran-C
interface, which enables development of additional API or
inter-operability with external libraries.  

\begin{itemize}
\item{\bf EDIpack2.}
This constitutes the  building block of the whole software. This part
implement the  with the Lanczos-based solver for generic quantum
impurity systems encoding different symmetries, i.e. quantum number
conservations and apt to solve multi-orbital problems, also in
presence of coupling to local phonons.  
The \NAME solver has a hierarchical and modular structure: different
sections of the library communicate through a shared memory layer. The
top module of the library is {\tt EDIPACK2} which, once loaded,
enables access to the Fortran API in terms of suitable procedures to
initialize, execute and finalize the solver or to retrieve internal
quantities while making opaque to the user the internal structure of
the library. 
A detailed presentation of the library can be found in
Sec.\ref{SecEDIpack}. 


\item{\bf EDIpack2ineq.}
This part of the software, leveraging on the object oriented concepts
available in modern Fortran, aims to extend the \NAME library to the
case of multiple inequivalent and independent impurity problems. This
is particularly useful while using \NAME as a solver for DMFT in
presence of unit cells with inequivalent atoms, for systems with
somehow broken translational symmetry (e.g. heterostructures, large
supercells, etc.).


\item{\bf EDIpack2 C-bindings.}
\NAME includes a single module implementing a Fortran-C interface of the main
library procedures. The module is developed around the implicit {\tt
  ISO\_C\_BINDING} capabilities of the most recent Fortran
distributions, which enable to translate Fortran procedures directly
to C. In order to overcome all the difficulties related to the internal
structure of the library,  we interfaced all and just the
procedures and the variables exposed to the user. 
This module aims to foster interoperability of \NAME  with different
third party softwares as well as to support development of additional
API. 


% \subsection{Dependent software}
% As a concrete example illustrating the interoperability of the
% software we here illustrate the case of EDIpy2, i.e. the Python API for
% \NAME and present an interface layer to Triqs (Toolbox
% for Reasearch In Quantum Systems). 

\item{\bf EDIpy2.}
This is a simple Python module which provides Python API to the
\NAME Fortran library. This interface is built around the Python
support to C-types, which allows to import the dynamic C-binding
library generated upon building \NAME. The module contains a specific
class, whose methods mirrors through  duck-typing all the available
procedures of \NAME as well as it gives access to relevant shared
control variables.




\item{\bf EDIpack2Triqs.}
This is a thin interface layer from \NAME to Triqs,
built around the Python API of the \NAME library. The exact
diagonalization solver is encapsulated in a dedicated class,
containing the necessary methods to initialize and run a single
instance of the solver. The interface also includes a specific class
encompassing the effective discretized bath structure as well as their 
optimization methods.  

  
\end{itemize}







% ##################################################################
% ##################################################################
% ##################################################################

\section{Installation}\label{SecInstall}
The installation of \NAME is available through CMake which ensures
multi-platforms compabitility and dependencies resolution.  
The software builds into two distinct libraries.
The main one is {\tt  libedipack.a} which, alongside the generated Fortan
modules, wraps the \NAME software possibly including support for  
inequivalent impurities.
A second dynamic library, {\tt libedipack\_cbinding.so}, enables interoperability through
specific bindings to the C programming language.    

\subsection{Dependencies}
\NAME essentially depends on two external libraries.
\begin{itemize}
\item {\bf SciFortran}: an open-source Fortran library to support
  mathematical and scientific software development. 
\item {\bf MPI} (optional): a distributed memory parallel communication layer with support to modern Fortran compiler.
\end{itemize}
 
SciFortran provides a solid development platform enabling access to
many algorithms and functions, including standard linear algebra
operations and high-performance Lanczos based algorithms. This
greatly reduces code clutter and development time.
The use of distributed memory parallel environment, although optional,
is required to access scalable parallel diagonalization algorithms
which speed up calculations for large dimensional systems. 

\subsection{Build and Install}
\subsubsection{Source}
The software can be installed from source as follows. The source can
be retrieved directly from its GitHub repository, for instance using:
\begin{lstlisting}[style=mybash]
git clone https://github.com/edipack/EDIpack2.0 EDIpack2
\end{lstlisting}
Then, assuming to be in the software directoru, a conventional
out-of-source building is performed using two different compilations
backends.

\begin{itemize}
  \item {\bf GNU Make}\\
This is the default CMake workflow:
\begin{lstlisting}[style=mybash]
mkdir build
cd build
cmake ..
make -j
make install
\end{lstlisting}


\item{\bf Ninja}

An alternative workflow employs the Ninja building backend with
Fortran support. Ninja is generally faster and automatically supports
multi-threaded building:
\begin{lstlisting}[style=mybash]
mkdir build
cd build
cmake -GNinja ..
ninja
ninja install
\end{lstlisting}
\end{itemize}

\noindent
The CMake configurations can be further tuned using the following variables:
\begin{center}
\begin{tabular}{ l|l|l } 
 \hline
  {\bf Option}               & {\bf Scope} & {\bf Value} \\
  \hline
  -D{\bf PREFIX}          & Install directory  & $\sim$/opt/EDIpack2/TAG/PLAT/BRANCH\\
  -D{\bf USE\_MPI}       & MPI support  &  True/{\color{red}False}\\
  -D{\bf WITH\_INEQ}   & Inequivalent impurities support & {\color{red}True}/{False}\\
  -D{\bf VERBOSE}      & Verbose CMake output & {\color{red}True}/{False}\\ 
  -D{\bf BUILD\_TYPE} & Compilation flags & {\color{red}RELEASE}/TESTING/DEBUG/AGGRESSIVE \\
 \hline
\end{tabular}
\end{center}

The default target builds and install either the main library and the C-binding.
However, a specific building for each library is available specifying
the required target. A recap message is printed at the end of the
CMake configuration step. 

\subsubsection{Anaconda}
As an alternative we provide for both Linux and OSx systems
installation through Anaconda packages into a virtual
environment containing Python ($>3.10$).

The Conda package installation procedure reads:
\begin{lstlisting}[style=mybash]
conda create -n edipack
conda activate edipack
conda install -c conda-forge -c edipack edipack2
\end{lstlisting}
\noindent
which installs a bundle of Scifor and \NAME libraries together with
specific {\tt pkg-config} configurations files which can be used to
retrieve compilation and linking flags. 


\subsection{OS Loading}
In oder to avoid possible conflicts or require administrative
privileges, the building step results get installed by default in a user home
directory, specified by the CMake variable {\tt PREFIX}.
In doing so, however, one misses the chance of automatic loading into
the operative system.

We offer different strategies to perform this action:
\begin{enumerate}
\item  A CMake generated configuration file for environment module
  which allows to load and unload the library at any time. This is
  preferred solution for HPC systems. 
\item A CMake generated bash script to be sourced (once or
  permanently) in any shell session to add \NAME library to the
  default environment.
\item A CMake generated pkg-config configuration file to be added in
  the pkg-config path itself.  
\end{enumerate}
An automatically generated recap message with all instructions is
generated at the end of the installation procedure. 



\subsection{Python API}
\subsubsection{Build from source}
EDIpy2, i.e. the Python API of EDIpack2, is available as a stand-alone
module which depends on both \NAME and SciFortran. The package can be
obtained from the repository
\href{https://github.com/EDIpack/EDIpy2.0}{EDIpy2}.

\begin{lstlisting}[style=mybash]
git clone https://github.com/edipack/EDIpy2 EDIpy2
cd EDIpy2
pip install . 
\end{lstlisting}
In some more recent Python distribution the flag {\tt
  --break-system-packages} might be required to complete
installation or a virtual environment should be used instead. 

\subsubsection{Anaconda}
As for EDIpack2, also the Python API in EDIpy2 are available through
Anaconda packaging. In this case the resolution of the dependencies is
taken care from Conda itself:

\begin{lstlisting}[style=mybash]
conda create -n edipack
conda activate edipack
conda install -c conda-forge -c edipack edipack2
\end{lstlisting}




\subsection{TRIQS interface}
A purely Python \NAME to Triqs interface is available, leveraging on
the C-bindings and Python API. The corresponding module depends on
\NAME (which ultimately depends on SciFortran) and Triqs.
Assuming the two software are correctly installed in the OS, the
EDIpack2Triqs interface is installed as follows:

\begin{lstlisting}[style=mybash]
git clone https://github.com/krivenko/edipack2triqs
cd edipack2triqs
pip install .
\end{lstlisting}






% ##################################################################
% ##################################################################
% ##################################################################


% $H_{e-ph}= \sum_{\a\sigma} g_\a
% d^+_{\a\sigma}d_{\a\sigma}(b+b^+)$. 


\section{Implementation}\label{SecEDIpack}
Here we present an overview of the implementation of the
different parts of the \NAME library. 

\subsection{The quantum impurity problem}\label{sSecQIM}
We consider a general quantum impurity problem defined by the
following Hamiltonian:
$$
\hat{H} = \hat{H}_{imp} + \hat{H}_{bath} + \hat{H}_{hyb} + \hat{H}_{ph} + \hat{H}_{e-ph}
$$
which describes a  multi-orbital interacting quantum
impurity coupled to an electronic bath and to local, i.e. Holstein,
phonons. We assuming for the moment that no particular symmetry
holds. The impurity part of the Hamiltonian reads: 
\begin{equation}\label{Himp}
  \begin{split}
    \hat{H}_{imp} & = \hat{H}^0_{imp} + \hat{H}^{int}_{imp}\\
    \hat{H}^0_{imp} & =
    \sum_{\a\b\sigma\sigma'}h^{0}_{\a\b\sigma\sigma'}d^{+}_{\a\sigma}d_{\b\sigma'}\\
    %
    \hat{H}^{int}_{imp} &=U\sum_{\a}n_{\a\uparrow}n_{\a\downarrow}+U'\sum_{\a\neq \b}n_{\a\uparrow}n_{\b\downarrow}+(U'-J)\sum_{\a<\b,\sigma}n_{\a\sigma}n_{\b\sigma}\\
    &{\phantom =}- J_X\sum_{\a\neq
      \b}d^{+}_{\a\uparrow}d_{\a\downarrow}d^{+}_{\b\downarrow}d_{\b\uparrow}+J_P\sum_{\a
      \neq
      \b}d^{+}_{\a\uparrow}d^{+}_{\a\downarrow}d_{\b\downarrow}d_{\b\uparrow}\\
    % 
\end{split}
\end{equation}

where $d_{\a\sigma}$ ($d^+_{\a\sigma}$) are the destruction (creation)
second-quantization operators for impurity electrons in the
orbital $\alpha=1,\dots,N_\a$, with $N_\a$ the number of orbitals,
with spin $\sigma=\up,\dw$ and whose occupation is described
by the  operator  
$n_{\alpha\sigma}=d^{+}_{\alpha\sigma}d_{\alpha\sigma}$. 
The non-interacting internal structure of the impurity is described by
the $h^{0}_{\a\b\sigma\sigma'}$ matrix. 
$\hat{H}^{int}$ describes the  local multi-orbital
interaction~\cite{Georges2013ACMP} which, for simplicity, we take as a
generalized Hubbard-Kanamori form.  
The first three terms represent the density-density part of the
interaction, where $U$ is the local intra-orbital Coulomb repulsion,
$U'$ the inter-orbital one and $J$ the Hund's coupling~\cite{Georges2013ACMP}.  
The  remaining two terms are, respectively, the spin-exchange and
pair-hopping which we considered with their respective independent
couplings $J_X$ and $J_P$.
In the case $N_\a=3$ a fully symmetric $SU(3)_{orbital}\times SU(2)_{spin}\times
U(1)_{charge}$ form of the interaction is obtained by setting $U'=U-2J$ and
$J_X=J_P=J$~\cite{Georges2013ACMP}. Different choices, preserving part
of the combined symmetry group, can be made for other values of
$N_\a$~\cite{Georges2013ACMP}. 


The bath part and its coupling to the impurity has the form: 
\begin{equation}\label{Hbath}
  \begin{split}
    \hat{H}_{bath} &=
    \sum_p\sum_{\a\b\sigma\sigma'}h^p_{\a\b\sigma\sigma'}a^{+}_{p\a\sigma}a_{p\b\sigma'}\\
    %
    \hat{H}_{hyb} &= \sum_p\sum_{\a\b\sigma\sigma'}V^p_{\a\b\sigma\sigma'}d^{+}_{\a\sigma}a_{p\b\sigma'}+H.c. \\
\end{split}
\end{equation}
where $p=1,\dots,N_{bath}$ is an index running over a finite number of
bath elements, $a_{p\alpha\sigma}$ ($a^+_{p\alpha\sigma}$) are the destruction (creation) operators for
the bath electrons with index $p$, with orbital $\alpha$ and
spin $\sigma$.
The  properties of each bath level are described by the
matrices $h^p_{\a\b\sigma\sigma'}$. As such any bath element can be
composed of several electronic levels according the bath topology,
which will be discussed further in the following.
Each bath level couples to the impurity with an amplitude
$V^p_{\a\b\s\sigma'}$ which we allow to couple different orbital and
opposite spins.   

Finally, the electron-phonon part of the quantum impurity problems is
described by the Hamiltonian terms: 
\begin{equation}\label{Hph}
  \begin{split}
    \hat{H}_{ph}&=\sum_q \omega_{0q} b_q^+b_q\\
    % 
    \hat{H}_{e-ph} &= \sum_q\sum_{\a\b\sigma} g_{\a\b} d^+_{\a\sigma}d_{\b\sigma}(b_q+b_q^+)
\end{split}
\end{equation}
where $q=1,\dots,N_q$ indexes the number of local phonons, $b_q$
($b_q^+$) are the destruction (creation) operators for the phonon $q$
with frequency $\omega_{0q}$. The matrix  $g_{\a\b}$ expresses is the electron-phonon coupling. 
Although feasible, dealing with more than one phonon mode becomes
quickly computationally very demanding, thus in the rest of the this
work we shall consider $N_q=1$. 


In the following we consider a bath discretized into a  number
of bath degrees of freedom and a finite number of available phonons,
to cut-off the unbounded dimensions of the local phonons Hilbert space.


More specifically, we consider a system composed of $N_{imp}=1$
impurities, i.e. a single impurity problem, $N_{bath}$ bath elements
and $N_{ph}$ phonons. The size of the system is determined by
the number of phonons (fixed) and that of {\it electronic} levels, i.e. levels with a local
electronic Hilbert space
$\HH_e=\{\ket{0},\ket{\up},\ket{\dw},\ket{\up\dw} \}$. 
Due to is internal structure, the single impurity contains
$N_i= N_\a$ electronic levels.
The total number of levels is then determined by
the electronic levels in the bath $N_b$. This is a function of the bath topology and $N_{bath}$,
i.e. the number of bath elements. In the simplest case each bath
element corresponds to an independent electronic levels coupled to the
impurity, thus $N_b\equiv N_{bath}$. 
We indicate with $N_s=N_i + N_b$ the total number of electronic levels. 

The setup of the general quantum impurity problem is implemented in
different parts of the \NAME software. The dimensions of the system
are controlled by input variables {\tt Nspin}$=N_\sigma$,
{\tt Norb}$=N_\a$ and {\tt Nbath}$=N_{bath}$ in {\tt
  ED\_INPUT\_VARS}. These are used to
determine the variables {\tt Ns}$=N_s$ and $N_b$, defined in the global
memory pool {\tt ED\_VARS\_GLOBAL}, using the functions contained
in {\tt ED\_SETUP}. 
The user can define the local non-interacting Hamiltonian
$h^0_{\a\b\s\s'}$ using the function {\tt ed\_set\_hloc} in {\tt ED\_AUX\_FUNX}.
The matrix is then stored in the internal memory and shared throughout the
code.
On the other hand the setup of the bath matrices $h^p_{\a\b\s\s'}$
requires a more involved procedure which will be illustrated in
\secu{sSecBath}. 


\subsection{The Fock basis states}\label{sSecBasis}
The Fock space of the quantum impurity problems is defined as
$\FF=\FF_e\otimes \FF_{ph}$, with $\FF_e=\bigoplus_{n=0}^{N_s}
S_-\HH_e^{\otimes n}$ the electronic Fock space,  $\FF_{ph}=\bigoplus_{n=0}^{N_q}S_+\HH_{ph}^{\otimes n}$ the
phonon Fock space,  $\HH_{ph}=\{\ket{0},\ket{1},\dots,\ket{N_{ph}}\}$ is the local phonon Hilbert space
and ($S_-$)  $S_+$ the (anti-)symmetrization operator.  
The total dimension of the Fock space is
$D=D_e\cdot D_{ph}=4^{N_s}\cdot (N_{ph}+1)$ making the exponential
growth with the number of electron levels transparent. 
The quantum states in the space $\FF$ are naturally represented in
terms of occupation number formalism of the second quantization,
i.e. the Fock basis.
For a system of $N_s$ electrons each Fock state
reads $\ket{p}\ket{\vec{n}}$ with
$$
\ket{\vec{n}}=\ket{\vec{n}_\up}{\vec{n}_\dw}=\ket{n_{1\up},\dots,n_{N_s\up},n_{1\dw},\dots,n_{N_s\dw}}
$$ 
where $p=1,\dots,N_{ph}$ is the number of local phonons while $n_{a\sigma}=0,1$ signals the absence or the
presence of an electron with spin $\sigma$ at the level $a$.
The electronic part of the Fock state $\ket{\vec{n}}$ is represented as a string of
zeros and ones of length $2N_s$. Thus, any such state can  be encoded
in a computer using a sequence of $2N_s$ bits or, analogously, as a
given integer $I=0,\dots 2^{2N_s}-1$ so that $\ket{\vec{n}}=\ket{I}$.  
Together with the basis states one defines  destruction and creation 
operators, respectively $c_{a\s}$ and $c^+_{a\s}$, which acts on the
Fock space as: 
$\ket{\vec{n}}$ as:  
\begin{align*}
  c_{a\sigma}\ket{\vec{n}} &=
    \begin{cases}
      (-1)^{\#_{a\sigma}}\ket{\dots,n_{a\sigma}\!-\!1,\dots}
      &\text{if $n_{a\sigma}\!=\! 1$}\\
      0 &\text{otherwise}
    \end{cases};\qquad
    c^{+}_{a\sigma}\ket{\vec{n}} &=
     \begin{cases}
      (-1)^{\#_{a\sigma}}\ket{\dots,n_{a\sigma}\!+\!1,\dots}
      & \text{if $n_{a\sigma}\!=\! 0$}\\
      0 & \text{otherwise}
    \end{cases}    
\end{align*}
where $\#_{a\sigma}=\sum_{b\sigma'<a\sigma} n_{b\sigma'}$ takes care
of the fermionic sign imposed by Pauli principle. 

The Fock states and operators implementation can be found in {\tt
  ED\_AUX\_FUNX}. There we define the bitwise action of generic fermionic creation
and annihilation operators {\tt CDG} and {\tt C}, the binary
decomposition {\tt bdecomp} required to reconstruct the Fock state as
bits sequence and other accessory functions. 

\subsection{Conserved quantum numbers}\label{sSecQNs}
In order to circumvent the exponential scaling of the dimensions of
the problem scales it is necessary to take into account suitable symmetries.
Indeed, considering operators ${\cal Q}$ such that $[H, {\cal Q}]=0$
reduces of the Fock space into several symmetry sectors
labelled by given quantum numbers $\vec{Q}$. 
In the context of quantum impurity problems two symmetries are often considered: i)
conservation of the total occupation $N$ and ii) the
conservation of the total magnetization $S_z$. Although the total spin
operator $S^2$ can also be conserved, the difficult  implementation
and the marginal gain makes it often non convenient to include this symmetry.
In \NAME we consider three different cases which are controlled by the
input variable {\tt ed\_mode}={\bf normal}, {\bf superc}, {\bf
  nonsu2}. 

The {\bf normal} case deals with independent conservation of the total occupation $N$
and the total magnetization $S_z$ or, equivalently, the total number of electrons with spin up $N_\up$ and down
$N_\dw$. Optionally, we consider the case in which the symmetry
applies separately for each orbital and spin,
i.e. $\vec{N_\s}=[N^1_\s,\dots,N^{N_\a}_\s]$. This special case has been
extensively discussed in \onlinecite{Amaricci2022} so it won't be covered in
this work.
%
The {\bf superc} case deals with the conservation of the total
magnetization only, so that total charge may not be conserved. This
case includes a description of $s$-wave superconductivity, featuring
intra- and inter-orbital components.
%
Finally, the {\bf nonsu2} case consider the conservation of the total
charge, whereas the spin symmetry group is not fully
conserved. Although there many possible realization of this scenario,
this particularly applies to the presence of local spin-orbit coupling
$\vec{L}\cdot\vec{S}$~\cite{something}, the emergence of in-plane spin ordering~\cite{KM} or
in-plane spin-triplet exciton condensation~\cite{ExcitonPRB,Amaricci,Blason}.  
%
From a computational point of view the construction of a symmetry
sector corresponds to the determination of a injective map
$\MM:\SS_{\vec{Q}}\rightarrow \FF$ relating the states $\ket{i}$
belonging to the sector $\SS_{\vec{Q}}$ to the states $\ket{I}$ in the
Fock space. Operatively, the map corresponds to an integer rank-1
array of dimension $D_\SS$ which is the {\it dimension} of the
sector. 
The table~\ref{TabSector} summarizes the properties of the symmetry
sectors. 

\begin{table}%[ht]
  \label{TabSector}
\begin{center}
\begin{tabularx}{\linewidth}{ |X|X|X| } 
 \hline
  {\tt ed\_mode} & {\it Quantum Numbers} & {\it Sector Dimension} \\
  \hline
  {\bf normal} & $[N,S_z]\equiv[N_\up,N_\dw]$ &
                                                $\binom{N_s}{N_\up}\binom{N_s}{N_\dw}$
  \\
  \hline
  {\bf superc} & $S_z\equiv N_\up-N_\dw$ &  $\sum_m 2^{N_s-S_z-2m}\binom{N_s}{N_s-S_z-2m}\binom{S_z+2m}{m}$
  \\
  \hline
  {\bf nonsu2} & $N \equiv[N_\up+N_\dw$ & $\binom{2N_s}{N}$ \\ 
 \hline
\end{tabularx}
\end{center}
\caption{Ciao}
\end{table}


The {\bf normal} case requires a brief remark. Because of the
independent conservation of $N_\up$ and $N_\dw$, the local Hilbert
space and the electronic Fock can be factorizes as, respectively,
$\HH=\HH_\up\otimes\HH_\dw$, $\FF_e = \FF_{e\up}\otimes \FF_{e\dw}$.  
Accordingly any Fock state is written as $\ket{\vec{n}_\up}\ket{\vec{n}_\dw}$, the symmetry sector can be written as  $\SS_{\vec{Q}} = \SS_{N_\up}\otimes
\SS_{N_\dw}$ and, correspondingly, the sector map splits in two
mutually exclusive ones $\MM = \MM_\up
\otimes \MM_\dw$.
Thus, each state $\ket{i}=\ket{i_\up}\ket{i_\dw}$ of the
sector is labelled by two integers $[i_\up,i_\dw]$, 
$i_\sigma=1,\dots,D_{\SS_\sigma}$ such that $i=i_\up + i_\dw
D_{\SS_\dw}$. The map $\MM$ connects any such state to a Fock state
$\ket{I}=\ket{I_\up}\ket{I_\dw}$ labelled by two integers
$[I_\up,I_\dw]$ as $I=I_\up +   I_\dw 2^{N_s}$. For a thorough
discussion about Fock basis organization in this case see
\onlinecite{amaricci2022}. 

The presence of a symmetry induces a factorization of the Fock space,
in turn inducing a block diagonal form to the Hamiltonian matrix.
Each block, labelled by the quantum numbers $\vec{Q}$, has dimension
$D_{\SS(\vec{Q})}$. The sector Hamiltonian matrix $H_\SS$ is represented in the
basis $\ket{i}\in\SS_{\vec{Q}}$ as a sparse matrix. In the {\bf
  normal} case $H_\SS$ takes a particularly symmetric form thanks to
the product structure of the sector and its map~\cite{amaricci2022}.
The analysis of the spectrum is then reconducted to the inspection of
the Hamiltonian in each symmetry sector. Should particular constraint
holds the search can be limited to only particular sector, further
reducing the computational cost. 

Although the sectors have dimensions much smaller than the full Fock
space, for large systems storing the Hamiltonian matrix in the memory
can still be highly inefficient.
In such cases, Krylov or Lanczos methods~\cite{Lanczos1950JRNBSB,Lin1993CIP,Lehoucq1998,Maschhoff1996} can
be implemented using a storage-free algorithm, performing the
necessary linear operations on-the-fly.
This solution has generally a negative impact on the execution
time, however this can be well compensated by scaling in a distributed 
parallel framework.


The object {\tt sector}, defined globally in {\tt
  ED\_VARS\_GLOBAL}, contains all the informations characterizing the
symmetry sector, its dimensions, its quantum numbers and an
implementation of the map $\MM$. The constructor/destructor are defined {\tt
  ED\_SECTORS} module with the function {\tt build\_sector}/{\tt
  delete\_sector} using different algorithms according to the nature
of the quantum numbers $\vec{Q}$ as reported in the following code
snippet.
\setbox0=\hbox{%
  \begin{minipage}{0.3\linewidth}
    \center{\bf normal}
\begin{lstlisting}[style=fstyle,frame=none,numbers=none,basicstyle={\scriptsize\ttfamily}]
i=0
do Iup=0,2**Nbit-1     
  nup_ = popcnt(Iup) 
  if(nup_ /= Nups(1))cycle
  i = i+1
  H(iud)%map(i) = lup
enddo
i=0
do Idw=0,2**Nbit-1
  ndw_= popcnt(Idw)
  if(ndw_ /= Ndws(1))cycle
  i = i+1
  H(iud+Ns)%map(i) = Idw
enddo
\end{lstlisting}
\end{minipage}
}
\savestack{\listingA}{\box0}

\setbox0=\hbox{%
  \begin{minipage}{0.3\linewidth}
    \center{\bf superc}
\begin{lstlisting}[style=fstyle,frame=none,numbers=none,basicstyle={\scriptsize\ttfamily}]
i=0
do Idw=0,2**Ns-1
  ndw_= popcnt(idw)
  do Iup=0,2**Ns-1
    nup_ = popcnt(iup)
    sz_  = nup_ - ndw_
    if(sz_ /= self%Sz)cycle
    i=i+1
    self%H(1)%map(i) = &
        Iup+Idw*2**N
  enddo
enddo

\end{lstlisting}
\end{minipage}
}
\savestack{\listingB}{\box0}

\setbox0=\hbox{%
  \begin{minipage}{0.3\linewidth}
    \center{\bf nonsu2}
\begin{lstlisting}[style=fstyle,frame=none,numbers=none,basicstyle={\scriptsize\ttfamily}]
i=0
do Idw=0,2**Ns-1
  ndw_= popcnt(Idw)
  do Iup=0,2**Ns-1
    nup_ = popcnt(Iup)
    nt_  = nup_ + ndw_
    if(nt_ /= self%Ntot)cycle
    i=i+1
    self%H(1)%map(i) = &
        Iup+Idw*2**Ns
  enddo
enddo
\end{lstlisting}
\end{minipage}
}
\savestack{\listingC}{\box0}

\begin{tabular}{c|c|c}\label{list1}
  \stackinset{l}{}{t}{}{}{\listingA} &
\stackinset{l}{}{t}{}{}{\listingB} &
\stackinset{l}{}{t}{}{}{\listingC} \\
\end{tabular}
%
Alongside these definitions, this module additional functions to
retrieve sector index or quantum number informations. Another set of
key functions concern the application of arbitrary linear combinations
of Fock operators  to a given vector $\ket{v}\in\SS$, i.e.
$\OO\ket{v} = \sum_i a_i C^{\dagger(p_i)}_{\a_i,\s_i}\ket{v}$ with
$a_i\in\CCC$ and $p_i=0,1$. These important operations which depend on
the sector informations are implemented
in the {\tt apply\_op\_C}, {\tt apply\_op\_CDG}, {\tt
apply\_Cops} functions within {\tt ED\_SECTORS}. 





\subsection{Classes}
The use of suitable objects enormously simplifies the  implementation
of crucial mathematical concepts aking to the diagonalization of the
quantum impurity problems. Here we discuss three main classes which
are used in the code.    
{\color{red} Text to be revised}

\subsubsection{Sparse matrix}\label{CodeSparseMatrix}
A sparse matrix storage is performed using a
dedicated custom class, contained in the \texttt{SPARSE\_MATRIX} module. 
The class defines a \texttt{sparse\_matrix\_csr} object as a 
simplified hash-table. The keys corresponds to the rows of the matrix
while the value is associated to a pair dynamical arrays, containing values and
columns location of the non-zero elements of the sparse matrix.
The \texttt{sparse\_matrix\_csr} object can be stored either serially,
i.e. one copy per process, or be parallel distributed assigning a number of keys/values to each
process.
The elements are progressively stored in the dynamic arrays using
\texttt{sp\_insert\_element} procedure, ultimately making use of the Fortran intrinsic
\texttt{move\_alloc}.
This ensures a faster execution compared to implicit  
reallocation, i.e. \texttt{vec=[vec,new\_element]}.
This solution enables to deal with the a priori unknown number of
non-zero elements on each row, to optimize the memory footprint and
to guarantee $O(1)$ access  to any element of the matrix, which are
crucial aspect to speed-up the execution of the MVP. 

\subsubsection{Eigenspace}\label{CodeEigenspace}
This class, contained in \texttt{ED\_EIGENSPACE} implements a
dedicated storage for the eigenvalues and eigenvectors of the quantum impurity Hamiltonian
The class defines the object \texttt{sparse\_espace}, an  
ordered linked list storing the eigenvalue (the sorting key), the
eigenvector and the corresponding QNs. To save memory the eigenvectors
are automatically distributed to all processors in shares of the right
size according to the nature of the quantum numbers $\vec{Q}$. 

For zero temperature calculations only the groundstates (with degeneracies) are stored
in the list.
For a finite temperature the excited states need to be stored too.
In order to avoid unbounded growth of the list we adopt an 
truncation mechanism. In the first call we collect a number 
\texttt{lanc\_nstates\_sector} of states from each sector, up to a
given maximum number \texttt{lanc\_nstates\_total}, both set on input.  
The list is truncated by keeping the states which
fulfil the condition $e^{-\beta(E_i-E_0)} < \mathtt{cutoff}$, where
$E_i$ is the energy of the $i^{\rm th}$ state in the list, $E_0$ is the
groundstate energy,  $\beta=1/T$ is the inverse temperature ($k_B=1$) and \texttt{cutoff}
is an input parameter fixing an a priori energy threshold.
%  
Annealing is achieved by successive diagonalization of the problem.
The numbers of states required to any sector $\SS$ contributing to the list is increased by
\texttt{lanc\_nstates\_step} or it is reduced otherwise. After few calls
(of the order of ten) the distribution among the sectors of the
numbers of states reaches a steady state.
The corresponding annealed list contains all and just the states
contributing to the spectrum up to the required energy threshold.
A histogram of the number of states for each sector is produced after
each diagonalization to check the evolution of their distribution.



\subsubsection{GFmatrix}
One of the main goal of the code is to evaluate dynamical correlations
functions (DCF) $\ibra \TT[ A(t) A^+ ]\iket$. As we shall see in the following, using Krylov method it is
possible to express the dynamical correlations in terms of a suitably
truncated Kallen-Lehmann spectral sum of the form
$\tfrac{1}{Z}\sum_n e^{-\beta E_n} \sum_{m=1}^{N} \tfrac{|w_{mn}|^2}{ z
  - dE_{mn}}$ where $w_{mn}$ is a weight set by the 
projection of the $m^{\rm th}$ eigenstate onto the $n^{\rm th}$
component of the Krylov basis (which reduce the sector Hamiltonian
into a partial tri-diagonal form) while $dE_{mn}=E_m-E_n$ is an excitation energy. 
The {\tt ED\_GFMATRIX} module contains a class which efficiently store all
the {\it weights} $w_{mn}$ and {\it poles} $dE_{mn}$ contributing to
a specific correlation function. Specifically, the {\tt
  gfmatrix} object implements a dynamical multi-layer data structure
storing any DCF as the set of all the weights and poles,
from any contributing eigenstate  and for any
combination of operators appearing in its definition.
The use of this class enables the istantantaneous evaluation of a
given  DCF  $\GG(z)$ for any $z\in\CCC$ the complex frequency plane
using a suitable compressed form. 
  
\subsection{Bath parametrization}\label{sSecBath}
The bath parametrization is a key feature in determining the properties
of the quantum impurity problem.
Following the structure of Eq.~\ref{Hbath} the bath can be
parametrized by two terms: the Hamiltonian matrices $h^p$ and the
amplitudes $V^p$, for $p=1,\dots,N_{bath}$.
Internally, the bath is represented by a dedicated object {\tt
  effective\_bath} defined in {\tt ED\_VARS\_GLOBAL}. 
On the
user side all parameters are packed into a rank-1 array of
doubles handled using reverse communication strategy.
This ensures that a local array is always conserved by the user, while
it prevents direct access to the internal copy.


The bath topology, i.e. the links between the $N_b$ electronic levels
assigned to the bath, is determined by the input variable {\tt
  bath\_type} among 4 different choices: {\bf normal}, {\bf hybrid},
{\bf replica} and {\bf general} (see Fig.\ref{figBaths}).  
%
\paragraph{{\tt bath\_type}={\bf normal}} The bath is formed out of $N_{bath}$
electronic levels coupled to each of the impurity orbital. The total
count of bath levels is $N_b = N_\a N_{bath}$. The bath Hamiltonan
matrices include a parametrization diagonal in the orbital and spin space: 
$h^p_{\a\b\s\s'}=\varepsilon_{\a\s}\delta_{\a\b}\delta_{\s\s'}$.
If {\tt ed\_mode}={\bf superc} one needs to account for anomalous
amplitudes connecting bath levels with opposite spins. So we consider
an additional set of parameters, diagonal in orbital space but
off-diagonal in the spins:
$h^p_{\a\b\s\s'}=\Delta^p_{\a}\delta_{\a\b}\delta_{\s \overline{\s}}$.
This choice corresponds to consider, for every orbital component,
bath matrices with the following structure in the Nambu space:
$\hat{h}^p_{\a\b} = \e_{\a}\delta_{\a\b}\tau_0 +
\Delta_{\a}\delta_{\a\b}\tau_x$. 
The hybridization amplitudes between the impurity and the bath levels
include, for any value of {\tt ed\_mode} a set of parameters diagonal in both
spin and orbital space: $V^p_{\a\b\s\s'}=V^p_{\a\s}\delta_{\a\b}\delta_{\s\s'}$.
If {\tt ed\_mode}={\bf nonsu2} the an additional set including terms
describing spin-flip processes (as total magnetization is not
conserved) should be included $V^p_{\a\b\s\s'} =
W^p_{\a}\delta_{\a\b}\delta_{\s \overline{\s}}$. 



\paragraph{{\tt bath\_type}={\bf hybrid}} The bath is formed out of
$N_{bath}$ coupled to all the impurity levels, correspondingly
$N_b\equiv N_{bath}$ is the total count of electronic bath levels. 
The main parametrization of the bath Hamiltonian matrices is still
diagonal in both orbital and spin space, i.e.
$h^p_{\a\b\s\s'}=\varepsilon_{\a\s}\delta_{\a\b}\delta_{\s\s'}$.
As for the previous case, the {\bf superc} mode requires the inclusion
of a further set of parameters taking care of the anomalous components:
$h^p_{\a\b\s\s'}=\Delta^p_{\a}\delta_{\a\b}\delta_{\s
  \overline{\s}}$.
The key difference with respect to the {\bf normal} case lies in the
off-diagonal nature of the hybridization amplitudes:
$V^p_{\a\b\s\s'}=V^p_{\a\b\s}\delta_{\s\s'}$. If total magnetization
is not conserved, i.e. for {\tt ed\_mode}={\bf nonsu2}, an additional
set of parameters should be included to describe spin-flip processes:
$V^p_{\a\b\s\s'} = W^p_{\a\b}\delta_{\s \overline{\s}}$. 
These sets of hybridization parameters allow to capture the effects of locally
hybridized impurity orbitals. This comes at the cost of a
slightly harder optimization process (see \secu{sSecFit}) specially
for systems with reduced number of available bath levels with respect
to the impurity. 

\paragraph{{\tt bath\_type}={\bf replica}/{\bf general}} A more flexible
parametrization of the bath is represented by this topology. The
original idea of this approach is to give to each bath element a structure which {\it replicates}
that of the impurity while keeping a diagonal coupling between bath
elements and impurity. This offloads the difficulties related to the
representation and optimization of strucured quantum impurities to the
bath Hamiltonan rather than the hybridizations.
Taking a sligthly more general point of view we consider a user
defined matrix basis $\{ \Gamma^\nu \}_{\nu=1,\dots,N_{sym}}$ in the (Nambu-)spin-orbital
space and parametrize any bath Hamiltonian as:
$$
h^p_{\a\b\s\s'} = \sum_{\nu=1}^{N_{sym}} \lambda^p_\nu \Gamma^\nu_{\a\b\s\s'}
$$
where $\lambda^p_\nu\in\RRR$ are suitable variational parameters. 
The choice of the matrix basis can be inspired either by the internal structure
of the quantum impurity, i.e. $\hat{h}^0$, or be determined
case-by-case by the properties of the problem.
The total number of electronic levels used to describe the bath is in
this case: $N_b = N_{sym} N_{bath}$. 
For the {\bf replica}  topology the coupling between the impurity and
each bath elements is diagonal in the spin, orbital and internal bath
structure: $V^p_{\a\b\s\s'} = V^p$. The
{\bf general} setup introduces a generalization introducing a
dependence on the internal spin and orbital indices: $V^p_{\a\b\s\s'}
= V^p_{\a\s}\delta_{\a\b}\delta_{\s\s'}$. 


All the procedures concerning the bath are grouped into a set of
modules wrapped by {\tt ED\_BATH}.

* get dimension

* replica/general bath setup

\subsection{Lanczos based Diagonalization}\label{sSecHam}

  

\subsection{Dynamical correlation functions}\label{sSecGF}

\subsection{Observables}\label{sSecObc}

\subsection{Reduced impurity density matrix}\label{sSecRDM}


\subsection{Bath Functions}\label{sSecFunc}

\subsection{Bath Optimization}\label{sSecFit}

\subsection{Input/Output}\label{sSecIO}




\section{Inequivalent impurities}

\section{C-bindings}\label{SecCbind}

\section{Python API}

\section{Triqs interface}\label{SecEDI2Triqs}


% ##################################################################
% ##################################################################
% ##################################################################


\section{Usage}\label{SecUsage}
\subsection{Bethe lattice DMFT (Fortran API)}
\subsection{Attractive Hubbard model (Python API)}
\subsection{Multi-orbital Hubbard (Triqs)}









% ##################################################################
% ##################################################################
% ##################################################################





\section{Conclusions}





% ##################################################################
% ##################################################################
% ##################################################################





\section*{Acknowledgements}



%% References with bibTeX database:
% \section*{References}
\bibliographystyle{elsarticle-num}
\bibliography{references}






\end{document}








